// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Common utils for AST.
   * @author Gyandeep Singh
   */
  'use strict';
  /**
   * Gets the name and kind of the given function node.
   *
   * - `function foo() {}`  .................... `function 'foo'`
   * - `(function foo() {})`  .................. `function 'foo'`
   * - `(function() {})`  ...................... `function`
   * - `function* foo() {}`  ................... `generator function 'foo'`
   * - `(function* foo() {})`  ................. `generator function 'foo'`
   * - `(function*() {})`  ..................... `generator function`
   * - `() => {}`  ............................. `arrow function`
   * - `async () => {}`  ....................... `async arrow function`
   * - `({ foo: function foo() {} })`  ......... `method 'foo'`
   * - `({ foo: function() {} })`  ............. `method 'foo'`
   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`
   * - `({ [foo]: function() {} })`  ........... `method`
   * - `({ foo() {} })`  ....................... `method 'foo'`
   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`
   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`
   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`
   * - `({ [foo]: function*() {} })`  .......... `generator method`
   * - `({ *foo() {} })`  ...................... `generator method 'foo'`
   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`
   * - `({ foo: async function() {} })`  ....... `async method 'foo'`
   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`
   * - `({ [foo]: async function() {} })`  ..... `async method`
   * - `({ async foo() {} })`  ................. `async method 'foo'`
   * - `({ get foo() {} })`  ................... `getter 'foo'`
   * - `({ set foo(a) {} })`  .................. `setter 'foo'`
   * - `class A { constructor() {} }`  ......... `constructor`
   * - `class A { foo() {} }`  ................. `method 'foo'`
   * - `class A { *foo() {} }`  ................ `generator method 'foo'`
   * - `class A { async foo() {} }`  ........... `async method 'foo'`
   * - `class A { ['foo']() {} }`  ............. `method 'foo'`
   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`
   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`
   * - `class A { [foo]() {} }`  ............... `method`
   * - `class A { *[foo]() {} }`  .............. `generator method`
   * - `class A { async [foo]() {} }`  ......... `async method`
   * - `class A { get foo() {} }`  ............. `getter 'foo'`
   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`
   * - `class A { static foo() {} }`  .......... `static method 'foo'`
   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`
   * - `class A { static async foo() {} }`  .... `static async method 'foo'`
   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`
   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`
   *
   * @param {ASTNode} node - The function node to get.
   * @returns {string} The name and kind of the function node.
   */
  var anyLoopPattern, astUtils, containsDeclaration, convertCommentToJsStyleJsdoc, getDeclarationAssignmentAncestor, getFunctionName, getFunctionNameWithKind, getPrecedence, getStaticPropertyName, hasIndentedLastLine, isBoundMethod, isDeclarationAssignment, isFatArrowFunction, isIife, isInLoop, isLoop;

  astUtils = require('../eslint-ast-utils');

  ({getStaticPropertyName} = astUtils);

  anyLoopPattern = /^WhileStatement|For$/;

  //------------------------------------------------------------------------------
  // Public Interface
  //------------------------------------------------------------------------------
  /**
   * Get the precedence level based on the node type
   * @param {ASTNode} node node to evaluate
   * @returns {int} precedence level
   * @private
   */
  getPrecedence = function(node) {
    switch (node.type) {
      // when 'SequenceExpression'
      //   return 0
      case 'AssignmentExpression': // ,'ArrowFunctionExpression', 'YieldExpression'
        return 1;
      // when 'ConditionalExpression'
      //   return 3
      case 'LogicalExpression':
        switch (node.operator) {
          case '?':
            return 3;
          case '||':
          case 'or':
            return 4;
          case '&&':
          case 'and':
            return 5;
        }
        break;
      // no default
      /* falls through */
      case 'BinaryExpression':
        switch (node.operator) {
          case '|':
            return 6;
          case '^':
            return 7;
          case '&':
            return 8;
          case '==':
          case '!=':
          case '===':
          case '!==':
            return 9;
          case '<':
          case '<=':
          case '>':
          case '>=':
          case 'in':
          case 'instanceof':
            return 10;
          case '<<':
          case '>>':
          case '>>>':
            return 11;
          case '+':
          case '-':
            return 12;
          case '*':
          case '/':
          case '%':
            return 13;
          case '**':
            return 15;
        }
    }
  };

  // no default
  /* falls through */
  // when 'UnaryExpression', 'AwaitExpression'
  //   return 16

  // when 'UpdateExpression'
  //   return 17

  // when 'CallExpression'
  //   return 18

  // when 'NewExpression'
  //   return 19

  // else
  //   return 20
  isLoop = function(node) {
    return !!(node && anyLoopPattern.test(node.type));
  };

  isInLoop = function(node) {
    var currentNode;
    currentNode = node;
    while (currentNode && !astUtils.isFunction(currentNode)) {
      if (isLoop(currentNode)) {
        return true;
      }
      currentNode = currentNode.parent;
    }
    return false;
  };

  getFunctionName = function(node) {
    if (!((node != null ? node.type : void 0) === 'FunctionExpression' && node.parent.type === 'AssignmentExpression' && node.parent.left.type === 'Identifier')) {
      return null;
    }
    return node.parent.left.name;
  };

  getFunctionNameWithKind = function(node) {
    var name, parent, ref, tokens;
    ({parent} = node);
    tokens = [];
    if (parent.type === 'MethodDefinition' && parent.static) {
      tokens.push('static');
    }
    if (node.async) {
      tokens.push('async');
    }
    if (node.generator) {
      tokens.push('generator');
    }
    if (node.type === 'ArrowFunctionExpression') {
      tokens.push('arrow', 'function');
    } else if ((ref = parent.type) === 'Property' || ref === 'MethodDefinition') {
      if (parent.kind === 'constructor') {
        return 'constructor';
      }
      if (parent.kind === 'get') {
        tokens.push('getter');
      } else if (parent.kind === 'set') {
        tokens.push('setter');
      } else {
        tokens.push('method');
      }
    } else {
      tokens.push('function');
    }
    name = getFunctionName(node);
    if (name == null) {
      name = getStaticPropertyName(parent);
    }
    if (name) {
      tokens.push(`'${name}'`);
    }
    return tokens.join(' ');
  };

  isIife = function(func) {
    if ((func != null ? func.type : void 0) !== 'FunctionExpression') {
      return false;
    }
    if (func.parent.type === 'UnaryExpression' && func.parent.operator === 'do') {
      return true;
    }
    if (func.parent.type === 'CallExpression' && func.parent.callee === func) {
      return true;
    }
    return false;
  };

  hasIndentedLastLine = function({node, sourceCode}) {
    var lastLineIndent, lastLineText, match;
    if (!(node.loc.start.line < node.loc.end.line)) {
      return false;
    }
    lastLineText = sourceCode.getText().slice((node.range[1] - node.loc.end.column), node.range[1]);
    match = /^\s+/.exec(lastLineText);
    if (!match) {
      return false;
    }
    lastLineIndent = match[0];
    return lastLineIndent.length + 1 > node.loc.start.column;
  };

  containsDeclaration = function(node) {
    var element, i, j, len, len1, prop, ref, ref1;
    switch (node != null ? node.type : void 0) {
      case 'Identifier':
        return node.declaration;
      case 'ObjectPattern':
        ref = node.properties;
        for (i = 0, len = ref.length; i < len; i++) {
          prop = ref[i];
          if (containsDeclaration(prop)) {
            return true;
          }
        }
        return false;
      case 'Property':
        return containsDeclaration(node.value);
      case 'RestElement':
        return containsDeclaration(node.argument);
      case 'ArrayPattern':
        ref1 = node.elements;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          element = ref1[j];
          if (containsDeclaration(element)) {
            return true;
          }
        }
        return false;
      case 'AssignmentPattern':
        return containsDeclaration(node.left);
    }
  };

  isDeclarationAssignment = function(node) {
    if ((node != null ? node.type : void 0) !== 'AssignmentExpression') {
      return false;
    }
    return containsDeclaration(node.left);
  };

  getDeclarationAssignmentAncestor = function(node) {
    var current;
    current = node;
    while (current) {
      switch (current != null ? current.type : void 0) {
        case 'AssignmentExpression':
          return current;
        case 'ObjectPattern':
        case 'ArrayPattern':
        case 'Property':
        case 'RestElement':
        case 'Identifier':
        case 'AssignmentPattern':
          current = current.parent;
          break;
        default:
          return null;
      }
    }
    return null;
  };

  isFatArrowFunction = function(node) {
    var bound, parent, type;
    if (node == null) {
      return;
    }
    ({bound, type, parent} = node);
    return type === 'ArrowFunctionExpression' || bound || ((parent != null ? parent.type : void 0) === 'MethodDefinition' && parent.bound);
  };

  isBoundMethod = function(node) {
    var parent;
    if (node == null) {
      return;
    }
    ({parent} = node);
    return (parent != null ? parent.type : void 0) === 'MethodDefinition' && parent.bound;
  };

  convertCommentToJsStyleJsdoc = function(comment) {
    return comment.replace(/^(\s*)#/gm, '$1*');
  };

  module.exports = {getPrecedence, isInLoop, getFunctionName, getFunctionNameWithKind, isIife, hasIndentedLastLine, isDeclarationAssignment, isFatArrowFunction, isBoundMethod, convertCommentToJsStyleJsdoc, getDeclarationAssignmentAncestor};

}).call(this);
