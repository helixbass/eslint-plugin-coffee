// Generated by CoffeeScript 2.5.0
(function() {
  'use strict';
  var StyleSheets, astHelpers, currentContent, getSourceCode;

  /**
   * StyleSheets represents the StyleSheets found in the source code.
   * @constructor
   */
  StyleSheets = class StyleSheets {
    constructor() {
      this.styleSheets = {};
    }

    /**
     * Add adds a StyleSheet to our StyleSheets collections.
     *
     * @param {string} styleSheetName - The name of the StyleSheet.
     * @param {object} properties - The collection of rules in the styleSheet.
     */
    add(styleSheetName, properties) {
      return this.styleSheets[styleSheetName] = properties;
    }

    /**
     * MarkAsUsed marks a rule as used in our source code by removing it from the
     * specified StyleSheet rules.
     *
     * @param {string} fullyQualifiedName - The fully qualified name of the rule.
     * for example 'styles.text'
     */
    markAsUsed(fullyQualifiedName) {
      var nameSplit, styleSheetName, styleSheetProperty;
      nameSplit = fullyQualifiedName.split('.');
      styleSheetName = nameSplit[0];
      styleSheetProperty = nameSplit[1];
      if (this.styleSheets[styleSheetName]) {
        return this.styleSheets[styleSheetName] = this.styleSheets[styleSheetName].filter(function(property) {
          return property.key.name !== styleSheetProperty;
        });
      }
    }

    /**
     * GetUnusedReferences returns all collected StyleSheets and their
     * unmarked rules.
     */
    getUnusedReferences() {
      return this.styleSheets;
    }

    /**
     * AddColorLiterals adds an array of expressions that contain color literals
     * to the ColorLiterals collection
     * @param {array} expressions - an array of expressions containing color literals
     */
    addColorLiterals(expressions) {
      var ref;
      return this.colorLiterals = ((ref = this.colorLiterals) != null ? ref : []).concat(expressions);
    }

    /**
     * GetColorLiterals returns an array of collected color literals expressions
     * @returns {Array}
     */
    getColorLiterals() {
      return this.colorLiterals;
    }

    /**
     * AddObjectexpressions adds an array of expressions to the ObjectExpressions collection
     * @param {Array} expressions - an array of expressions containing ObjectExpressions in
     * inline styles
     */
    addObjectExpressions(expressions) {
      var ref;
      return this.objectExpressions = ((ref = this.objectExpressions) != null ? ref : []).concat(expressions);
    }

    /**
     * GetObjectExpressions returns an array of collected object expressiosn used in inline styles
     * @returns {Array}
     */
    getObjectExpressions() {
      return this.objectExpressions;
    }

  };

  currentContent = null;

  getSourceCode = function(node) {
    return currentContent.getSourceCode(node).getText(node);
  };

  astHelpers = {
    containsStyleSheetObject: function(node) {
      var ref, ref1, ref2, right;
      right = (ref = node != null ? node.init : void 0) != null ? ref : node != null ? node.right : void 0;
      return (right != null ? (ref1 = right.callee) != null ? (ref2 = ref1.object) != null ? ref2.name : void 0 : void 0 : void 0) === 'StyleSheet';
    },
    containsCreateCall: function(node) {
      var ref, ref1, ref2, right;
      right = (ref = node != null ? node.init : void 0) != null ? ref : node != null ? node.right : void 0;
      return (right != null ? (ref1 = right.callee) != null ? (ref2 = ref1.property) != null ? ref2.name : void 0 : void 0 : void 0) === 'create';
    },
    isStyleSheetDeclaration: function(node) {
      return Boolean(astHelpers.containsStyleSheetObject(node) && astHelpers.containsCreateCall(node));
    },
    getStyleSheetName: function(node) {
      var ref, ref1, ref2;
      return (ref = node != null ? (ref1 = node.id) != null ? ref1.name : void 0 : void 0) != null ? ref : node != null ? (ref2 = node.left) != null ? ref2.name : void 0 : void 0;
    },
    getStyleDeclarations: function(node) {
      var ref, ref1, ref2, right;
      right = (ref = node != null ? node.init : void 0) != null ? ref : node != null ? node.right : void 0;
      if (right != null ? (ref1 = right.arguments) != null ? (ref2 = ref1[0]) != null ? ref2.properties : void 0 : void 0 : void 0) {
        return right.arguments[0].properties.filter(function(property) {
          return property.type === 'Property';
        });
      }
      return [];
    },
    isStyleAttribute: function(node) {
      return Boolean(node.type === 'JSXAttribute' && node.name && node.name.name && node.name.name.toLowerCase().includes('style'));
    },
    collectStyleObjectExpressions: function(node, context) {
      var styleReferenceContainers;
      currentContent = context;
      if (astHelpers.hasArrayOfStyleReferences(node)) {
        styleReferenceContainers = node.expression.elements;
        return astHelpers.collectStyleObjectExpressionFromContainers(styleReferenceContainers);
      }
      if ((node != null ? node.expression : void 0)) {
        return astHelpers.getStyleObjectExpressionFromNode(node.expression);
      }
      return [];
    },
    collectColorLiterals: function(node, context) {
      var styleReferenceContainers;
      if (!node) {
        return [];
      }
      currentContent = context;
      if (astHelpers.hasArrayOfStyleReferences(node)) {
        styleReferenceContainers = node.expression.elements;
        return astHelpers.collectColorLiteralsFromContainers(styleReferenceContainers);
      }
      if (node.type === 'ObjectExpression') {
        return astHelpers.getColorLiteralsFromNode(node);
      }
      return astHelpers.getColorLiteralsFromNode(node.expression);
    },
    collectStyleObjectExpressionFromContainers: function(nodes) {
      var objectExpressions;
      objectExpressions = [];
      nodes.forEach(function(node) {
        return objectExpressions = objectExpressions.concat(astHelpers.getStyleObjectExpressionFromNode(node));
      });
      return objectExpressions;
    },
    collectColorLiteralsFromContainers: function(nodes) {
      var colorLiterals;
      colorLiterals = [];
      nodes.forEach(function(node) {
        return colorLiterals = colorLiterals.concat(astHelpers.getColorLiteralsFromNode(node));
      });
      return colorLiterals;
    },
    getStyleReferenceFromNode: function(node) {
      var leftStyleReferences, rightStyleReferences, styleReference;
      if (!node) {
        return [];
      }
      switch (node.type) {
        case 'MemberExpression':
          styleReference = astHelpers.getStyleReferenceFromExpression(node);
          return [styleReference];
        case 'LogicalExpression':
          leftStyleReferences = astHelpers.getStyleReferenceFromNode(node.left);
          rightStyleReferences = astHelpers.getStyleReferenceFromNode(node.right);
          return [].concat(leftStyleReferences).concat(rightStyleReferences);
        case 'ConditionalExpression':
          leftStyleReferences = astHelpers.getStyleReferenceFromNode(node.consequent);
          rightStyleReferences = astHelpers.getStyleReferenceFromNode(node.alternate);
          return [].concat(leftStyleReferences).concat(rightStyleReferences);
        default:
          return [];
      }
    },
    getStyleObjectExpressionFromNode: function(node) {
      var leftStyleObjectExpression, rightStyleObjectExpression;
      if (!node) {
        return [];
      }
      if (node.type === 'ObjectExpression') {
        return [astHelpers.getStyleObjectFromExpression(node)];
      }
      switch (node.type) {
        case 'LogicalExpression':
          leftStyleObjectExpression = astHelpers.getStyleObjectExpressionFromNode(node.left);
          rightStyleObjectExpression = astHelpers.getStyleObjectExpressionFromNode(node.right);
          return [].concat(leftStyleObjectExpression).concat(rightStyleObjectExpression);
        case 'ConditionalExpression':
          leftStyleObjectExpression = astHelpers.getStyleObjectExpressionFromNode(node.consequent);
          rightStyleObjectExpression = astHelpers.getStyleObjectExpressionFromNode(node.alternate);
          return [].concat(leftStyleObjectExpression).concat(rightStyleObjectExpression);
        default:
          return [];
      }
    },
    getColorLiteralsFromNode: function(node) {
      var leftColorLiterals, rightColorLiterals;
      if (!node) {
        return [];
      }
      if (node.type === 'ObjectExpression') {
        return [astHelpers.getColorLiteralsFromExpression(node)];
      }
      switch (node.type) {
        case 'LogicalExpression':
          leftColorLiterals = astHelpers.getColorLiteralsFromNode(node.left);
          rightColorLiterals = astHelpers.getColorLiteralsFromNode(node.right);
          return [].concat(leftColorLiterals).concat(rightColorLiterals);
        case 'ConditionalExpression':
          leftColorLiterals = astHelpers.getColorLiteralsFromNode(node.consequent);
          rightColorLiterals = astHelpers.getColorLiteralsFromNode(node.alternate);
          return [].concat(leftColorLiterals).concat(rightColorLiterals);
        default:
          return [];
      }
    },
    hasArrayOfStyleReferences: function(node) {
      return node && Boolean(node.type === 'JSXExpressionContainer' && node.expression && node.expression.type === 'ArrayExpression');
    },
    getStyleReferenceFromExpression: function(node) {
      var name, property, result;
      result = [];
      name = astHelpers.getObjectName(node);
      if (name) {
        result.push(name);
      }
      property = astHelpers.getPropertyName(node);
      if (property) {
        result.push(property);
      }
      return result.join('.');
    },
    getStyleObjectFromExpression: function(node) {
      var invalid, obj, ref;
      obj = {};
      invalid = false;
      if ((ref = node.properties) != null ? ref.length : void 0) {
        node.properties.forEach(function(p) {
          var innerNode;
          if (!p.value || !p.key) {
            return;
          }
          if (p.value.type === 'Literal') {
            invalid = true;
            return obj[p.key.name] = p.value.value;
          } else if (p.value.type === 'ConditionalExpression') {
            innerNode = p.value;
            if (innerNode.consequent.type === 'Literal' || innerNode.alternate.type === 'Literal') {
              invalid/*:*/ = true;
              return obj[p.key.name] = getSourceCode(innerNode);
            }
          } else if (p.value.type === 'UnaryExpression' && p.value.operator === '-' && p.value.argument.type === 'Literal') {
            invalid/*:*/ = true;
            return obj[p.key.name] = -1 * p.value.argument.value;
          } else if (p.value.type === 'UnaryExpression' && p.value.operator === '+' && p.value.argument.type === 'Literal') {
            invalid/*:*/ = true;
            return obj[p.key.name] = p.value.argument.value;
          }
        });
      }
      if (invalid) {
        return {
          expression: obj,
          node
        };
      } else {
        return void 0;
      }
    },
    getColorLiteralsFromExpression: function(node) {
      var invalid, obj, ref;
      obj = {};
      invalid = false;
      if ((ref = node.properties) != null ? ref.length : void 0) {
        node.properties.forEach(function(p) {
          var innerNode, ref1;
          if (((ref1 = p.key) != null ? ref1.name : void 0) && p.key.name.toLowerCase().indexOf('color') !== -1) {
            if (p.value.type === 'Literal') {
              invalid = true;
              return obj[p.key.name] = p.value.value;
            } else if (p.value.type === 'ConditionalExpression') {
              innerNode = p.value;
              if (innerNode.consequent.type === 'Literal' || innerNode.alternate.type === 'Literal') {
                invalid/*:*/ = true;
                return obj[p.key.name] = getSourceCode(innerNode);
              }
            }
          }
        });
      }
      if (invalid) {
        return {
          expression: obj,
          node
        };
      } else {
        return void 0;
      }
    },
    getObjectName: function(node) {
      if ((node != null ? node.object : void 0) && node.object.name) {
        return node.object.name;
      }
    },
    getPropertyName: function(node) {
      if ((node != null ? node.property : void 0) && node.property.name) {
        return node.property.name;
      }
    },
    getPotentialStyleReferenceFromMemberExpression: function(node) {
      if ((node != null ? node.object : void 0) && node.object.type === 'Identifier' && node.object.name && node.property && node.property.type === 'Identifier' && node.property.name && node.parent.type !== 'MemberExpression') {
        return [node.object.name, node.property.name].join('.');
      }
    }
  };

  module.exports.astHelpers = astHelpers;

  module.exports.StyleSheets = StyleSheets;

}).call(this);
