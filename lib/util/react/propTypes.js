// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Common propTypes detection functionality.
   */
  'use strict';
  /**
   * Retrieve the name of a key node
   * @param {ASTNode} node The AST node with the key.
   * @return {string} the name of the key
   */
  /**
   * Checks if we are declaring a props as a generic type in a flow-annotated class.
   *
   * @param {ASTNode} node  the AST node being checked.
   * @returns {Boolean} True if the node is a class with generic prop types, false if not.
   */
  /**
   * Iterates through a properties node, like a customized forEach.
   * @param {Object[]} properties Array of properties to iterate.
   * @param {Function} fn Function to call on each property, receives property key
      and property value. (key, value) => void
   */
  /**
   * Removes quotes from around an identifier.
   * @param {string} the identifier to strip
   */
  var annotations, getKeyValue, isSuperTypeParameterPropsDeclaration, iterateProperties, propsUtil, stripQuotes, variableUtil, versionUtil;

  annotations = require('eslint-plugin-react/lib/util/annotations');

  propsUtil = require('./props');

  variableUtil = require('./variable');

  versionUtil = require('eslint-plugin-react/lib/util/version');

  isSuperTypeParameterPropsDeclaration = function(node) {
    var ref;
    if (node && ((ref = node.type) === 'ClassDeclaration' || ref === 'ClassExpression')) {
      if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {
        return true;
      }
    }
    return false;
  };

  stripQuotes = function(string) {
    return string.replace(/^'|'$/g, '');
  };

  getKeyValue = function(context, node) {
    var key, ref, tokens;
    if (node.type === 'ObjectTypeProperty') {
      tokens = context.getFirstTokens(node, 2);
      return ((ref = tokens[0].value) === '+' || ref === '-' ? tokens[1].value : stripQuotes(tokens[0].value));
    }
    key = node.key || node.argument;
    if (key.type === 'Identifier') {
      return key.name;
    } else {
      return key.value;
    }
  };

  iterateProperties = function(context, properties, fn) {
    var i, j, key, node, results, value;
    if ((properties != null ? properties.length : void 0) && typeof fn === 'function') {
      i = 0;
      j = properties.length;
      results = [];
      while (i < j) {
        node = properties[i];
        key = getKeyValue(context, node);
        ({value} = node);
        fn(key, value);
        results.push(i++);
      }
      return results;
    }
  };

  module.exports = function(context, components, utils) {
    /**
     * Creates the representation of the React propTypes for the component.
     * The representation is used to verify nested used properties.
     * @param {ASTNode} value Node of the PropTypes for the desired property
     * @return {Object} The representation of the declaration, empty object means
     *    the property is declared without the need for further analysis.
     */
    /**
     * Creates the representation of the React props type annotation for the component.
     * The representation is used to verify nested used properties.
     * @param {ASTNode} annotation Type annotation for the props class property.
     * @return {Object} The representation of the declaration, empty object means
     *    the property is declared without the need for further analysis.
     */
    /**
     * Marks all props found inside IntersectionTypeAnnotation as declared.
     * Since InterSectionTypeAnnotations can be nested, this handles recursively.
     *
     * Modifies the declaredPropTypes object
     * @param {ASTNode} propTypes
     * @param {Object} declaredPropTypes
     * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
     */
    /**
     * Marks all props found inside ObjectTypeAnnotaiton as declared.
     *
     * Modifies the declaredProperties object
     * @param {ASTNode} propTypes
     * @param {Object} declaredPropTypes
     * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
     */
    /**
     * Gets a node from the scope.
     * @param {string} key The name of the identifier to access.
     * @returns {ASTNode} The ASTNode associated with the given identifier.
     */
    /**
     * Checks if prop should be validated by plugin-react-proptypes
     * @param {String} validator Name of validator to check.
     * @returns {Boolean} True if validator should be checked by custom validator.
     */
    /**
     * Checks if we are declaring a `props` class property with a flow type annotation.
     * @param {ASTNode} node The AST node being checked.
     * @returns {Boolean} True if the node is a type annotated props declaration, false if not.
     */
    /**
     * @param {ASTNode} node We expect either an ArrowFunctionExpression,
     *   FunctionDeclaration, or FunctionExpression
     */
    /**
     * Resolve the type annotation for a given class declaration node with superTypeParameters.
     *
     * @param {ASTNode} node The annotation or a node containing the type annotation.
     * @returns {ASTNode} The resolved type annotation for the node.
     */
    /* eslint-enable coffee/no-use-before-define */
    /**
     * Resolve the type annotation for a given node.
     * Flow annotations are sometimes wrapped in outer `TypeAnnotation`
     * and `NullableTypeAnnotation` nodes which obscure the annotation we're
     * interested in.
     * This method also resolves type aliases where possible.
     *
     * @param {ASTNode} node The annotation or a node containing the type annotation.
     * @returns {ASTNode} The resolved type annotation for the node.
     */
    /**
     * Sets the new value in the scope.
     * @param {string} key The name of the identifier to access
     * @param {ASTNode} value The new value for the identifier.
     * @returns {ASTNode} The ASTNode associated with the given identifier.
     */
    /* eslint-disable coffee/no-use-before-define */
    /**
     * Returns the full scope.
     * @returns {Object} The whole scope.
     */
    var buildReactDeclarationTypes, buildTypeAnnotationDeclarationTypes, classExpressions, configuration, customValidators, declarePropTypesForIntersectionTypeAnnotation, declarePropTypesForObjectTypeAnnotation, defaults, getInTypeScope, hasCustomValidator, isAnnotatedClassPropsDeclaration, markAnnotatedFunctionArgumentsAsDeclared, markPropTypesAsDeclared, propWrapperFunctions, resolveSuperParameterPropsType, resolveTypeAnnotation, setInTypeScope, sourceCode, stack, typeDeclarationBuilders, typeScope;
    // Used to track the type annotations in scope.
    // Necessary because babel's scopes do not track type annotations.
    stack = null;
    classExpressions = [];
    defaults = {
      customValidators: []
    };
    configuration = {...defaults, ...(context.options[0] || {})};
    ({customValidators} = configuration);
    sourceCode = context.getSourceCode();
    propWrapperFunctions = new Set(context.settings.propWrapperFunctions);
    typeScope = function() {
      return stack[stack.length - 1];
    };
    getInTypeScope = function(key) {
      return stack[stack.length - 1][key];
    };
    setInTypeScope = function(key, value) {
      stack[stack.length - 1][key] = value;
      return value;
    };
    hasCustomValidator = function(validator) {
      return customValidators.indexOf(validator) !== -1;
    };
    typeDeclarationBuilders = {
      GenericTypeAnnotation: function(annotation, parentName, seen) {
        if (getInTypeScope(annotation.id.name)) {
          return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);
        }
        return {};
      },
      ObjectTypeAnnotation: function(annotation, parentName, seen) {
        var containsObjectTypeSpread, shapeTypeDefinition;
        containsObjectTypeSpread = false;
        shapeTypeDefinition = {
          type: 'shape',
          children: {}
        };
        iterateProperties(context, annotation.properties, function(childKey, childValue) {
          var fullName, types;
          fullName = [parentName, childKey].join('.');
          if (!childKey && !childValue) {
            return containsObjectTypeSpread = true;
          } else {
            types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);
            types.fullName = fullName;
            types.name = childKey;
            types.node = childValue;
            return shapeTypeDefinition.children[childKey] = types;
          }
        });
        // Mark if this shape has spread. We will know to consider all props from this shape as having propTypes,
        // but still have the ability to detect unused children of this shape.
        shapeTypeDefinition.containsSpread = containsObjectTypeSpread;
        return shapeTypeDefinition;
      },
      UnionTypeAnnotation: function(annotation, parentName, seen) {
        var i, j, type, unionTypeDefinition;
        unionTypeDefinition = {
          type: 'union',
          children: []
        };
        i = 0;
        j = annotation.types.length;
        while (i < j) {
          type = buildTypeAnnotationDeclarationTypes(annotation.types[i], parentName, seen);
          if (type.type) {
            if (type.children === true) {
              unionTypeDefinition.children = true;
              return unionTypeDefinition;
            }
          }
          unionTypeDefinition.children.push(type);
          i++;
        }
        // keep only complex type
        // every child is accepted for one type, abort type analysis
        // no complex type found, simply accept everything
        if (unionTypeDefinition.children.length === 0) {
          return {};
        }
        return unionTypeDefinition;
      },
      ArrayTypeAnnotation: function(annotation, parentName, seen) {
        var child, fullName;
        fullName = [parentName, '*'].join('.');
        child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);
        child.fullName = fullName;
        child.name = '__ANY_KEY__';
        child.node = annotation;
        return {
          type: 'object',
          children: {
            __ANY_KEY__: child
          }
        };
      }
    };
    resolveTypeAnnotation = function(node) {
      var annotation, ref;
      annotation = node.typeAnnotation || node;
      while ((ref = annotation != null ? annotation.type : void 0) === 'TypeAnnotation' || ref === 'NullableTypeAnnotation') {
        annotation = annotation.typeAnnotation;
      }
      if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {
        return getInTypeScope(annotation.id.name);
      }
      return annotation;
    };
    buildTypeAnnotationDeclarationTypes = function(annotation, parentName, seen) {
      if (typeof seen === 'undefined') {
        // Keeps track of annotations we've already seen to
        // prevent problems with recursive types.
        seen = new Set();
      }
      // This must be a recursive type annotation, so just accept anything.
      if (seen.has(annotation)) {
        return {};
      }
      seen.add(annotation);
      if (annotation.type in typeDeclarationBuilders) {
        return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);
      }
      return {};
    };
    declarePropTypesForObjectTypeAnnotation = function(propTypes, declaredPropTypes) {
      var ignorePropsValidation;
      ignorePropsValidation = false;
      iterateProperties(context, propTypes.properties, function(key, value) {
        var types;
        if (!value) {
          ignorePropsValidation = true;
          return;
        }
        types = buildTypeAnnotationDeclarationTypes(value, key);
        types.fullName = key;
        types.name = key;
        types.node = value;
        return declaredPropTypes[key] = types;
      });
      return ignorePropsValidation;
    };
    declarePropTypesForIntersectionTypeAnnotation = function(propTypes, declaredPropTypes) {
      return propTypes.types.some(function(annotation) {
        var typeNode;
        if (annotation.type === 'ObjectTypeAnnotation') {
          return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
        }
        if (annotation.type === 'UnionTypeAnnotation') {
          return true;
        }
        if (!annotation.id) {
          // Type can't be resolved
          return true;
        }
        typeNode = getInTypeScope(annotation.id.name);
        if (!typeNode) {
          return true;
        }
        if (typeNode.type === 'IntersectionTypeAnnotation') {
          return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
        }
        return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
      });
    };
    buildReactDeclarationTypes = function(value, parentName) {
      var argument, callName, child, fullName, i, j, shapeTypeDefinition, type, unionTypeDefinition;
      if ((value != null ? value.callee : void 0) && value.callee.object && hasCustomValidator(value.callee.object.name)) {
        return {};
      }
      if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
        value = value.object;
      }
      // Verify PropTypes that are functions
      if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {
        callName = value.callee.property.name;
        argument = value.arguments[0];
        switch (callName) {
          case 'shape':
            // Invalid proptype or cannot analyse statically
            if (argument.type !== 'ObjectExpression') {
              return {};
            }
            shapeTypeDefinition = {
              type: 'shape',
              children: {}
            };
            iterateProperties(context, argument.properties, function(childKey, childValue) {
              var fullName, types;
              fullName = [parentName, childKey].join('.');
              types = buildReactDeclarationTypes(childValue, fullName);
              types.fullName = fullName;
              types.name = childKey;
              types.node = childValue;
              return shapeTypeDefinition.children[childKey] = types;
            });
            return shapeTypeDefinition;
          case 'arrayOf':
          case 'objectOf':
            fullName = [parentName, '*'].join('.');
            child = buildReactDeclarationTypes(argument, fullName);
            child.fullName = fullName;
            child.name = '__ANY_KEY__';
            child.node = argument;
            return {
              type: 'object',
              children: {
                __ANY_KEY__: child
              }
            };
          case 'oneOfType':
            // Invalid proptype or cannot analyse statically
            if (!argument.elements || !argument.elements.length) {
              return {};
            }
            unionTypeDefinition = {
              type: 'union',
              children: []
            };
            i = 0;
            j = argument.elements.length;
            while (i < j) {
              type = buildReactDeclarationTypes(argument.elements[i], parentName);
              if (type.type) {
                if (type.children === true) {
                  unionTypeDefinition.children = true;
                  return unionTypeDefinition;
                }
              }
              unionTypeDefinition.children.push(type);
              i++;
            }
            // keep only complex type
            // every child is accepted for one type, abort type analysis
            // no complex type found, simply accept everything
            if (unionTypeDefinition.length === 0) {
              return {};
            }
            return unionTypeDefinition;
          case 'instanceOf':
            return {
              type: 'instance',
              // Accept all children because we can't know what type they are
              children: true
            };
          default:
            return {};
        }
      }
      return {};
    };
    /**
     * Mark a prop type as declared
     * @param {ASTNode} node The AST node being checked.
     * @param {propTypes} node The AST node containing the proptypes
     */
    // Unknown property or accepts everything (any, object, ...)
    markPropTypesAsDeclared = function(node, propTypes) {
      var component, componentNode, curDeclaredPropTypes, declaredPropTypes, defInScope, ignorePropsValidation, isUsedInPropTypes, k, len, n, parentProp, propName, ref, ref1, ref2, ref3, types, variable, variablesInScope;
      componentNode = node;
      while (componentNode && !components.get(componentNode)) {
        componentNode = componentNode.parent;
      }
      component = components.get(componentNode);
      declaredPropTypes = (component != null ? component.declaredPropTypes : void 0) || {};
      ignorePropsValidation = (component != null ? component.ignorePropsValidation : void 0) || false;
      switch (propTypes != null ? propTypes.type : void 0) {
        case 'ObjectTypeAnnotation':
          ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
          break;
        case 'ObjectExpression':
          iterateProperties(context, propTypes.properties, function(key, value) {
            var types;
            if (!value) {
              ignorePropsValidation = true;
              return;
            }
            types = buildReactDeclarationTypes(value, key);
            types.fullName = key;
            types.name = key;
            types.node = value;
            return declaredPropTypes[key] = types;
          });
          break;
        case 'MemberExpression':
          curDeclaredPropTypes = declaredPropTypes;
          // Walk the list of properties, until we reach the assignment
          // ie: ClassX.propTypes.a.b.c = ...
          while ((propTypes != null ? propTypes.parent : void 0) && propTypes.parent.type !== 'AssignmentExpression' && propTypes.property && curDeclaredPropTypes) {
            propName = propTypes.property.name;
            if (propName in curDeclaredPropTypes) {
              curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
              propTypes = propTypes.parent;
            } else {
              // This will crash at runtime because we haven't seen this key before
              // stop this and do not declare it
              propTypes = null;
            }
          }
          if ((propTypes != null ? propTypes.parent : void 0) && propTypes.property) {
            if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {
              ignorePropsValidation = true;
            }
            parentProp = context.getSource(propTypes.parent.left.object).replace(/^.*\.propTypes\./, '');
            types = buildReactDeclarationTypes(propTypes.parent.right, parentProp);
            types.name = propTypes.property.name;
            types.fullName = [parentProp, propTypes.property.name].join('.');
            types.node = propTypes.property;
            curDeclaredPropTypes[propTypes.property.name] = types;
          } else {
            isUsedInPropTypes = false;
            n = propTypes;
            while (n) {
              if ((n.type === 'AssignmentExpression' && propsUtil.isPropTypesDeclaration(n.left)) || (((ref = n.type) === 'ClassProperty' || ref === 'Property') && propsUtil.isPropTypesDeclaration(n))) {
                // Found a propType used inside of another propType. This is not considered usage, we'll still validate
                // this component.
                isUsedInPropTypes = true;
              }
              n = n.parent;
            }
            if (!isUsedInPropTypes) {
              ignorePropsValidation = true;
            }
          }
          break;
        case 'Identifier':
          variablesInScope = variableUtil.variablesInScope(context);
          for (k = 0, len = variablesInScope.length; k < len; k++) {
            variable = variablesInScope[k];
            if (variable.name !== propTypes.name) {
              continue;
            }
            defInScope = variable.defs[variable.defs.length - 1];
            markPropTypesAsDeclared(node, (ref1 = (ref2 = defInScope.node) != null ? ref2.init : void 0) != null ? ref1 : (ref3 = defInScope.node) != null ? ref3.parent.right : void 0);
            return;
          }
          ignorePropsValidation = true;
          break;
        case 'CallExpression':
          if (propWrapperFunctions.has(sourceCode.getText(propTypes.callee)) && propTypes.arguments && propTypes.arguments[0]) {
            markPropTypesAsDeclared(node, propTypes.arguments[0]);
            return;
          }
          break;
        case 'IntersectionTypeAnnotation':
          ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
          break;
        default:
          ignorePropsValidation = true;
      }
      return components.set(node, {declaredPropTypes, ignorePropsValidation});
    };
    markAnnotatedFunctionArgumentsAsDeclared = function(node) {
      if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
        return;
      }
      return markPropTypesAsDeclared(node, resolveTypeAnnotation(node.params[0]));
    };
    resolveSuperParameterPropsType = function(node) {
      var annotation, e, propsParameterPosition, ref;
      try {
        // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.
        // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.
        propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
      } catch (error) {
        e = error;
        // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52
        propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
      }
      annotation = node.superTypeParameters.params[propsParameterPosition];
      while ((ref = annotation != null ? annotation.type : void 0) === 'TypeAnnotation' || ref === 'NullableTypeAnnotation') {
        annotation = annotation.typeAnnotation;
      }
      if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {
        return getInTypeScope(annotation.id.name);
      }
      return annotation;
    };
    isAnnotatedClassPropsDeclaration = function(node) {
      var tokens;
      if (node && node.type === 'ClassProperty') {
        tokens = context.getFirstTokens(node, 2);
        if (node.typeAnnotation && (tokens[0].value === 'props' || (tokens[1] && tokens[1].value === 'props'))) {
          return true;
        }
      }
      return false;
    };
    return {
      ClassExpression: function(node) {
        // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.
        // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone
        // processing class expressions until when the program exists.
        return classExpressions.push(node);
      },
      ClassDeclaration: function(node) {
        if (isSuperTypeParameterPropsDeclaration(node)) {
          return markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
        }
      },
      ClassProperty: function(node) {
        if (isAnnotatedClassPropsDeclaration(node)) {
          return markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
        } else if (propsUtil.isPropTypesDeclaration(node)) {
          return markPropTypesAsDeclared(node, node.value);
        }
      },
      ObjectExpression: function(node) {
        // Search for the proptypes declaration
        return node.properties.forEach(function(property) {
          if (!propsUtil.isPropTypesDeclaration(property)) {
            return;
          }
          return markPropTypesAsDeclared(node, property.value);
        });
      },
      FunctionExpression: function(node) {
        if (node.parent.type !== 'MethodDefinition') {
          return markAnnotatedFunctionArgumentsAsDeclared(node);
        }
      },
      FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,
      ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,
      MemberExpression: function(node) {
        var component;
        if (propsUtil.isPropTypesDeclaration(node)) {
          component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          return markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
        }
      },
      MethodDefinition: function(node) {
        var i;
        if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) {
          return;
        }
        i = node.value.body.body.length - 1;
        while (i >= 0) {
          if (node.value.body.body[i].type === 'ReturnStatement') {
            break;
          }
          i--;
        }
        if (i >= 0) {
          return markPropTypesAsDeclared(node, node.value.body.body[i].argument);
        }
      },
      JSXSpreadAttribute: function(node) {
        var component;
        component = components.get(utils.getParentComponent());
        return components.set(component ? component.node : node, {
          ignoreUnusedPropTypesValidation: true
        });
      },
      TypeAlias: function(node) {
        return setInTypeScope(node.id.name, node.right);
      },
      TypeParameterDeclaration: function(node) {
        var identifier;
        identifier = node.params[0];
        if (identifier.typeAnnotation) {
          return setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
        }
      },
      Program: function() {
        return stack = [{}];
      },
      BlockStatement: function() {
        return stack.push(Object.create(typeScope()));
      },
      'BlockStatement:exit': function() {
        return stack.pop();
      },
      'Program:exit': function() {
        return classExpressions.forEach(function(node) {
          if (isSuperTypeParameterPropsDeclaration(node)) {
            return markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
          }
        });
      }
    };
  };

}).call(this);
