// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Utility class and functions for React components detection
   * @author Yannick Croissant
   */
  'use strict';
  var Components, astUtil, componentRule, doctrine, getId, mergeUsedPropTypes, pragmaUtil, propTypes, usedPropTypesAreEquivalent, util, variableUtil,
    hasProp = {}.hasOwnProperty;

  util = require('util');

  doctrine = require('doctrine');

  variableUtil = require('./variable');

  pragmaUtil = require('eslint-plugin-react/lib/util/pragma');

  astUtil = require('./ast');

  propTypes = require('./propTypes');

  getId = function(node) {
    return node != null ? node.range.join(':') : void 0;
  };

  usedPropTypesAreEquivalent = function(propA, propB) {
    if (propA.name === propB.name) {
      if (!propA.allNames && !propB.allNames) {
        return true;
      }
      if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {
        return true;
      }
      return false;
    }
    return false;
  };

  mergeUsedPropTypes = function(propsList, newPropsList) {
    var propsToAdd;
    propsToAdd = [];
    newPropsList.forEach(function(newProp) {
      var newPropisAlreadyInTheList;
      newPropisAlreadyInTheList = propsList.some(function(prop) {
        return usedPropTypesAreEquivalent(prop, newProp);
      });
      if (!newPropisAlreadyInTheList) {
        return propsToAdd.push(newProp);
      }
    });
    return propsList.concat(propsToAdd);
  };

  /**
   * Components
   */
  Components = class Components {
    constructor() {
      this._list = {};
    }

    /**
     * Add a node to the components list, or update it if it's already in the list
     *
     * @param {ASTNode} node The AST node being added.
     * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)
     * @returns {Object} Added component object
     */
    add(node, confidence) {
      var id;
      id = getId(node);
      if (this._list[id]) {
        if (confidence === 0 || this._list[id].confidence === 0) {
          this._list[id].confidence = 0;
        } else {
          this._list[id].confidence = Math.max(this._list[id].confidence, confidence);
        }
        return this._list[id];
      }
      this._list[id] = {node, confidence};
      return this._list[id];
    }

    /**
     * Find a component in the list using its node
     *
     * @param {ASTNode} node The AST node being searched.
     * @returns {Object} Component object, undefined if the component is not found or has confidence value of 0.
     */
    get(node) {
      var id, ref1;
      id = getId(node);
      if (((ref1 = this._list[id]) != null ? ref1.confidence : void 0) >= 1) {
        return this._list[id];
      }
      return null;
    }

    /**
     * Update a component in the list
     *
     * @param {ASTNode} node The AST node being updated.
     * @param {Object} props Additional properties to add to the component.
     */
    set(node, props) {
      var copyUsedPropTypes, id, ref1;
      while (node && !this._list[getId(node)]) {
        node = node.parent;
      }
      if (!node) {
        return;
      }
      id = getId(node);
      if (this._list[id]) {
        // usedPropTypes is an array. _extend replaces existing array with a new one which caused issue #1309.
        // preserving original array so it can be merged later on.
        copyUsedPropTypes = (ref1 = this._list[id].usedPropTypes) != null ? ref1.slice() : void 0;
      }
      this._list[id] = util._extend(this._list[id], props);
      if (this._list[id] && props.usedPropTypes) {
        return this._list[id].usedPropTypes = mergeUsedPropTypes(copyUsedPropTypes || [], props.usedPropTypes);
      }
    }

    /**
     * Return the components list
     * Components for which we are not confident are not returned
     *
     * @returns {Object} Components list
     */
    list() {
      var _, comp, component, componentId, id, j, list, newUsedProps, node, ref1, ref2, usedPropTypes;
      list = {};
      usedPropTypes = {};
      ref1 = this._list;
      for (_ in ref1) {
        if (!hasProp.call(ref1, _)) continue;
        comp = ref1[_];
        if (comp.confidence >= 2) {
          continue;
        }
        component = null;
        node = null;
        ({node} = comp);
        while (!component && node.parent) {
          node = node.parent;
          if (node.type === 'Decorator') {
            // Stop moving up if we reach a decorator
            break;
          }
          component = this.get(node);
        }
        if (component) {
          newUsedProps = (comp.usedPropTypes || []).filter(function(propType) {
            return !propType.node || propType.node.kind !== 'init';
          });
          componentId = getId(component.node);
          usedPropTypes[componentId] = (usedPropTypes[componentId] || []).concat(newUsedProps);
        }
      }
      ref2 = this._list;
      for (j in ref2) {
        if (!hasProp.call(ref2, j)) continue;
        comp = ref2[j];
        if (!(comp.confidence >= 2)) {
          continue;
        }
        id = getId(comp.node);
        list[j] = comp;
        if (usedPropTypes[id]) {
          list[j].usedPropTypes = (list[j].usedPropTypes || []).concat(usedPropTypes[id]);
        }
      }
      return list;
    }

    /**
     * Return the length of the components list
     * Components for which we are not confident are not counted
     *
     * @returns {Number} Components list length
     */
    length() {
      var i, length, ref1;
      length = 0;
      ref1 = this._list;
      for (i in ref1) {
        if (!hasProp.call(ref1, i)) continue;
        if (this._list[i].confidence >= 2) {
          length++;
        }
      }
      return length;
    }

  };

  componentRule = function(rule, context) {
    var allKeys, components, createClass, detectionInstructions, pragma, propTypesInstructions, ruleInstructions, sourceCode, updatedRuleInstructions, utils;
    createClass = pragmaUtil.getCreateClassFromContext(context);
    pragma = pragmaUtil.getFromContext(context);
    sourceCode = context.getSourceCode();
    components = new Components();
    // Utilities for component detection
    utils = {
      /**
       * Check if the node is a React ES5 component
       *
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if the node is a React ES5 component, false if not
       */
      isES5Component: function(node) {
        if (!node.parent) {
          return false;
        }
        return RegExp(`^(${pragma}\\.)?${createClass}$`).test(sourceCode.getText(node.parent.callee));
      },
      /**
       * Check if the node is a React ES6 component
       *
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if the node is a React ES6 component, false if not
       */
      isES6Component: function(node) {
        if (utils.isExplicitComponent(node)) {
          return true;
        }
        if (!node.superClass) {
          return false;
        }
        return RegExp(`^(${pragma}\\.)?(Pure)?Component$`).test(sourceCode.getText(node.superClass));
      },
      /**
       * Check if the node is explicitly declared as a descendant of a React Component
       *
       * @param {ASTNode} node The AST node being checked (can be a ReturnStatement or an ArrowFunctionExpression).
       * @returns {Boolean} True if the node is explicitly declared as a descendant of a React Component, false if not
       */
      isExplicitComponent: function(node) {
        var comment, commentAst, e, relevantTags;
        try {
          // Sometimes the passed node may not have been parsed yet by eslint, and this function call crashes.
          // Can be removed when eslint sets "parent" property for all nodes on initial AST traversal: https://github.com/eslint/eslint-scope/issues/27
          // eslint-disable-next-line no-warning-comments
          // FIXME: Remove try/catch when https://github.com/eslint/eslint-scope/issues/27 is implemented.
          comment = sourceCode.getJSDocComment(node);
        } catch (error) {
          e = error;
          comment = null;
        }
        if (comment === null) {
          return false;
        }
        commentAst = doctrine.parse(comment.value, {
          unwrap: true,
          tags: ['extends', 'augments']
        });
        relevantTags = commentAst.tags.filter(function(tag) {
          var ref1;
          return (ref1 = tag.name) === 'React.Component' || ref1 === 'React.PureComponent';
        });
        return relevantTags.length > 0;
      },
      /**
       * Checks to see if our component extends React.PureComponent
       *
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if node extends React.PureComponent, false if not
       */
      isPureComponent: function(node) {
        if (node.superClass) {
          return RegExp(`^(${pragma}\\.)?PureComponent$`).test(sourceCode.getText(node.superClass));
        }
        return false;
      },
      /**
       * Check if createElement is destructured from React import
       *
       * @returns {Boolean} True if createElement is destructured from React
       */
      hasDestructuredReactCreateElement: function() {
        var map, variable, variables;
        variables = variableUtil.variablesInScope(context);
        variable = variableUtil.getVariable(variables, 'createElement');
        if (variable) {
          map = variable.scope.set;
          if (map.has('React')) {
            return true;
          }
        }
        return false;
      },
      /**
       * Checks to see if node is called within React.createElement
       *
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if React.createElement called
       */
      isReactCreateElement: function(node) {
        var calledDirectly, calledOnReact, ref1, ref2, ref3, ref4;
        calledOnReact = (node != null ? (ref1 = node.callee) != null ? (ref2 = ref1.object) != null ? ref2.name : void 0 : void 0 : void 0) === 'React' && ((ref3 = node.callee.property) != null ? ref3.name : void 0) === 'createElement';
        calledDirectly = (node != null ? (ref4 = node.callee) != null ? ref4.name : void 0 : void 0) === 'createElement';
        if (this.hasDestructuredReactCreateElement()) {
          return calledDirectly || calledOnReact;
        }
        return calledOnReact;
      },
      getReturnPropertyAndNode: function(ASTnode) {
        var node, property;
        node = ASTnode;
        if (node.type === 'ExpressionStatement' && node.expression.returns) {
          return {
            node,
            property: 'expression'
          };
        }
        switch (node.type) {
          case 'ReturnStatement':
            property = 'argument';
            break;
          case 'ArrowFunctionExpression':
            property = 'body';
            if (node[property] && node[property].type === 'BlockStatement') {
              ({node, property} = utils.findReturnStatement(node));
            }
            break;
          default:
            ({node, property} = utils.findReturnStatement(node));
        }
        return {node, property};
      },
      /**
       * Check if the node is returning JSX
       *
       * @param {ASTNode} ASTnode The AST node being checked
       * @param {Boolean} strict If true, in a ternary condition the node must return JSX in both cases
       * @returns {Boolean} True if the node is returning JSX, false if not
       */
      isReturningJSX: function(ASTnode, strict) {
        var node, nodeAndProperty, property, ref1, returnsConditionalJSX, returnsConditionalJSXAlternate, returnsConditionalJSXConsequent, returnsJSX, returnsReactCreateElement;
        nodeAndProperty = utils.getReturnPropertyAndNode(ASTnode);
        ({node, property} = nodeAndProperty);
        if (!node) {
          return false;
        }
        returnsConditionalJSXConsequent = node[property] && node[property].type === 'ConditionalExpression' && node[property].consequent.type === 'JSXElement';
        returnsConditionalJSXAlternate = node[property] && node[property].type === 'ConditionalExpression' && ((ref1 = node[property].alternate) != null ? ref1.type : void 0) === 'JSXElement';
        returnsConditionalJSX = strict ? returnsConditionalJSXConsequent && returnsConditionalJSXAlternate : returnsConditionalJSXConsequent || returnsConditionalJSXAlternate;
        returnsJSX = node[property] && node[property].type === 'JSXElement';
        returnsReactCreateElement = this.isReactCreateElement(node[property]);
        return Boolean(returnsConditionalJSX || returnsJSX || returnsReactCreateElement);
      },
      /**
       * Check if the node is returning null
       *
       * @param {ASTNode} ASTnode The AST node being checked
       * @returns {Boolean} True if the node is returning null, false if not
       */
      isReturningNull: function(ASTnode) {
        var node, nodeAndProperty, property;
        nodeAndProperty = utils.getReturnPropertyAndNode(ASTnode);
        ({property, node} = nodeAndProperty);
        if (!node) {
          return false;
        }
        return node[property] && node[property].value === null;
      },
      /**
       * Check if the node is returning JSX or null
       *
       * @param {ASTNode} ASTnode The AST node being checked
       * @param {Boolean} strict If true, in a ternary condition the node must return JSX in both cases
       * @returns {Boolean} True if the node is returning JSX or null, false if not
       */
      isReturningJSXOrNull: function(ASTNode, strict) {
        return utils.isReturningJSX(ASTNode, strict) || utils.isReturningNull(ASTNode);
      },
      /**
       * Find a return statment in the current node
       *
       * @param {ASTNode} ASTnode The AST node being checked
       */
      findReturnStatement: astUtil.findReturnStatement,
      /**
       * Get the parent component node from the current scope
       *
       * @returns {ASTNode} component node, null if we are not in a component
       */
      getParentComponent: function() {
        return utils.getParentES6Component() || utils.getParentES5Component() || utils.getParentStatelessComponent();
      },
      /**
       * Get the parent ES5 component node from the current scope
       *
       * @returns {ASTNode} component node, null if we are not in a component
       */
      getParentES5Component: function() {
        var node, ref1, ref2, scope;
        // eslint-disable-next-line coffee/destructuring-assignment
        scope = context.getScope();
        while (scope) {
          node = (ref1 = scope.block) != null ? (ref2 = ref1.parent) != null ? ref2.parent : void 0 : void 0;
          if (node && utils.isES5Component(node)) {
            return node;
          }
          scope = scope.upper;
        }
        return null;
      },
      /**
       * Get the parent ES6 component node from the current scope
       *
       * @returns {ASTNode} component node, null if we are not in a component
       */
      getParentES6Component: function() {
        var node, scope;
        scope = context.getScope();
        while (scope && scope.type !== 'class') {
          scope = scope.upper;
        }
        node = scope != null ? scope.block : void 0;
        if (!node || !utils.isES6Component(node)) {
          return null;
        }
        return node;
      },
      /**
       * Get the parent stateless component node from the current scope
       *
       * @returns {ASTNode} component node, null if we are not in a component
       */
      getParentStatelessComponent: function() {
        var isArgument, isClass, isFunction, isJSXExpressionContainer, isMethod, node, ref1, ref2, ref3, ref4, scope;
        // eslint-disable-next-line coffee/destructuring-assignment
        scope = context.getScope();
        while (scope) {
          node = scope.block;
          isClass = node.type === 'ClassExpression';
          isFunction = /Function/.test(node.type); // Functions
          isMethod = ((ref1 = node.parent) != null ? ref1.type : void 0) === 'MethodDefinition'; // Classes methods
          isArgument = ((ref2 = node.parent) != null ? ref2.type : void 0) === 'CallExpression' || (((ref3 = node.parent) != null ? ref3.type : void 0) === 'UnaryExpression' && node.parent.operator === 'do'); // Arguments (callback, etc.)
          // Attribute Expressions inside JSX Elements (<button onClick={() => props.handleClick()}></button>)
          isJSXExpressionContainer = ((ref4 = node.parent) != null ? ref4.type : void 0) === 'JSXExpressionContainer';
          if (isClass || isArgument) {
            // Stop moving up if we reach a class or an argument (like a callback)
            return null;
          }
          if (isFunction && !isMethod && !isJSXExpressionContainer && utils.isReturningJSXOrNull(node)) {
            // Return the node if it is a function that is not a class method and is not inside a JSX Element
            return node;
          }
          scope = scope.upper;
        }
        return null;
      },
      /**
       * Get the related component from a node
       *
       * @param {ASTNode} node The AST node being checked (must be a MemberExpression).
       * @returns {ASTNode} component node, null if we cannot find the component
       */
      getRelatedComponent: function(node) {
        var componentName, componentNode, componentPath, componentPathSegment, def, defInScope, k, l, len, len1, len2, len3, len4, m, n, o, prop, ref, ref1, ref2, ref3, ref4, ref5, refId, variable, variableInScope, variableName, variables;
        // Get the component path
        componentPath = [];
        while (node) {
          if (node.property && node.property.type === 'Identifier') {
            componentPath.push(node.property.name);
          }
          if (node.object && node.object.type === 'Identifier') {
            componentPath.push(node.object.name);
          }
          node = node.object;
        }
        componentPath.reverse();
        componentName = componentPath.slice(0, componentPath.length - 1).join('.');
        // Find the variable in the current scope
        variableName = componentPath.shift();
        if (!variableName) {
          return null;
        }
        variables = variableUtil.variablesInScope(context);
        for (k = 0, len = variables.length; k < len; k++) {
          variable = variables[k];
          if (variable.name === variableName) {
            variableInScope = variable;
            break;
          }
        }
        if (!variableInScope) {
          return null;
        }
        ref1 = variableInScope.references;
        // Try to find the component using variable references
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          ref = ref1[l];
          refId = ref.identifier;
          if (refId.parent && refId.parent.type === 'MemberExpression') {
            refId = refId.parent;
          }
          if (sourceCode.getText(refId) !== componentName) {
            continue;
          }
          if (refId.type === 'MemberExpression') {
            componentNode = refId.parent.right;
          } else if (refId.parent && refId.parent.type === 'VariableDeclarator') {
            componentNode = refId.parent.init;
          } else if (refId.declaration && refId.parent.type === 'AssignmentExpression') {
            componentNode = refId.parent.right;
          }
          break;
        }
        if (componentNode) {
          // Return the component
          return components.add(componentNode, 1);
        }
        ref2 = variableInScope.defs;
        // Try to find the component using variable declarations
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          def = ref2[m];
          if ((ref3 = def.type) === 'ClassName' || ref3 === 'FunctionName' || ref3 === 'Variable') {
            defInScope = def;
            break;
          }
        }
        if (!(defInScope != null ? defInScope.node : void 0)) {
          return null;
        }
        componentNode = defInScope.node.init || (defInScope.node.declaration && defInScope.node.parent.type === 'AssignmentExpression' && defInScope.node.parent.right) || defInScope.node;
// Traverse the node properties to the component declaration
        for (n = 0, len3 = componentPath.length; n < len3; n++) {
          componentPathSegment = componentPath[n];
          if (!componentNode.properties) {
            continue;
          }
          ref4 = componentNode.properties;
          for (o = 0, len4 = ref4.length; o < len4; o++) {
            prop = ref4[o];
            if (((ref5 = prop.key) != null ? ref5.name : void 0) === componentPathSegment) {
              componentNode = prop;
              break;
            }
          }
          if (!componentNode || !componentNode.value) {
            return null;
          }
          componentNode = componentNode.value;
        }
        // Return the component
        return components.add(componentNode, 1);
      }
    };
    // Component detection instructions
    detectionInstructions = {
      ClassExpression: function(node) {
        if (!utils.isES6Component(node)) {
          return;
        }
        return components.add(node, 2);
      },
      ClassDeclaration: function(node) {
        if (!utils.isES6Component(node)) {
          return;
        }
        return components.add(node, 2);
      },
      ClassProperty: function(node) {
        node = utils.getParentComponent();
        if (!node) {
          return;
        }
        return components.add(node, 2);
      },
      ObjectExpression: function(node) {
        if (!utils.isES5Component(node)) {
          return;
        }
        return components.add(node, 2);
      },
      FunctionExpression: function(node) {
        var component;
        if (node.async) {
          components.add(node, 0);
          return;
        }
        component = utils.getParentComponent();
        if (!component || (component.parent && component.parent.type === 'JSXExpressionContainer')) {
          // Ban the node if we cannot find a parent component
          components.add(node, 0);
          return;
        }
        return components.add(component, 1);
      },
      FunctionDeclaration: function(node) {
        if (node.async) {
          components.add(node, 0);
          return;
        }
        node = utils.getParentComponent();
        if (!node) {
          return;
        }
        return components.add(node, 1);
      },
      ArrowFunctionExpression: function(node) {
        var component;
        if (node.async) {
          components.add(node, 0);
          return;
        }
        component = utils.getParentComponent();
        if (!component || (component.parent && component.parent.type === 'JSXExpressionContainer')) {
          // Ban the node if we cannot find a parent component
          components.add(node, 0);
          return;
        }
        if (component.expression && utils.isReturningJSX(component)) {
          return components.add(component, 2);
        } else {
          return components.add(component, 1);
        }
      },
      ThisExpression: function(node) {
        var component;
        component = utils.getParentComponent();
        if (!component || !/Function/.test(component.type) || !node.parent.property) {
          return;
        }
        // Ban functions accessing a property on a ThisExpression
        return components.add(node, 0);
      },
      ReturnStatement: function(node) {
        var scope;
        if (!utils.isReturningJSX(node)) {
          return;
        }
        node = utils.getParentComponent();
        if (!node) {
          scope = context.getScope();
          components.add(scope.block, 1);
          return;
        }
        return components.add(node, 2);
      },
      ExpressionStatement: function(node) {
        var scope;
        if (!utils.isReturningJSX(node)) {
          return;
        }
        node = utils.getParentComponent();
        if (!node) {
          scope = context.getScope();
          components.add(scope.block, 1);
          return;
        }
        return components.add(node, 2);
      }
    };
    // Update the provided rule instructions to add the component detection
    ruleInstructions = rule(context, components, utils);
    updatedRuleInstructions = util._extend({}, ruleInstructions);
    propTypesInstructions = propTypes(context, components, utils);
    allKeys = new Set(Object.keys(detectionInstructions).concat(Object.keys(propTypesInstructions)));
    allKeys.forEach(function(instruction) {
      return updatedRuleInstructions[instruction] = function(node) {
        if (instruction in detectionInstructions) {
          detectionInstructions[instruction](node);
        }
        if (instruction in propTypesInstructions) {
          propTypesInstructions[instruction](node);
        }
        if (ruleInstructions[instruction]) {
          return ruleInstructions[instruction](node);
        } else {
          return void 0;
        }
      };
    });
    // Return the updated rule instructions
    return updatedRuleInstructions;
  };

  module.exports = Object.assign(Components, {
    detect: function(rule) {
      return componentRule.bind(this, rule);
    }
  });

}).call(this);
