// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Utility functions for AST
   */
  'use strict';
  /**
   * Find a return statment in the current node
   *
   * @param {ASTNode} ASTnode The AST node being checked
   */
  /**
   * Get properties for a given AST node
   * @param {ASTNode} node The AST node being checked.
   * @returns {Array} Properties array.
   */
  /**
   * Get properties name
   * @param {Object} node - Property.
   * @returns {String} Property name.
   */
  /**
   * Get node with property's name
   * @param {Object} node - Property.
   * @returns {Object} Property name node.
   */
  /**
   * Checks if the node is a function or arrow function expression.
   * @param {Object} context The node to check
   * @return {Boolean} true if it's a function-like expression
   */
  /**
   * Checks if the node is the first in its line, excluding whitespace.
   * @param {Object} context The node to check
   * @param {ASTNode} node The node to check
   * @return {Boolean} true if it's the first node in its line
   */
  var findReturnStatement, getComponentProperties, getPropertyName, getPropertyNameNode, isFunctionLikeExpression, isNodeFirstInLine;

  findReturnStatement = function(node) {
    var bodyNode, bodyNodes, found, i, ifStatement, ifStatements, j, len, ref, ref1, ref2, ref3;
    if (!((ref = node.value) != null ? (ref1 = ref.body) != null ? ref1.body : void 0 : void 0) && !((ref2 = node.body) != null ? ref2.body : void 0)) {
      return {};
    }
    bodyNodes = node.value ? node.value.body.body : node.body.body;
    ifStatements = [];
    for (i = bodyNodes.length - 1; i >= 0; i += -1) {
      bodyNode = bodyNodes[i];
      if (bodyNode.type === 'ReturnStatement') {
        return {
          node: bodyNode,
          property: 'argument',
          expression: bodyNode.argument
        };
      }
      if ((ref3 = bodyNode.expression) != null ? ref3.returns : void 0) { // or bodyNode.returns
        return {
          node: bodyNode,
          property: 'expression',
          expression: bodyNode.expression
        };
      }
      if (bodyNode.type === 'IfStatement') {
        ifStatements.push(bodyNode);
      }
    }
    for (j = 0, len = ifStatements.length; j < len; j++) {
      ifStatement = ifStatements[j];
      found = findReturnStatement({
        body: ifStatement.consequent
      });
      if (found.node != null) {
        return found;
      }
      if (!ifStatement.alternate) {
        continue;
      }
      found = findReturnStatement({
        body: ifStatement.alternate
      });
      if (found.node != null) {
        return found;
      }
    }
    return {};
  };

  getPropertyNameNode = function(node) {
    if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
      return node.key;
    }
    if (node.type === 'MemberExpression') {
      return node.property;
    }
    return null;
  };

  getPropertyName = function(node) {
    var nameNode, ref;
    nameNode = getPropertyNameNode(node);
    return (ref = nameNode != null ? nameNode.name : void 0) != null ? ref : '';
  };

  getComponentProperties = function(node) {
    switch (node.type) {
      case 'ClassDeclaration':
      case 'ClassExpression':
        return node.body.body.filter(function({type}) {
          return type === 'ClassProperty' || type === 'MethodDefinition';
        });
      case 'ObjectExpression':
        return node.properties;
      default:
        return [];
    }
  };

  isNodeFirstInLine = function(context, node) {
    var endLine, lines, sourceCode, startLine, token;
    sourceCode = context.getSourceCode();
    token = node;
    token = sourceCode.getTokenBefore(token);
    lines = token.type === 'JSXText' ? token.value.split('\n') : null;
    while (token.type === 'JSXText' && /^\s*$/.test(lines[lines.length - 1])) {
      token = sourceCode.getTokenBefore(token);
      lines = token.type === 'JSXText' ? token.value.split('\n') : null;
    }
    startLine = node.loc.start.line;
    endLine = token ? token.loc.end.line : -1;
    return startLine !== endLine;
  };

  isFunctionLikeExpression = function(node) {
    var ref;
    return (ref = node.type) === 'FunctionExpression' || ref === 'ArrowFunctionExpression';
  };

  module.exports = {findReturnStatement, getPropertyName, getPropertyNameNode, getComponentProperties, isNodeFirstInLine, isFunctionLikeExpression};

}).call(this);
