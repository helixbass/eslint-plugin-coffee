// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to count multiple spaces in regular expressions
   * @author Matt DuVall <http://www.mattduvall.com/>
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow multiple spaces in regular expressions',
        category: 'Possible Errors',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-regex-spaces'
      },
      schema: [],
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Validate strings passed to the RegExp constructor
       * @param {ASTNode} node node to validate
       * @returns {void}
       * @private
       */
      /*
       * TODO: (platinumazure) Fix message to use rule message
       * substitution when api.report is fixed in lib/eslint.js.
       */
      /**
       * Validate regular expression literals
       * @param {ASTNode} node node to validate
       * @returns {void}
       * @private
       */
      /**
       * Validate regular expressions
       * @param {ASTNode} node node to validate
       * @param {string} value regular expression to validate
       * @param {number} valueStart The start location of the regex/string literal. It will always be the case that
       * `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`
       * @returns {void}
       * @private
       */
      /**
       * Check if node is a string
       * @param {ASTNode} node node to evaluate
       * @returns {boolean} True if its a string
       * @private
       */
      var checkFunction, checkLiteral, checkRegex, isString, sourceCode;
      sourceCode = context.getSourceCode();
      checkRegex = function(node, value, valueStart) {
        var count, multipleSpacesRegex, regexResults;
        multipleSpacesRegex = /( {2,})( [+*{?]|[^+*{?]|$)/;
        regexResults = multipleSpacesRegex.exec(value);
        if (regexResults !== null) {
          count = regexResults[1].length;
          return context.report({
            node,
            message: 'Spaces are hard to count. Use {{{count}}}.',
            data: {count},
            fix: function(fixer) {
              return fixer.replaceTextRange([valueStart + regexResults.index, valueStart + regexResults.index + count], ` {${count}}`);
            }
          });
        }
      };
      checkLiteral = function(node) {
        var nodeType, nodeValue, token;
        token = sourceCode.getFirstToken(node);
        nodeType = token.type;
        nodeValue = node.raw;
        if (nodeType === 'RegularExpression') {
          return checkRegex(node, nodeValue, token.range[0]);
        }
      };
      isString = function(node) {
        return node && node.type === 'Literal' && typeof node.value === 'string';
      };
      checkFunction = function(node) {
        var regExpVar, scope, shadowed;
        scope = context.getScope();
        regExpVar = astUtils.getVariableByName(scope, 'RegExp');
        shadowed = regExpVar && regExpVar.defs.length > 0;
        if (node.callee.type === 'Identifier' && node.callee.name === 'RegExp' && isString(node.arguments[0]) && !shadowed) {
          return checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
        }
      };
      return {
        Literal: checkLiteral,
        CallExpression: checkFunction,
        NewExpression: checkFunction
      };
    }
  };

}).call(this);
