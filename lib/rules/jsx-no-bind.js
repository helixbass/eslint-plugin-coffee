// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevents usage of Function.prototype.bind and arrow functions
   *               in React component props.
   * @author Daniel Lo Nigro <dan.cx>
   * @author Jacky Ho
   */
  'use strict';
  var Components, docsUrl, jsxUtil, propName, violationMessageStore;

  propName = require('jsx-ast-utils/propName');

  Components = require('../util/react/Components');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  jsxUtil = require('../util/react/jsx');

  // {isDeclarationAssignment} = '../util/ast-utils'

  // -----------------------------------------------------------------------------
  // Rule Definition
  // -----------------------------------------------------------------------------
  violationMessageStore = {
    bindCall: 'JSX props should not use .bind()',
    arrowFunc: 'JSX props should not use arrow functions',
    bindExpression: 'JSX props should not use ::',
    func: 'JSX props should not use functions'
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Prevents usage of Function.prototype.bind and arrow functions in React component props',
        category: 'Best Practices',
        recommended: false,
        url: docsUrl('jsx-no-bind')
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowArrowFunctions: {
              default: false,
              type: 'boolean'
            },
            allowBind: {
              default: false,
              type: 'boolean'
            },
            allowFunctions: {
              default: false,
              type: 'boolean'
            },
            ignoreRefs: {
              default: false,
              type: 'boolean'
            },
            ignoreDOMComponents: {
              default: false,
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context) {
      var addVariableNameToSet, blockVariableNameSets, configuration, findVariableViolation, getBlockStatementAncestors, getNodeViolationType, reportVariableViolation, setBlockVariableNameSet;
      configuration = context.options[0] || {};
      // Keep track of all the variable names pointing to a bind call,
      // bind expression or an arrow function in different block statements
      blockVariableNameSets = {};
      setBlockVariableNameSet = function(blockStart) {
        return blockVariableNameSets[blockStart] = {
          arrowFunc: new Set(),
          bindCall: new Set(),
          bindExpression: new Set(),
          func: new Set()
        };
      };
      getNodeViolationType = function(node) {
        var nodeType;
        if (node == null) {
          return null;
        }
        nodeType = node.type;
        if (!configuration.allowBind && nodeType === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'bind') {
          return 'bindCall';
        }
        if (nodeType === 'ConditionalExpression') {
          return getNodeViolationType(node.test) || getNodeViolationType(node.consequent) || getNodeViolationType(node.alternate);
        }
        if (!configuration.allowArrowFunctions && nodeType === 'ArrowFunctionExpression') {
          return 'arrowFunc';
        }
        if (!configuration.allowFunctions && nodeType === 'FunctionExpression') {
          return 'func';
        }
        if (!configuration.allowBind && nodeType === 'BindExpression') {
          return 'bindExpression';
        }
        return null;
      };
      addVariableNameToSet = function(violationType, variableName, blockStart) {
        return blockVariableNameSets[blockStart][violationType].add(variableName);
      };
      getBlockStatementAncestors = function(node) {
        return context.getAncestors(node).reverse().filter(function(ancestor) {
          return ancestor.type === 'BlockStatement';
        });
      };
      reportVariableViolation = function(node, name, blockStart) {
        var blockSets, violationTypes;
        blockSets = blockVariableNameSets[blockStart];
        violationTypes = Object.keys(blockSets);
        return violationTypes.find(function(type) {
          if (blockSets[type].has(name)) {
            context.report({
              node,
              message: violationMessageStore[type]
            });
            return true;
          }
          return false;
        });
      };
      findVariableViolation = function(node, name) {
        return getBlockStatementAncestors(node).find(function(block) {
          return reportVariableViolation(node, name, block.start);
        });
      };
      return {
        BlockStatement: function(node) {
          return setBlockVariableNameSet(node.start);
        },
        AssignmentExpression: function(node) {
          var blockAncestors, variableViolationType;
          if (!(node.left.type === 'Identifier' && node.left.declaration)) {
            return;
          }
          blockAncestors = getBlockStatementAncestors(node);
          variableViolationType = getNodeViolationType(node.right);
          if (blockAncestors.length > 0 && variableViolationType) { // and # node.parent.kind is 'const' # only support const right now # TODO: should check for reassignment?
            return addVariableNameToSet(variableViolationType, node.left.name, blockAncestors[0].start);
          }
        },
        VariableDeclarator: function(node) {
          var blockAncestors, variableViolationType;
          if (!node.init) {
            return;
          }
          blockAncestors = getBlockStatementAncestors(node);
          variableViolationType = getNodeViolationType(node.init);
          if (blockAncestors.length > 0 && variableViolationType && node.parent.kind === 'const') { // only support const right now
            return addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].start);
          }
        },
        JSXAttribute: function(node) {
          var isDOMComponent, isRef, nodeViolationType, valueNode, valueNodeType;
          isRef = configuration.ignoreRefs && propName(node) === 'ref';
          if (isRef || !node.value || !node.value.expression) {
            return;
          }
          isDOMComponent = jsxUtil.isDOMComponent(node.parent);
          if (configuration.ignoreDOMComponents && isDOMComponent) {
            return;
          }
          valueNode = node.value.expression;
          valueNodeType = valueNode.type;
          nodeViolationType = getNodeViolationType(valueNode);
          if (valueNodeType === 'Identifier') {
            return findVariableViolation(node, valueNode.name);
          } else if (nodeViolationType) {
            return context.report({
              node,
              message: violationMessageStore[nodeViolationType]
            });
          }
        }
      };
    })
  };

}).call(this);
