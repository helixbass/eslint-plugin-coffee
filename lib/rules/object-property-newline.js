// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to enforce placing object properties on separate lines.
   * @author Vitor Balocco
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce placing object properties on separate lines',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/object-property-newline'
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowAllPropertiesOnSameLine: {
              type: 'boolean'
            },
            allowMultiplePropertiesPerLine: {
              // Deprecated
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    // fixable: 'whitespace'
    create: function(context) {
      var allowSameLine, errorMessage, sourceCode;
      allowSameLine = context.options[0] && (Boolean(context.options[0].allowAllPropertiesOnSameLine) || Boolean(context.options[0].allowMultiplePropertiesPerLine)); // Deprecated
      errorMessage = allowSameLine ? "Object properties must go on a new line if they aren't all on the same line." : 'Object properties must go on a new line.';
      sourceCode = context.getSourceCode();
      return {
        ObjectExpression: function(node) {
          var firstTokenOfCurrentProperty, firstTokenOfFirstProperty, i, j, lastTokenOfLastProperty, lastTokenOfPreviousProperty, ref, results;
          if (!node.properties.length) {
            return;
          }
          if (allowSameLine) {
            if (node.properties.length > 1) {
              firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
              lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
              // All keys and values are on the same line
              if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
                return;
              }
            }
          }
          results = [];
          for (i = j = 1, ref = node.properties.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
            lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
            firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
            if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
              results.push(context.report({
                node,
                loc: firstTokenOfCurrentProperty.loc.start,
                message: errorMessage
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    }
  };

  // fix: (fixer) ->
//   comma = sourceCode.getTokenBefore firstTokenOfCurrentProperty
//   rangeAfterComma = [
//     comma.range[1]
//     firstTokenOfCurrentProperty.range[0]
//   ]

  //   # Don't perform a fix if there are any comments between the comma and the next property.
//   return null if sourceCode.text
//   .slice(rangeAfterComma[0], rangeAfterComma[1])
//   .trim()

  //   fixer.replaceTextRange rangeAfterComma, '\n'

}).call(this);
