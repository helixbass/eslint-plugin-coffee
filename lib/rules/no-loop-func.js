// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag creation of function inside a loop
   * @author Ilya Volodin
   */
  'use strict';
  /**
   * Gets the containing loop node of a given node.
   * If the loop was nested, this returns the most outer loop.
   *
   * @param {ASTNode} node - A node to get. This is a loop node.
   * @param {ASTNode|null} excludedNode - A node that the result node should not
   *      include.
   * @returns {ASTNode} The most outer loop node.
   */
  /**
   * Checks whether a given reference which refers to an upper scope's variable is
   * safe or not.
   *
   * @param {ASTNode} loopNode - A containing loop node.
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is safe or not.
   */
  var getContainingLoopNode, getTopLoopNode, isSafe;

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Gets the containing loop node of a specified node.
   *
   * We don't need to check nested functions, so this ignores those.
   * `Scope.through` contains references of nested functions.
   *
   * @param {ASTNode} node - An AST node to get.
   * @returns {ASTNode|null} The containing loop node of the specified node, or
   *      `null`.
   */
  getContainingLoopNode = function(node) {
    var currentNode, parent;
    currentNode = node;
    while (currentNode.parent) {
      ({parent} = currentNode);
      switch (parent.type) {
        case 'WhileStatement':
        case 'DoWhileStatement':
          return parent;
        case 'ForStatement':
          if (parent.init !== currentNode) {
            return parent;
          }
          break;
        case 'ForInStatement':
        case 'ForOfStatement':
          if (parent.right !== currentNode) {
            return parent;
          }
          break;
        case 'For':
          if (parent.source !== currentNode) {
            return parent;
          }
          break;
        case 'ArrowFunctionExpression':
        case 'FunctionExpression':
        case 'FunctionDeclaration':
          return null;
      }
      currentNode = currentNode.parent;
    }
    // `init` is outside of the loop.
    // `right` is outside of the loop.
    // We don't need to check nested functions.
    return null;
  };

  getTopLoopNode = function(node, excludedNode) {
    var border, containingLoopNode, retv;
    border = excludedNode ? excludedNode.range[1] : 0;
    retv = node;
    containingLoopNode = node;
    while (containingLoopNode && containingLoopNode.range[0] >= border) {
      retv = containingLoopNode;
      containingLoopNode = getContainingLoopNode(containingLoopNode);
    }
    return retv;
  };

  isSafe = function(loopNode, reference) {
    /*
     * WriteReferences which exist after this border are unsafe because those
     * can modify the variable.
     */
    /**
     * Checks whether a given reference is safe or not.
     * The reference is every reference of the upper scope's variable we are
     * looking now.
     *
     * It's safeafe if the reference matches one of the following condition.
     * - is readonly.
     * - doesn't exist inside a local function and after the border.
     *
     * @param {eslint-scope.Reference} upperRef - A reference to check.
     * @returns {boolean} `true` if the reference is safe.
     */
    var border, declaration, definition, isSafeReference, kind, variable;
    variable = reference.resolved;
    definition = variable != null ? variable.defs[0] : void 0;
    declaration = definition != null ? definition.parent : void 0;
    kind = declaration && declaration.type === 'VariableDeclaration' ? declaration.kind : '';
    if (kind === 'const') {
      // Variables which are declared by `const` is safe.
      return true;
    }
    if (kind === 'let' && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
      /*
       * Variables which are declared by `let` in the loop is safe.
       * It's a different instance from the next loop step's.
       */
      return true;
    }
    border = getTopLoopNode(loopNode, kind === 'let' ? declaration : null).range[0];
    isSafeReference = function(upperRef) {
      var id;
      id = upperRef.identifier;
      return !upperRef.isWrite() || (variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border);
    };
    return Boolean(variable) && variable.references.every(isSafeReference);
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow `function` declarations and expressions inside loop statements',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-loop-func'
      },
      schema: []
    },
    create: function(context) {
      /**
       * Reports functions which match the following condition:
       *
       * - has a loop node in ancestors.
       * - has any references which refers to an unsafe variable.
       *
       * @param {ASTNode} node The AST node to check.
       * @returns {boolean} Whether or not the node is within a loop.
       */
      var checkForLoops;
      checkForLoops = function(node) {
        var loopNode, references;
        loopNode = getContainingLoopNode(node);
        if (!loopNode) {
          return;
        }
        references = context.getScope().through;
        if (references.length > 0 && !references.every(isSafe.bind(null, loopNode))) {
          return context.report({
            node,
            message: "Don't make functions within a loop."
          });
        }
      };
      return {
        ArrowFunctionExpression: checkForLoops,
        FunctionExpression: checkForLoops,
        FunctionDeclaration: checkForLoops
      };
    }
  };

}).call(this);
