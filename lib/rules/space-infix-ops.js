// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Require spaces around infix operators
   * @author Michael Ficarra
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require spacing around infix operators',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/space-infix-ops'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            int32Hint: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Check if the node is binary then report
       * @param {ASTNode} node node to evaluate
       * @returns {void}
       * @private
       */
      /**
       * Check if the node is a variable
       * @param {ASTNode} node node to evaluate
       * @returns {void}
       * @private
       */
      /**
       * Returns the first token which violates the rule
       * @param {ASTNode} left - The left node of the main node
       * @param {ASTNode} right - The right node of the main node
       * @returns {Object} The violator token or null
       * @private
       */
      /**
       * Reports an AST node as a rule violation
       * @param {ASTNode} mainNode - The node to report
       * @param {Object} culpritToken - The token which has a problem
       * @returns {void}
       * @private
       */
      var OPERATORS, checkBinary, checkVar, getFirstNonSpacedToken, int32Hint, report, sourceCode;
      int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
      OPERATORS = ['*', '/', '%', '+', '-', '<<', '>>', '>>>', '<', '<=', '>', '>=', 'not in', 'in', 'not of', 'of', 'instanceof', '==', '!=', 'is', 'isnt', '&', '^', '|', '&&', 'and', '||', 'or', '?', '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '&&=', 'and=', '||=', 'or=', '?=', ',', '**', '%%'];
      sourceCode = context.getSourceCode();
      getFirstNonSpacedToken = function(left, right) {
        var i, j, op, ref, ref1, tokens;
        tokens = sourceCode.getTokensBetween(left, right, 1);
        for (i = j = 1, ref = tokens.length - 1; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
          op = tokens[i];
          if (((ref1 = op.type) === 'Punctuator' || ref1 === 'Keyword') && OPERATORS.indexOf(op.value) >= 0 && (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])) {
            return op;
          }
        }
        return null;
      };
      report = function(mainNode, culpritToken) {
        return context.report({
          node: mainNode,
          loc: culpritToken.loc.start,
          message: 'Infix operators must be spaced.',
          fix: function(fixer) {
            var afterToken, fixString, previousToken, ref;
            previousToken = sourceCode.getTokenBefore(culpritToken);
            afterToken = sourceCode.getTokenAfter(culpritToken);
            fixString = '';
            if (culpritToken.range[0] - previousToken.range[1] === 0) {
              fixString = ' ';
            }
            // could actually be `not in` or `not of`
            fixString += (ref = culpritToken.value) === 'in' || ref === 'of' ? sourceCode.getText(culpritToken) : culpritToken.value;
            if (afterToken.range[0] - culpritToken.range[1] === 0) {
              fixString += ' ';
            }
            return fixer.replaceText(culpritToken, fixString);
          }
        });
      };
      checkBinary = function(node) {
        var leftNode, nonSpacedNode, rightNode;
        leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
        rightNode = node.right;
        nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);
        if (nonSpacedNode) {
          if (!(int32Hint && sourceCode.getText(node).endsWith('|0'))) {
            return report(node, nonSpacedNode);
          }
        }
      };
      checkVar = function(node) {
        var leftNode, nonSpacedNode, rightNode;
        leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
        rightNode = node.init;
        if (rightNode) {
          nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode);
          if (nonSpacedNode) {
            return report(node, nonSpacedNode);
          }
        }
      };
      return {
        AssignmentExpression: checkBinary,
        AssignmentPattern: checkBinary,
        BinaryExpression: checkBinary,
        LogicalExpression: checkBinary,
        VariableDeclarator: checkVar
      };
    }
  };

}).call(this);
