// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag the use of redundant constructors in classes.
   * @author Alberto Rodr√≠guez
   */
  'use strict';
  /**
   * Checks whether the parameters of a constructor and the arguments of `super()`
   * have the same values or not.
   * @param {ASTNode} ctorParams The parameters of a constructor to check.
   * @param {ASTNode} superArgs The arguments of `super()` to check.
   * @returns {boolean} `true` if those have the same values.
   */
  /**
   * Checks whether the constructor body is a redundant super call.
   * @param {Array} body constructor body content.
   * @param {Array} ctorParams The params to check against super call.
   * @returns {boolean} true if the construtor body is redundant
   */
  /**
   * Checks whether a given node is a pattern which doesn't have any side effects.
   * Default parameters and Destructuring parameters can have side effects.
   * @param {ASTNode} node A pattern node.
   * @returns {boolean} `true` if the node doesn't have any side effects.
   */
  /**
   * Checks whether a given array of expressions is `...arguments` or not.
   * `super(...arguments)` passes all arguments through.
   * @param {ASTNode[]} superArgs An array of expressions to check.
   * @returns {boolean} `true` if the superArgs is `...arguments`.
   */
  /**
   * Checks whether given 2 nodes are identifiers which have the same name or not.
   * @param {ASTNode} ctorParam A node to check.
   * @param {ASTNode} superArg A node to check.
   * @returns {boolean} `true` if the nodes are identifiers which have the same
   *      name.
   */
  /**
   * Checks whether given 2 nodes have the same value or not.
   * @param {ASTNode} ctorParam A node to check.
   * @param {ASTNode} superArg A node to check.
   * @returns {boolean} `true` if the nodes have the same value or not.
   */
  /**
   * Checks whether given 2 nodes are a rest/spread pair which has the same values.
   * @param {ASTNode} ctorParam A node to check.
   * @param {ASTNode} superArg A node to check.
   * @returns {boolean} `true` if the nodes are a rest/spread pair which has the
   *      same values.
   */
  var hasThisParams, isPassingThrough, isRedundantSuperCall, isSimple, isSingleSuperCall, isSpreadArguments, isThisParam, isValidIdentifierPair, isValidPair, isValidRestSpreadPair;

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Checks whether a given array of statements is a single call of `super`.
   * @param {ASTNode[]} body An array of statements to check.
   * @returns {boolean} `true` if the body is a single call of `super`.
   */
  isSingleSuperCall = function(body) {
    return body.length === 1 && body[0].type === 'ExpressionStatement' && body[0].expression.type === 'CallExpression' && body[0].expression.callee.type === 'Super';
  };

  isSimple = function(node) {
    var ref;
    return (ref = node.type) === 'Identifier' || ref === 'RestElement';
  };

  isSpreadArguments = function(superArgs) {
    return superArgs.length === 1 && superArgs[0].type === 'SpreadElement' && superArgs[0].argument.type === 'Identifier' && superArgs[0].argument.name === 'arguments';
  };

  isValidIdentifierPair = function(ctorParam, superArg) {
    return ctorParam.type === 'Identifier' && superArg.type === 'Identifier' && ctorParam.name === superArg.name;
  };

  isValidRestSpreadPair = function(ctorParam, superArg) {
    return ctorParam.type === 'RestElement' && superArg.type === 'SpreadElement' && isValidIdentifierPair(ctorParam.argument, superArg.argument);
  };

  isValidPair = function(ctorParam, superArg) {
    return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
  };

  isPassingThrough = function(ctorParams, superArgs) {
    var i;
    if (ctorParams.length !== superArgs.length) {
      return false;
    }
    i = 0;
    while (i < ctorParams.length) {
      if (!isValidPair(ctorParams[i], superArgs[i])) {
        return false;
      }
      ++i;
    }
    return true;
  };

  isRedundantSuperCall = function(body, ctorParams) {
    return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
  };

  isThisParam = function(param) {
    var current, element, property;
    current = param;
    while (current) {
      switch (current.type) {
        case 'ThisExpression':
          return true;
        case 'MemberExpression':
          current = current.object;
          break;
        case 'ArrayPattern':
          return ((function() {
            var j, len, ref, results;
            ref = current.elements;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              element = ref[j];
              if (isThisParam(element)) {
                results.push(true);
              }
            }
            return results;
          })()).length > 0;
        case 'ObjectPattern':
          return ((function() {
            var j, len, ref, results;
            ref = current.properties;
            results = [];
            for (j = 0, len = ref.length; j < len; j++) {
              property = ref[j];
              if (isThisParam(property)) {
                results.push(true);
              }
            }
            return results;
          })()).length > 0;
        case 'Property':
          current = current.value;
          break;
        case 'AssignmentPattern':
          current = current.left;
          break;
        default:
          return false;
      }
    }
    return false;
  };

  hasThisParams = function(params) {
    var j, len, param;
    for (j = 0, len = params.length; j < len; j++) {
      param = params[j];
      if (isThisParam(param)) {
        return true;
      }
    }
    return false;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      type: 'suggestion',
      docs: {
        description: 'disallow unnecessary constructors',
        category: 'ECMAScript 6',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-useless-constructor'
      },
      schema: []
    },
    create: function(context) {
      /**
       * Checks whether a node is a redundant constructor
       * @param {ASTNode} node node to check
       * @returns {void}
       */
      var checkForConstructor;
      checkForConstructor = function(node) {
        var body, ctorParams, superClass;
        if (node.kind !== 'constructor') {
          return;
        }
        ({body} = node.value.body);
        ctorParams = node.value.params;
        ({superClass} = node.parent.parent);
        if ((superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0 && !hasThisParams(ctorParams))) {
          return context.report({
            node,
            message: 'Useless constructor.'
          });
        }
      };
      return {
        MethodDefinition: checkForConstructor
      };
    }
  };

}).call(this);
