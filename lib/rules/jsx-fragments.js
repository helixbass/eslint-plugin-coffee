// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce shorthand or standard form for React fragments.
   * @author Alex Zherdev
   */
  'use strict';
  var docsUrl, elementType, pragmaUtil, replaceNode, variableUtil, versionUtil;

  elementType = require('jsx-ast-utils/elementType');

  pragmaUtil = require('eslint-plugin-react/lib/util/pragma');

  variableUtil = require('../util/react/variable');

  versionUtil = require('eslint-plugin-react/lib/util/version');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  replaceNode = function(source, node, text) {
    return `${source.slice(0, node.range[0])}${text}${source.slice(node.range[1])}`;
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Enforce shorthand or standard form for React fragments',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-fragments')
      },
      fixable: 'code',
      schema: [
        {
          enum: ['syntax',
        'element']
        }
      ]
    },
    create: function(context) {
      var closeFragLong, closeFragShort, configuration, fragmentNames, fragmentPragma, getFixerToLong, getFixerToShort, jsxElements, openFragLong, openFragShort, reactPragma, refersToReactFragment, reportOnReactVersion;
      configuration = context.options[0] || 'syntax';
      reactPragma = pragmaUtil.getFromContext(context);
      fragmentPragma = pragmaUtil.getFragmentFromContext(context);
      openFragShort = '<>';
      closeFragShort = '</>';
      openFragLong = `<${reactPragma}.${fragmentPragma}>`;
      closeFragLong = `</${reactPragma}.${fragmentPragma}>`;
      reportOnReactVersion = function(node) {
        if (!versionUtil.testReactVersion(context, '16.2.0')) {
          context.report({
            node,
            message: 'Fragments are only supported starting from React v16.2. ' + 'Please disable the `react/jsx-fragments` rule in ESLint settings or upgrade your version of React.'
          });
          return true;
        }
        return false;
      };
      getFixerToLong = function(jsxFragment) {
        var sourceCode;
        sourceCode = context.getSourceCode();
        return function(fixer) {
          var lengthDiff, range, source;
          source = sourceCode.getText();
          source = replaceNode(source, jsxFragment.closingFragment, closeFragLong);
          source = replaceNode(source, jsxFragment.openingFragment, openFragLong);
          lengthDiff = openFragLong.length - sourceCode.getText(jsxFragment.openingFragment).length + closeFragLong.length - sourceCode.getText(jsxFragment.closingFragment).length;
          ({range} = jsxFragment);
          return fixer.replaceTextRange(range, source.slice(range[0], range[1] + lengthDiff));
        };
      };
      getFixerToShort = function(jsxElement) {
        var sourceCode;
        sourceCode = context.getSourceCode();
        return function(fixer) {
          var lengthDiff, range, source;
          source = sourceCode.getText();
          if (jsxElement.closingElement) {
            source = replaceNode(source, jsxElement.closingElement, closeFragShort);
            source = replaceNode(source, jsxElement.openingElement, openFragShort);
            lengthDiff = sourceCode.getText(jsxElement.openingElement).length - openFragShort.length + sourceCode.getText(jsxElement.closingElement).length - closeFragShort.length;
          } else {
            source = replaceNode(source, jsxElement.openingElement, `${openFragShort}${closeFragShort}`);
            lengthDiff = sourceCode.getText(jsxElement.openingElement).length - openFragShort.length - closeFragShort.length;
          }
          ({range} = jsxElement);
          return fixer.replaceTextRange(range, source.slice(range[0], range[1] - lengthDiff));
        };
      };
      refersToReactFragment = function(name) {
        var variableInit;
        variableInit = variableUtil.findVariableByName(context, name);
        if (!variableInit) {
          return false;
        }
        if (variableInit.type === 'Identifier' && variableInit.name === reactPragma) {
          // const { Fragment } = React;
          return true;
        }
        if (variableInit.type === 'MemberExpression' && variableInit.object.type === 'Identifier' && variableInit.object.name === reactPragma && variableInit.property.type === 'Identifier' && variableInit.property.name === fragmentPragma) {
          // const Fragment = React.Fragment;
          return true;
        }
        if (variableInit.callee && variableInit.callee.name === 'require' && variableInit.arguments && variableInit.arguments[0] && variableInit.arguments[0].value === 'react') {
          // const { Fragment } = require('react');
          return true;
        }
        return false;
      };
      jsxElements = [];
      fragmentNames = new Set([`${reactPragma}.${fragmentPragma}`]);
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        JSXElement: function(node) {
          return jsxElements.push(node);
        },
        JSXFragment: function(node) {
          if (reportOnReactVersion(node)) {
            return;
          }
          if (configuration === 'element') {
            return context.report({
              node,
              message: `Prefer ${reactPragma}.${fragmentPragma} over fragment shorthand`,
              fix: getFixerToLong(node)
            });
          }
        },
        ImportDeclaration: function(node) {
          if (node.source && node.source.value === 'react') {
            return node.specifiers.forEach(function(spec) {
              if (spec.imported && spec.imported.name === fragmentPragma) {
                if (spec.local) {
                  return fragmentNames.add(spec.local.name);
                }
              }
            });
          }
        },
        'Program:exit': function() {
          return jsxElements.forEach(function(node) {
            var attrs, elName, openingEl;
            openingEl = node.openingElement;
            elName = elementType(openingEl);
            if (fragmentNames.has(elName) || refersToReactFragment(elName)) {
              if (reportOnReactVersion(node)) {
                return;
              }
              attrs = openingEl.attributes;
              if (configuration === 'syntax' && !(attrs && attrs.length > 0)) {
                return context.report({
                  node,
                  message: `Prefer fragment shorthand over ${reactPragma}.${fragmentPragma}`,
                  fix: getFixerToShort(node)
                });
              }
            }
          });
        }
      };
    }
  };

}).call(this);
