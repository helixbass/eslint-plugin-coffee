// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
   * @author Brandon Mills
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------

  // astUtils = require '../eslint-ast-utils'

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow unnecessary boolean casts',
        category: 'Possible Errors',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-extra-boolean-cast'
      },
      schema: [],
      // fixable: 'code'
      messages: {
        unexpectedCall: 'Redundant Boolean call.',
        unexpectedNegation: 'Redundant double negation.'
      }
    },
    create: function(context) {
      /**
       * Check if a node is in a context where its value would be coerced to a boolean at runtime.
       *
       * @param {Object} node The node
       * @param {Object} parent Its parent
       * @returns {boolean} If it is in a boolean context
       */
      var BOOLEAN_NODE_TYPES, isInBooleanContext;
      // sourceCode = context.getSourceCode()

      // Node types which have a test which will coerce values to booleans.
      BOOLEAN_NODE_TYPES = ['IfStatement', 'WhileStatement', 'ConditionalExpression'];
      isInBooleanContext = function(node, parent) {
        // !<bool>
        return (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 && node === parent.test) || (parent.type === 'UnaryExpression' && parent.operator === '!');
      };
      return {
        UnaryExpression: function(node) {
          var ancestors, grandparent, parent, ref;
          ancestors = context.getAncestors();
          parent = ancestors.pop();
          grandparent = ancestors.pop();
          // Exit early if it's guaranteed not to match
          if (node.operator !== '!' || parent.type !== 'UnaryExpression' || parent.operator !== '!') {
            return;
          }
          // Boolean(<bool>) and new Boolean(<bool>)
          if (isInBooleanContext(parent, grandparent) || (((ref = grandparent.type) === 'CallExpression' || ref === 'NewExpression') && grandparent.callee.type === 'Identifier' && grandparent.callee.name === 'Boolean')) {
            return context.report({
              node,
              messageId: 'unexpectedNegation'
            });
          }
        },
        // fix: (fixer) ->
        //   fixer.replaceText parent, sourceCode.getText node.argument
        CallExpression: function(node) {
          var parent;
          ({parent} = node);
          if (node.callee.type !== 'Identifier' || node.callee.name !== 'Boolean') {
            return;
          }
          if (isInBooleanContext(node, parent)) {
            return context.report({
              node,
              messageId: 'unexpectedCall'
            });
          }
        }
      };
    }
  };

  // fix: (fixer) ->
//   return fixer.replaceText parent, 'true' unless node.arguments.length

  //   return null if (
//     node.arguments.length > 1 or
//     node.arguments[0].type is 'SpreadElement'
//   )

  //   argument = node.arguments[0]

  //   return fixer.replaceText(
//     node
//     "(#{sourceCode.getText argument})"
//   ) if (
//     astUtils.getPrecedence(argument) <
//     astUtils.getPrecedence node.parent
//   )
//   fixer.replaceText node, sourceCode.getText argument

}).call(this);
