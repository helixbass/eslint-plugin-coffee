// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce default props alphabetical sorting
   * @author Vladimir Kattsov
   */
  'use strict';
  var docsUrl, variableUtil;

  variableUtil = require('../util/react/variable');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce default props alphabetical sorting',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-sort-default-props')
      },
      schema: [
        {
          type: 'object',
          properties: {
            ignoreCase: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if defaultProps declarations are sorted
       * @param {Array} declarations The array of AST nodes being checked.
       * @returns {void}
       */
      /**
       * Find a variable by name in the current scope.
       * @param  {string} name Name of the variable to look for.
       * @returns {ASTNode|null} Return null if the variable could not be found, ASTNode otherwise.
       */
      /**
       * Get properties name
       * @param {Object} node - Property.
       * @returns {String} Property name.
       */
      /**
       * Checks if the Identifier node passed in looks like a defaultProps declaration.
       * @param   {ASTNode}  node The node to check. Must be an Identifier node.
       * @returns {Boolean}       `true` if the node is a defaultProps declaration, `false` if not
       */
      var checkNode, checkSorted, configuration, findVariableByName, getKey, getPropertyName, ignoreCase, isDefaultPropsDeclaration, propWrapperFunctions, sourceCode;
      sourceCode = context.getSourceCode();
      configuration = context.options[0] || {};
      ignoreCase = configuration.ignoreCase || false;
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      getPropertyName = function(node) {
        var tokens;
        if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {
          return node.key.name;
        } else if (node.type === 'MemberExpression') {
          return node.property.name;
        // Special case for class properties
        // (babel-eslint@5 does not expose property name so we have to rely on tokens)
        } else if (node.type === 'ClassProperty') {
          tokens = context.getFirstTokens(node, 2);
          return (tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value);
        }
        return '';
      };
      isDefaultPropsDeclaration = function(node) {
        var propName;
        propName = getPropertyName(node);
        return propName === 'defaultProps' || propName === 'getDefaultProps';
      };
      getKey = function(node) {
        return sourceCode.getText(node.key || node.argument);
      };
      findVariableByName = function(name) {
        var defNode, ref, variable;
        variable = variableUtil.variablesInScope(context).find(function(item) {
          return item.name === name;
        });
        if (!(defNode = variable != null ? (ref = variable.defs[0]) != null ? ref.node : void 0 : void 0)) {
          return null;
        }
        if (defNode.type === 'TypeAlias') {
          return defNode.right;
        }
        if (defNode.parent.type === 'AssignmentExpression') {
          return defNode.parent.right;
        }
        return defNode.init;
      };
      checkSorted = function(declarations) {
        return declarations.reduce(function(prev, curr, idx, decls) {
          var currentPropName, prevPropName;
          if (/Spread/.test(curr.type)) {
            // return decls[idx + 1] if /SpreadProperty$/.test curr.type TODO: this should be ok once transformation happens
            return decls[idx + 1];
          }
          prevPropName = getKey(prev);
          currentPropName = getKey(curr);
          if (ignoreCase) {
            prevPropName = prevPropName.toLowerCase();
            currentPropName = currentPropName.toLowerCase();
          }
          if (currentPropName < prevPropName) {
            context.report({
              node: curr,
              message: 'Default prop types declarations should be sorted alphabetically'
            });
            return prev;
          }
          return curr;
        }, declarations[0]);
      };
      checkNode = function(node) {
        var innerNode, propTypesObject, ref;
        switch (node != null ? node.type : void 0) {
          case 'ObjectExpression':
            return checkSorted(node.properties);
          case 'Identifier':
            propTypesObject = findVariableByName(node.name);
            if (propTypesObject != null ? propTypesObject.properties : void 0) {
              return checkSorted(propTypesObject.properties);
            }
            break;
          case 'CallExpression':
            innerNode = (ref = node.arguments) != null ? ref[0] : void 0;
            if (propWrapperFunctions.has(node.callee.name) && innerNode) {
              return checkNode(innerNode);
            }
        }
      };
      return {
        // --------------------------------------------------------------------------
        // Public API
        // --------------------------------------------------------------------------
        ClassProperty: function(node) {
          if (!isDefaultPropsDeclaration(node)) {
            return;
          }
          return checkNode(node.value);
        },
        MemberExpression: function(node) {
          if (!isDefaultPropsDeclaration(node)) {
            return;
          }
          return checkNode(node.parent.right);
        }
      };
    }
  };

}).call(this);
