// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce component methods order
   * @author Yannick Croissant
   */
  'use strict';
  /**
   * Get the methods order from the default config and the user config
   * @param {Object} userConfig The user configuration.
   * @returns {Array} Methods order
   */
  var Components, astUtil, defaultConfig, docsUrl, getMethodsOrder, has, util,
    hasProp = {}.hasOwnProperty;

  ({has} = require('lodash'));

  util = require('util');

  Components = require('../util/react/Components');

  astUtil = require('../util/react/ast');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  defaultConfig = {
    order: ['static-methods', 'lifecycle', 'everything-else', 'render'],
    groups: {
      lifecycle: ['displayName', 'propTypes', 'contextTypes', 'childContextTypes', 'mixins', 'statics', 'defaultProps', 'constructor', 'getDefaultProps', 'state', 'getInitialState', 'getChildContext', 'getDerivedStateFromProps', 'componentWillMount', 'UNSAFE_componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'UNSAFE_componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'UNSAFE_componentWillUpdate', 'getSnapshotBeforeUpdate', 'componentDidUpdate', 'componentDidCatch', 'componentWillUnmount']
    }
  };

  getMethodsOrder = function(userConfig) {
    var config, entry, groups, j, len, order;
    userConfig || (userConfig = {});
    groups = util._extend(defaultConfig.groups, userConfig.groups);
    order = userConfig.order || defaultConfig.order;
    config = [];
    for (j = 0, len = order.length; j < len; j++) {
      entry = order[j];
      if (has(groups, entry)) {
        config = config.concat(groups[entry]);
      } else {
        config.push(entry);
      }
    }
    return config;
  };

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce component methods order',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('sort-comp')
      },
      schema: [
        {
          type: 'object',
          properties: {
            order: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            groups: {
              type: 'object',
              patternProperties: {
                '^.*$': {
                  type: 'array',
                  items: {
                    type: 'string'
                  }
                }
              }
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components) {
      /**
       * Check properties order from a properties list and store the eventual errors
       * @param {Array} properties Array containing all the properties.
       */
      /**
       * Compare two properties and find out if they are in the right order
       * @param {Array} propertiesInfos Array containing all the properties metadata.
       * @param {Object} propA First property name and metadata
       * @param {Object} propB Second property name.
       * @returns {Object} Object containing a correct true/false flag and the correct indexes for the two properties.
       */
      /**
       * Dedupe errors, only keep the ones with the highest score and delete the others
       */
      /**
       * Get properties name
       * @param {Object} node - Property.
       * @returns {String} Property name.
       */
      /**
       * Get indexes of the matching patterns in methods order configuration
       * @param {Object} method - Method metadata.
       * @returns {Array} The matching patterns indexes. Return [Infinity] if there is no match.
       */
      /**
       * Report errors
       */
      /**
       * Store a new error in the error list
       * @param {Object} propA - Mispositioned property.
       * @param {Object} propB - Reference property.
       */
      var MISPOSITION_MESSAGE, checkPropsOrder, comparePropsOrder, dedupeErrors, errors, getPropertyName, getRefPropIndexes, methodsOrder, regExpRegExp, reportErrors, storeError;
      errors = {};
      MISPOSITION_MESSAGE = '{{propA}} should be placed {{position}} {{propB}}';
      methodsOrder = getMethodsOrder(context.options[0]);
      // --------------------------------------------------------------------------
      // Public
      // --------------------------------------------------------------------------
      regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;
      getRefPropIndexes = function(method) {
        var everythingElseIndex, methodGroupIndexes;
        methodGroupIndexes = [];
        methodsOrder.forEach(function(currentGroup, groupIndex) {
          var isMatching, isRegExp;
          if (currentGroup === 'getters') {
            if (method.getter) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'setters') {
            if (method.setter) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'type-annotations') {
            if (method.typeAnnotation) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'static-methods') {
            if (method.static) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'instance-variables') {
            if (method.instanceVariable) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'instance-methods') {
            if (method.instanceMethod) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else if (currentGroup === 'displayName' || currentGroup === 'propTypes' || currentGroup === 'contextTypes' || currentGroup === 'childContextTypes' || currentGroup === 'mixins' || currentGroup === 'statics' || currentGroup === 'defaultProps' || currentGroup === 'constructor' || currentGroup === 'getDefaultProps' || currentGroup === 'state' || currentGroup === 'getInitialState' || currentGroup === 'getChildContext' || currentGroup === 'getDerivedStateFromProps' || currentGroup === 'componentWillMount' || currentGroup === 'UNSAFE_componentWillMount' || currentGroup === 'componentDidMount' || currentGroup === 'componentWillReceiveProps' || currentGroup === 'UNSAFE_componentWillReceiveProps' || currentGroup === 'shouldComponentUpdate' || currentGroup === 'componentWillUpdate' || currentGroup === 'UNSAFE_componentWillUpdate' || currentGroup === 'getSnapshotBeforeUpdate' || currentGroup === 'componentDidUpdate' || currentGroup === 'componentDidCatch' || currentGroup === 'componentWillUnmount' || currentGroup === 'render') {
            if (currentGroup === method.name) {
              return methodGroupIndexes.push(groupIndex);
            }
          } else {
            // Is the group a regex?
            isRegExp = currentGroup.match(regExpRegExp);
            if (isRegExp) {
              isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
              if (isMatching) {
                return methodGroupIndexes.push(groupIndex);
              }
            } else if (currentGroup === method.name) {
              return methodGroupIndexes.push(groupIndex);
            }
          }
        });
        // No matching pattern, return 'everything-else' index
        if (methodGroupIndexes.length === 0) {
          everythingElseIndex = methodsOrder.indexOf('everything-else');
          if (everythingElseIndex !== -1) {
            methodGroupIndexes.push(everythingElseIndex);
          } else {
            // No matching pattern and no 'everything-else' group
            methodGroupIndexes.push(2e308);
          }
        }
        return methodGroupIndexes;
      };
      getPropertyName = function(node) {
        if (node.kind === 'get') {
          return 'getter functions';
        }
        if (node.kind === 'set') {
          return 'setter functions';
        }
        return astUtil.getPropertyName(node);
      };
      storeError = function(propA, propB) {
        // Initialize the error object if needed
        if (!errors[propA.index]) {
          errors[propA.index] = {
            node: propA.node,
            score: 0,
            closest: {
              distance: 2e308,
              ref: {
                node: null,
                index: 0
              }
            }
          };
        }
        // Increment the prop score
        errors[propA.index].score++;
        // Stop here if we already have pushed another node at this position
        if (!(getPropertyName(errors[propA.index].node) === getPropertyName(propA.node))) {
          return;
        }
        // Stop here if we already have a closer reference
        if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
          return;
        }
        // Update the closest reference
        errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
        errors[propA.index].closest.ref.node = propB.node;
        return errors[propA.index].closest.ref.index = propB.index;
      };
      dedupeErrors = function() {
        var error, i, index, results;
        results = [];
        for (i in errors) {
          if (!hasProp.call(errors, i)) continue;
          error = errors[i];
          ({index} = error.closest.ref);
          if (!errors[index]) {
            continue;
          }
          if (error.score > errors[index].score) {
            results.push(delete errors[index]);
          } else {
            results.push(delete errors[i]);
          }
        }
        return results;
      };
      reportErrors = function() {
        var error, i, indexA, indexB, nodeA, nodeB, results;
        dedupeErrors();
        results = [];
        for (i in errors) {
          if (!hasProp.call(errors, i)) continue;
          error = errors[i];
          nodeA = error.node;
          nodeB = error.closest.ref.node;
          indexA = i;
          indexB = error.closest.ref.index;
          results.push(context.report({
            node: nodeA,
            message: MISPOSITION_MESSAGE,
            data: {
              propA: getPropertyName(nodeA),
              propB: getPropertyName(nodeB),
              position: indexA < indexB ? 'before' : 'after'
            }
          }));
        }
        return results;
      };
      comparePropsOrder = function(propertiesInfos, propA, propB) {
        var classIndexA, classIndexB, j, l, len, len1, refIndexA, refIndexB, refIndexesA, refIndexesB;
        // Get references indexes (the correct position) for given properties
        refIndexesA = getRefPropIndexes(propA);
        refIndexesB = getRefPropIndexes(propB);
        // Get current indexes for given properties
        classIndexA = propertiesInfos.indexOf(propA);
        classIndexB = propertiesInfos.indexOf(propB);
// Loop around the references indexes for the 1st property
        for (j = 0, len = refIndexesA.length; j < len; j++) {
          refIndexA = refIndexesA[j];
          for (l = 0, len1 = refIndexesB.length; l < len1; l++) {
            refIndexB = refIndexesB[l];
            if (refIndexA === refIndexB || (refIndexA < refIndexB && classIndexA < classIndexB) || (refIndexA > refIndexB && classIndexA > classIndexB)) {
              return {
                correct: true,
                indexA: classIndexA,
                indexB: classIndexB
              };
            }
          }
        }
        return {
          // Loop around the properties for the 2nd property (for comparison)
          // Comparing the same properties
          // 1st property is placed before the 2nd one in reference and in current component
          // 1st property is placed after the 2nd one in reference and in current component
          // We did not find any correct match between reference and current component
          correct: false,
          indexA: refIndexA,
          indexB: refIndexB
        };
      };
      checkPropsOrder = function(properties) {
        var i, j, k, len, order, propA, propB, propertiesInfos, results;
        propertiesInfos = properties.map(function(node) {
          return {
            name: getPropertyName(node),
            getter: node.kind === 'get',
            setter: node.kind === 'set',
            static: node.static,
            instanceVariable: !node.static && node.type === 'ClassProperty' && node.value && !astUtil.isFunctionLikeExpression(node.value),
            instanceMethod: !node.static && node.type === 'ClassProperty' && node.value && astUtil.isFunctionLikeExpression(node.value),
            typeAnnotation: !!node.typeAnnotation && node.value === null
          };
        });
// Loop around the properties
        results = [];
        for (i = j = 0, len = propertiesInfos.length; j < len; i = ++j) {
          propA = propertiesInfos[i];
          results.push((function() {
            var l, len1, results1;
// Loop around the properties a second time (for comparison)
            results1 = [];
            for (k = l = 0, len1 = propertiesInfos.length; l < len1; k = ++l) {
              propB = propertiesInfos[k];
              if (i === k) {
                continue;
              }
              // Compare the properties order
              order = comparePropsOrder(propertiesInfos, propA, propB);
              if (order.correct === true) {
                // Continue to next comparison is order is correct
                continue;
              }
              // Store an error if the order is incorrect
              results1.push(storeError({
                node: properties[i],
                index: order.indexA
              }, {
                node: properties[k],
                index: order.indexB
              }));
            }
            return results1;
          })());
        }
        return results;
      };
      return {
        'Program:exit': function() {
          var _, component, properties, ref;
          ref = components.list();
          for (_ in ref) {
            if (!hasProp.call(ref, _)) continue;
            component = ref[_];
            properties = astUtil.getComponentProperties(component.node);
            checkPropsOrder(properties);
          }
          return reportErrors();
        }
      };
    }),
    defaultConfig
  };

}).call(this);
