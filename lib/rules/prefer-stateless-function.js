// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce stateless components to be written as a pure function
   * @author Yannick Croissant
   * @author Alberto Rodríguez
   * @copyright 2015 Alberto Rodríguez. All rights reserved.
   */
  'use strict';
  var Components, astUtil, docsUrl, isDeclarationAssignment, versionUtil,
    hasProp = {}.hasOwnProperty;

  Components = require('../util/react/Components');

  versionUtil = require('eslint-plugin-react/lib/util/version');

  astUtil = require('../util/react/ast');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce stateless components to be written as a pure function',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('prefer-stateless-function')
      },
      schema: [
        {
          type: 'object',
          properties: {
            ignorePureComponents: {
              default: false,
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Check if a given AST node have any other properties the ones available in stateless components
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if the node has at least one other property, false if not.
       */
      /**
       * Checks whether the parameters of a constructor and the arguments of `super()`
       * have the same values or not.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode} ctorParams - The parameters of a constructor to check.
       * @param {ASTNode} superArgs - The arguments of `super()` to check.
       * @returns {boolean} `true` if those have the same values.
       */
      /**
       * Checks whether the constructor body is a redundant super call.
       * @see ESLint no-useless-constructor rule
       * @param {Array} body - constructor body content.
       * @param {Array} ctorParams - The params to check against super call.
       * @returns {boolean} true if the construtor body is redundant
       */
      /**
       * Checks whether a given node is a pattern which doesn't have any side effects.
       * Default parameters and Destructuring parameters can have side effects.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode} node - A pattern node.
       * @returns {boolean} `true` if the node doesn't have any side effects.
       */
      /**
       * Checks whether a given array of expressions is `...arguments` or not.
       * `super(...arguments)` passes all arguments through.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode[]} superArgs - An array of expressions to check.
       * @returns {boolean} `true` if the superArgs is `...arguments`.
       */
      /**
       * Checks whether given 2 nodes are identifiers which have the same name or not.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode} ctorParam - A node to check.
       * @param {ASTNode} superArg - A node to check.
       * @returns {boolean} `true` if the nodes are identifiers which have the same
       *      name.
       */
      /**
       * Checks whether given 2 nodes have the same value or not.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode} ctorParam - A node to check.
       * @param {ASTNode} superArg - A node to check.
       * @returns {boolean} `true` if the nodes have the same value or not.
       */
      /**
       * Checks whether given 2 nodes are a rest/spread pair which has the same values.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode} ctorParam - A node to check.
       * @param {ASTNode} superArg - A node to check.
       * @returns {boolean} `true` if the nodes are a rest/spread pair which has the
       *      same values.
       */
      /**
       * Mark childContextTypes as declared
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark a ClassDeclaration as having used decorators
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark a props or context as used
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark a ref as used
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark return as invalid
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark component as pure as declared
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Mark a setState as used
       * @param {ASTNode} node The AST node being checked.
       */
      var configuration, hasOtherProperties, ignorePureComponents, isPassingThrough, isRedundantSuperCall, isSimple, isSingleSuperCall, isSpreadArguments, isValidIdentifierPair, isValidPair, isValidRestSpreadPair, markChildContextTypesAsDeclared, markDecoratorsAsUsed, markPropsOrContextAsUsed, markRefAsUsed, markReturnAsInvalid, markSCUAsDeclared, markThisAsUsed, sourceCode, visitClass;
      configuration = context.options[0] || {};
      ignorePureComponents = configuration.ignorePureComponents || false;
      sourceCode = context.getSourceCode();
      // --------------------------------------------------------------------------
      // Public
      // --------------------------------------------------------------------------
      /**
       * Checks whether a given array of statements is a single call of `super`.
       * @see ESLint no-useless-constructor rule
       * @param {ASTNode[]} body - An array of statements to check.
       * @returns {boolean} `true` if the body is a single call of `super`.
       */
      isSingleSuperCall = function(body) {
        return body.length === 1 && body[0].type === 'ExpressionStatement' && body[0].expression.type === 'CallExpression' && body[0].expression.callee.type === 'Super';
      };
      isSimple = function(node) {
        var ref;
        return (ref = node.type) === 'Identifier' || ref === 'RestElement';
      };
      isSpreadArguments = function(superArgs) {
        return superArgs.length === 1 && superArgs[0].type === 'SpreadElement' && superArgs[0].argument.type === 'Identifier' && superArgs[0].argument.name === 'arguments';
      };
      isValidIdentifierPair = function(ctorParam, superArg) {
        return ctorParam.type === 'Identifier' && superArg.type === 'Identifier' && ctorParam.name === superArg.name;
      };
      isValidRestSpreadPair = function(ctorParam, superArg) {
        return ctorParam.type === 'RestElement' && superArg.type === 'SpreadElement' && isValidIdentifierPair(ctorParam.argument, superArg.argument);
      };
      isValidPair = function(ctorParam, superArg) {
        return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
      };
      isPassingThrough = function(ctorParams, superArgs) {
        var i;
        if (ctorParams.length !== superArgs.length) {
          return false;
        }
        i = 0;
        while (i < ctorParams.length) {
          if (!isValidPair(ctorParams[i], superArgs[i])) {
            return false;
          }
          ++i;
        }
        return true;
      };
      isRedundantSuperCall = function(body, ctorParams) {
        return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
      };
      hasOtherProperties = function(node) {
        var properties;
        properties = astUtil.getComponentProperties(node);
        return properties.some(function(property) {
          var contextTypes, defaultProps, isDisplayName, isPropTypes, isRender, isUselessConstructor, name;
          name = astUtil.getPropertyName(property);
          isDisplayName = name === 'displayName';
          isPropTypes = name === 'propTypes' || (name === 'props' && property.typeAnnotation);
          contextTypes = name === 'contextTypes';
          defaultProps = name === 'defaultProps';
          isUselessConstructor = property.kind === 'constructor' && isRedundantSuperCall(property.value.body.body, property.value.params);
          isRender = name === 'render';
          return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;
        });
      };
      markSCUAsDeclared = function(node) {
        return components.set(node, {
          hasSCU: true
        });
      };
      markChildContextTypesAsDeclared = function(node) {
        return components.set(node, {
          hasChildContextTypes: true
        });
      };
      markThisAsUsed = function(node) {
        return components.set(node, {
          useThis: true
        });
      };
      markPropsOrContextAsUsed = function(node) {
        return components.set(node, {
          usePropsOrContext: true
        });
      };
      markRefAsUsed = function(node) {
        return components.set(node, {
          useRef: true
        });
      };
      markReturnAsInvalid = function(node) {
        return components.set(node, {
          invalidReturn: true
        });
      };
      markDecoratorsAsUsed = function(node) {
        return components.set(node, {
          useDecorators: true
        });
      };
      visitClass = function(node) {
        var ref;
        if (ignorePureComponents && utils.isPureComponent(node)) {
          markSCUAsDeclared(node);
        }
        if ((ref = node.decorators) != null ? ref.length : void 0) {
          return markDecoratorsAsUsed(node);
        }
      };
      return {
        ClassDeclaration: visitClass,
        ClassExpression: visitClass,
        // Mark `this` destructuring as a usage of `this`
        VariableDeclarator: function(node) {
          var ref, ref1, useThis;
          // Ignore destructuring on other than `this`
          if (!(((ref = node.id) != null ? ref.type : void 0) === 'ObjectPattern' && ((ref1 = node.init) != null ? ref1.type : void 0) === 'ThisExpression')) {
            return;
          }
          // Ignore `props` and `context`
          useThis = node.id.properties.some(function(property) {
            var name;
            name = astUtil.getPropertyName(property);
            return name !== 'props' && name !== 'context';
          });
          if (!useThis) {
            markPropsOrContextAsUsed(node);
            return;
          }
          return markThisAsUsed(node);
        },
        AssignmentExpression: function(node) {
          var left, right, useThis;
          if (!isDeclarationAssignment(node)) {
            return;
          }
          ({left, right} = node);
          // Ignore destructuring on other than `this`
          if (!(left.type === 'ObjectPattern' && right.type === 'ThisExpression')) {
            return;
          }
          // Ignore `props` and `context`
          useThis = left.properties.some(function(property) {
            var name;
            name = astUtil.getPropertyName(property);
            return name !== 'props' && name !== 'context';
          });
          if (!useThis) {
            markPropsOrContextAsUsed(node);
            return;
          }
          return markThisAsUsed(node);
        },
        // Mark `this` usage
        MemberExpression: function(node) {
          var component;
          if (node.object.type !== 'ThisExpression') {
            if (node.property && node.property.name === 'childContextTypes') {
              component = utils.getRelatedComponent(node);
              if (!component) {
                return;
              }
              markChildContextTypesAsDeclared(component.node);
              return;
            }
            return;
          // Ignore calls to `this.props` and `this.context`
          } else if ((node.property.name || node.property.value) === 'props' || (node.property.name || node.property.value) === 'context') {
            markPropsOrContextAsUsed(node);
            return;
          }
          return markThisAsUsed(node);
        },
        // Mark `ref` usage
        JSXAttribute: function(node) {
          var name;
          name = sourceCode.getText(node.name);
          if (name !== 'ref') {
            return;
          }
          return markRefAsUsed(node);
        },
        // Mark `render` that do not return some JSX
        ReturnStatement: function(node) {
          var allowNull, blockNode, isRender, isReturningJSX, isReturningNull, ref, ref1, ref2, scope;
          scope = context.getScope();
          while (scope) {
            blockNode = (ref = scope.block) != null ? ref.parent : void 0;
            if (blockNode && ((ref1 = blockNode.type) === 'MethodDefinition' || ref1 === 'Property')) {
              break;
            }
            scope = scope.upper;
          }
          isRender = (blockNode != null ? blockNode.key : void 0) && blockNode.key.name === 'render';
          allowNull = versionUtil.testReactVersion(context, '15.0.0'); // Stateless components can return null since React 15
          isReturningJSX = utils.isReturningJSX(node, !allowNull);
          isReturningNull = node.argument && ((ref2 = node.argument.value) === null || ref2 === false);
          if (!isRender || (allowNull && (isReturningJSX || isReturningNull)) || (!allowNull && isReturningJSX)) {
            return;
          }
          return markReturnAsInvalid(node);
        },
        'Program:exit': function() {
          var _, component, list, results;
          list = components.list();
          results = [];
          for (_ in list) {
            if (!hasProp.call(list, _)) continue;
            component = list[_];
            if (hasOtherProperties(component.node) || component.useThis || component.useRef || component.invalidReturn || component.hasChildContextTypes || component.useDecorators || (!utils.isES5Component(component.node) && !utils.isES6Component(component.node))) {
              continue;
            }
            if (component.hasSCU && component.usePropsOrContext) {
              continue;
            }
            results.push(context.report({
              node: component.node,
              message: 'Component should be written as a pure function'
            }));
          }
          return results;
        }
      };
    })
  };

}).call(this);
