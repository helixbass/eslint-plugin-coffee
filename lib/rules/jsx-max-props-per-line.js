// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Limit maximum of props on a single line in JSX
   * @author Yannick Croissant
   */
  'use strict';
  var docsUrl;

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Limit maximum of props on a single line in JSX',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-max-props-per-line')
      },
      // fixable: 'code'
      schema: [
        {
          type: 'object',
          properties: {
            maximum: {
              type: 'integer',
              minimum: 1
            },
            when: {
              type: 'string',
              enum: ['always',
        'multiline']
            }
          }
        }
      ]
    },
    create: function(context) {
      var _when, configuration, getPropName, maximum, sourceCode;
      sourceCode = context.getSourceCode();
      configuration = context.options[0] || {};
      maximum = configuration.maximum || 1;
      _when = configuration.when || 'always';
      getPropName = function(propNode) {
        if (propNode.type === 'JSXSpreadAttribute') {
          return sourceCode.getText(propNode.argument);
        }
        return propNode.name.name;
      };
      return {
        // generateFixFunction = (line, max) ->
        //   output = []
        //   front = line[0].range[0]
        //   back = line[line.length - 1].range[1]
        //   i = 0
        //   while i < line.length
        //     nodes = line.slice i, i + max
        //     output.push(
        //       nodes.reduce(
        //         (prev, curr) ->
        //           return sourceCode.getText curr if prev is ''
        //           "#{prev} #{sourceCode.getText curr}"
        //         ''
        //       )
        //     )
        //     i += max
        //   code = output.join '\n'
        //   (fixer) -> fixer.replaceTextRange [front, back], code
        JSXOpeningElement: function(node) {
          var firstProp, linePartitionedProps;
          if (!node.attributes.length) {
            return;
          }
          if (_when === 'multiline' && node.loc.start.line === node.loc.end.line) {
            return;
          }
          firstProp = node.attributes[0];
          linePartitionedProps = [[firstProp]];
          node.attributes.reduce(function(last, decl) {
            if (last.loc.end.line === decl.loc.start.line) {
              linePartitionedProps[linePartitionedProps.length - 1].push(decl);
            } else {
              linePartitionedProps.push([decl]);
            }
            return decl;
          });
          return linePartitionedProps.forEach(function(propsInLine) {
            var name;
            if (propsInLine.length > maximum) {
              name = getPropName(propsInLine[maximum]);
              return context.report({
                node: propsInLine[maximum],
                message: `Prop \`${name}\` must be placed on a new line`
              });
            }
          });
        }
      };
    }
  };

  // fix: generateFixFunction propsInLine, maximum

}).call(this);
