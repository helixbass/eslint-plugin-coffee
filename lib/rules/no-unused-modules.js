// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileOverview Ensures that modules contain exports and/or all
   * modules are consumed within other modules.
   * @author Ren√© Fermann
   */
  /**
   * traverse through all imports and add the respective path to the whereUsed-list
   * of the corresponding export
   */
  /**
   * parse all source files and build up 2 maps containing the existing imports and exports
   */
  /**
   * read all files matching the patterns in src and ignoreExports
   *
   * return all files matching src pattern, which are not matching the ignoreExports pattern
   */
  /**
   * prepare the lists of existing imports and exports - should only be executed once at
   * the start of a new eslint run
   */
  var ASSIGNMENT_EXPRESSION, CLASS_DECLARATION, DEFAULT, EXPORT_ALL_DECLARATION, EXPORT_DEFAULT_DECLARATION, EXPORT_NAMED_DECLARATION, Exports, FUNCTION_DECLARATION, FileEnumerator, IDENTIFIER, IMPORT_DECLARATION, IMPORT_DEFAULT_SPECIFIER, IMPORT_NAMESPACE_SPECIFIER, TYPE_ALIAS, VARIABLE_DECLARATION, determineUsage, dirname, doPreparation, docsUrl, e1, e2, exportList, fileIsInPkg, filesOutsideSrc, getFileExtensions, getSrc, ignoredFiles, importList, includes, isNodeModule, join, lastPrepareKey, listFilesToProcess, newDefaultImportExists, newNamespaceImportExists, originalListFilesToProcess, prepareImportsAndExports, readPkgUp, resolve, resolveFiles, srcFiles, values;

  ({
    default: Exports
  } = require('../eslint-plugin-import-export-map'));

  ({getFileExtensions} = require('eslint-module-utils/ignore'));

  ({
    default: resolve
  } = require('eslint-module-utils/resolve'));

  ({
    default: docsUrl
  } = require('eslint-plugin-import/lib/docsUrl'));

  ({dirname, join} = require('path'));

  readPkgUp = require('read-pkg-up');

  values = require('object.values');

  includes = require('array-includes');

  try {
    // eslint/lib/util/glob-util has been moved to eslint/lib/util/glob-utils with version 5.3
    // and has been moved to eslint/lib/cli-engine/file-enumerator in version 6
    FileEnumerator = require('eslint/lib/cli-engine/file-enumerator').FileEnumerator;
    listFilesToProcess = function(src, extensions) {
      var e;
      e = new FileEnumerator({
        extensions: extensions
      });
      return Array.from(e.iterateFiles(src), function({filePath, ignored}) {
        return {
          ignored,
          filename: filePath
        };
      });
    };
  } catch (error) {
    e1 = error;
    try {
      // Prevent passing invalid options (extensions array) to old versions of the function.
      // https://github.com/eslint/eslint/blob/v5.16.0/lib/util/glob-utils.js#L178-L280
      // https://github.com/eslint/eslint/blob/v5.2.0/lib/util/glob-util.js#L174-L269
      originalListFilesToProcess = require('eslint/lib/util/glob-utils').listFilesToProcess;
      listFilesToProcess = function(src, extensions) {
        return originalListFilesToProcess(src, {
          extensions: extensions
        });
      };
    } catch (error) {
      e2 = error;
      originalListFilesToProcess = require('eslint/lib/util/glob-util').listFilesToProcess;
      listFilesToProcess = function(src, extensions) {
        var patterns;
        patterns = src.reduce(function(carry, pattern) {
          return carry.concat(extensions.map(function(extension) {
            if (/\*\*|\*\./.test(pattern)) {
              return pattern;
            } else {
              return `${pattern}/**/*${extension}`;
            }
          }));
        }, src.slice());
        return originalListFilesToProcess(patterns);
      };
    }
  }

  EXPORT_DEFAULT_DECLARATION = 'ExportDefaultDeclaration';

  EXPORT_NAMED_DECLARATION = 'ExportNamedDeclaration';

  EXPORT_ALL_DECLARATION = 'ExportAllDeclaration';

  IMPORT_DECLARATION = 'ImportDeclaration';

  IMPORT_NAMESPACE_SPECIFIER = 'ImportNamespaceSpecifier';

  IMPORT_DEFAULT_SPECIFIER = 'ImportDefaultSpecifier';

  VARIABLE_DECLARATION = 'VariableDeclaration';

  FUNCTION_DECLARATION = 'FunctionDeclaration';

  CLASS_DECLARATION = 'ClassDeclaration';

  ASSIGNMENT_EXPRESSION = 'AssignmentExpression';

  IDENTIFIER = 'Identifier';

  DEFAULT = 'default';

  TYPE_ALIAS = 'TypeAlias';

  importList = new Map();

  exportList = new Map();

  ignoredFiles = new Set();

  filesOutsideSrc = new Set();

  isNodeModule = function(path) {
    return /\/(node_modules)\//.test(path);
  };

  resolveFiles = function(src, ignoreExports, context) {
    var extensions, ignoredFilesList, srcFileList, srcFiles;
    extensions = Array.from(getFileExtensions(context.settings));
    srcFiles = new Set();
    srcFileList = listFilesToProcess(src, extensions);
    // prepare list of ignored files
    ignoredFilesList = listFilesToProcess(ignoreExports, extensions);
    ignoredFilesList.forEach(function({filename}) {
      return ignoredFiles.add(filename);
    });
    // prepare list of source files, don't consider files from node_modules
    srcFileList.filter(function({filename}) {
      return !isNodeModule(filename);
    }).forEach(function({filename}) {
      return srcFiles.add(filename);
    });
    return srcFiles;
  };

  prepareImportsAndExports = function(srcFiles, context) {
    var exportAll;
    exportAll = new Map();
    srcFiles.forEach(function(file) {
      var currentExportAll, currentExports, dependencies, exports, imports, localImportList, namespace, reexports;
      exports = new Map();
      imports = new Map();
      currentExports = Exports.get(file, context);
      if (currentExports) {
        ({
          dependencies,
          reexports,
          imports: localImportList,
          namespace
        } = currentExports);
        // dependencies === export * from
        currentExportAll = new Set();
        dependencies.forEach(function(getDependency) {
          var dependency;
          dependency = getDependency();
          if (dependency === null) {
            return;
          }
          return currentExportAll.add(dependency.path);
        });
        exportAll.set(file, currentExportAll);
        reexports.forEach(function(value, key) {
          var currentValue, localImport, reexport;
          if (key === DEFAULT) {
            exports.set(IMPORT_DEFAULT_SPECIFIER, {
              whereUsed: new Set()
            });
          } else {
            exports.set(key, {
              whereUsed: new Set()
            });
          }
          reexport = value.getImport();
          if (!reexport) {
            return;
          }
          localImport = imports.get(reexport.path);
          if (value.local === DEFAULT) {
            currentValue = IMPORT_DEFAULT_SPECIFIER;
          } else {
            currentValue = value.local;
          }
          if (typeof localImport !== 'undefined') {
            localImport = new Set([...localImport, currentValue]);
          } else {
            localImport = new Set([currentValue]);
          }
          return imports.set(reexport.path, localImport);
        });
        localImportList.forEach(function(value, key) {
          if (isNodeModule(key)) {
            return;
          }
          return imports.set(key, value.importedSpecifiers);
        });
        importList.set(file, imports);
        // build up export list only, if file is not ignored
        if (ignoredFiles.has(file)) {
          return;
        }
        namespace.forEach(function(value, key) {
          if (key === DEFAULT) {
            return exports.set(IMPORT_DEFAULT_SPECIFIER, {
              whereUsed: new Set()
            });
          } else {
            return exports.set(key, {
              whereUsed: new Set()
            });
          }
        });
      }
      exports.set(EXPORT_ALL_DECLARATION, {
        whereUsed: new Set()
      });
      exports.set(IMPORT_NAMESPACE_SPECIFIER, {
        whereUsed: new Set()
      });
      return exportList.set(file, exports);
    });
    return exportAll.forEach(function(value, key) {
      return value.forEach(function(val) {
        var currentExport, currentExports;
        currentExports = exportList.get(val);
        currentExport = currentExports.get(EXPORT_ALL_DECLARATION);
        return currentExport.whereUsed.add(key);
      });
    });
  };

  determineUsage = function() {
    return importList.forEach(function(listValue, listKey) {
      return listValue.forEach(function(value, key) {
        var exports;
        exports = exportList.get(key);
        if (typeof exports !== 'undefined') {
          return value.forEach(function(currentImport) {
            var exportStatement, specifier, whereUsed;
            if (currentImport === IMPORT_NAMESPACE_SPECIFIER) {
              specifier = IMPORT_NAMESPACE_SPECIFIER;
            } else if (currentImport === IMPORT_DEFAULT_SPECIFIER) {
              specifier = IMPORT_DEFAULT_SPECIFIER;
            } else {
              specifier = currentImport;
            }
            if (typeof specifier !== 'undefined') {
              exportStatement = exports.get(specifier);
              if (typeof exportStatement !== 'undefined') {
                ({whereUsed} = exportStatement);
                whereUsed.add(listKey);
                return exports.set(specifier, {whereUsed});
              }
            }
          });
        }
      });
    });
  };

  getSrc = function(src) {
    if (src) {
      return src;
    }
    return [process.cwd()];
  };

  srcFiles = null;

  lastPrepareKey = null;

  doPreparation = function(src, ignoreExports, context) {
    var prepareKey;
    prepareKey = JSON.stringify({
      src: (src || []).sort(),
      ignoreExports: (ignoreExports || []).sort(),
      extensions: Array.from(getFileExtensions(context.settings)).sort()
    });
    if (prepareKey === lastPrepareKey) {
      return;
    }
    importList.clear();
    exportList.clear();
    ignoredFiles.clear();
    filesOutsideSrc.clear();
    srcFiles = resolveFiles(getSrc(src), ignoreExports, context);
    prepareImportsAndExports(srcFiles, context);
    determineUsage();
    return lastPrepareKey = prepareKey;
  };

  newNamespaceImportExists = function(specifiers) {
    return specifiers.some(function({type}) {
      return type === IMPORT_NAMESPACE_SPECIFIER;
    });
  };

  newDefaultImportExists = function(specifiers) {
    return specifiers.some(function({type}) {
      return type === IMPORT_DEFAULT_SPECIFIER;
    });
  };

  fileIsInPkg = function(file) {
    var basePath, checkPkgField, checkPkgFieldObject, checkPkgFieldString, path, pkg;
    ({path, pkg} = readPkgUp.sync({
      cwd: file,
      normalize: false
    }));
    basePath = dirname(path);
    checkPkgFieldString = function(pkgField) {
      if (join(basePath, pkgField) === file) {
        return true;
      }
    };
    checkPkgFieldObject = function(pkgField) {
      var pkgFieldFiles;
      pkgFieldFiles = values(pkgField).map(function(value) {
        return join(basePath, value);
      });
      if (includes(pkgFieldFiles, file)) {
        return true;
      }
    };
    checkPkgField = function(pkgField) {
      if (typeof pkgField === 'string') {
        return checkPkgFieldString(pkgField);
      }
      if (typeof pkgField === 'object') {
        return checkPkgFieldObject(pkgField);
      }
    };
    if (pkg.private === true) {
      return false;
    }
    if (pkg.bin) {
      if (checkPkgField(pkg.bin)) {
        return true;
      }
    }
    if (pkg.browser) {
      if (checkPkgField(pkg.browser)) {
        return true;
      }
    }
    if (pkg.main) {
      if (checkPkgFieldString(pkg.main)) {
        return true;
      }
    }
    return false;
  };

  module.exports = {
    meta: {
      docs: {
        url: docsUrl('no-unused-modules')
      },
      schema: [
        {
          properties: {
            src: {
              description: 'files/paths to be analyzed (only for unused exports)',
              type: 'array',
              minItems: 1,
              items: {
                type: 'string',
                minLength: 1
              }
            },
            ignoreExports: {
              description: 'files/paths for which unused exports will not be reported (e.g module entry points)',
              type: 'array',
              minItems: 1,
              items: {
                type: 'string',
                minLength: 1
              }
            },
            missingExports: {
              description: 'report modules without any exports',
              type: 'boolean'
            },
            unusedExports: {
              description: 'report exports without any usage',
              type: 'boolean'
            }
          },
          not: {
            properties: {
              unusedExports: {
                enum: [false]
              },
              missingExports: {
                enum: [false]
              }
            }
          },
          anyOf: [
            {
              not: {
                properties: {
                  unusedExports: {
                    enum: [true]
                  }
                }
              },
              required: ['missingExports']
            },
            {
              not: {
                properties: {
                  missingExports: {
                    enum: [true]
                  }
                }
              },
              required: ['unusedExports']
            },
            {
              properties: {
                unusedExports: {
                  enum: [true]
                }
              },
              required: ['unusedExports']
            },
            {
              properties: {
                missingExports: {
                  enum: [true]
                }
              },
              required: ['missingExports']
            }
          ]
        }
      ]
    },
    create: function(context) {
      /**
       * only useful for tools like vscode-eslint
       *
       * update lists of existing exports during runtime
       */
      /**
       * only useful for tools like vscode-eslint
       *
       * update lists of existing imports during runtime
       */
      var checkExportPresence, checkUsage, file, ignoreExports, missingExports, src, unusedExports, updateExportUsage, updateImportUsage;
      ({src, ignoreExports = [], missingExports, unusedExports} = context.options[0] || {});
      if (unusedExports) {
        doPreparation(src, ignoreExports, context);
      }
      file = context.getFilename();
      checkExportPresence = function(node) {
        var exportAll, exportCount, namespaceImports;
        if (!missingExports) {
          return;
        }
        if (ignoredFiles.has(file)) {
          return;
        }
        exportCount = exportList.get(file);
        exportAll = exportCount.get(EXPORT_ALL_DECLARATION);
        namespaceImports = exportCount.get(IMPORT_NAMESPACE_SPECIFIER);
        exportCount.delete(EXPORT_ALL_DECLARATION);
        exportCount.delete(IMPORT_NAMESPACE_SPECIFIER);
        if (exportCount.size < 1) {
          // node.body[0] === 'undefined' only happens, if everything is commented out in the file
          // being linted
          context.report(node.body[0] ? node.body[0] : node, 'No exports found');
        }
        exportCount.set(EXPORT_ALL_DECLARATION, exportAll);
        return exportCount.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);
      };
      checkUsage = function(node, exportedValue) {
        var exportAll, exportStatement, exports, namespaceImports, value;
        if (!unusedExports) {
          return;
        }
        if (ignoredFiles.has(file)) {
          return;
        }
        if (fileIsInPkg(file)) {
          return;
        }
        if (filesOutsideSrc.has(file)) {
          return;
        }
        // make sure file to be linted is included in source files
        if (!srcFiles.has(file)) {
          srcFiles = resolveFiles(getSrc(src), ignoreExports, context);
          if (!srcFiles.has(file)) {
            filesOutsideSrc.add(file);
            return;
          }
        }
        exports = exportList.get(file);
        // special case: export * from
        exportAll = exports.get(EXPORT_ALL_DECLARATION);
        if (typeof exportAll !== 'undefined' && exportedValue !== IMPORT_DEFAULT_SPECIFIER) {
          if (exportAll.whereUsed.size > 0) {
            return;
          }
        }
        // special case: namespace import
        namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);
        if (typeof namespaceImports !== 'undefined') {
          if (namespaceImports.whereUsed.size > 0) {
            return;
          }
        }
        exportStatement = exports.get(exportedValue);
        value = exportedValue === IMPORT_DEFAULT_SPECIFIER ? DEFAULT : exportedValue;
        if (typeof exportStatement !== 'undefined') {
          if (exportStatement.whereUsed.size < 1) {
            return context.report(node, `exported declaration '${value}' not used within other modules`);
          }
        } else {
          return context.report(node, `exported declaration '${value}' not used within other modules`);
        }
      };
      updateExportUsage = function(node) {
        var exportAll, exports, namespaceImports, newExportIdentifiers, newExports;
        if (ignoredFiles.has(file)) {
          return;
        }
        exports = exportList.get(file);
        // new module has been created during runtime
        // include it in further processing
        if (typeof exports === 'undefined') {
          exports = new Map();
        }
        newExports = new Map();
        newExportIdentifiers = new Set();
        node.body.forEach(function({type, declaration, specifiers}) {
          var ref;
          if (type === EXPORT_DEFAULT_DECLARATION) {
            newExportIdentifiers.add(IMPORT_DEFAULT_SPECIFIER);
          }
          if (type === EXPORT_NAMED_DECLARATION) {
            if (specifiers.length > 0) {
              specifiers.forEach(function(specifier) {
                if (specifier.exported) {
                  return newExportIdentifiers.add(specifier.exported.name);
                }
              });
            }
            if (declaration) {
              if ((ref = declaration.type) === FUNCTION_DECLARATION || ref === CLASS_DECLARATION || ref === TYPE_ALIAS) {
                newExportIdentifiers.add(declaration.id.name);
              }
              if (declaration.type === VARIABLE_DECLARATION) {
                declaration.declarations.forEach(function({id}) {
                  return newExportIdentifiers.add(id.name);
                });
              }
              if (declaration.type === ASSIGNMENT_EXPRESSION && declaration.left.type === IDENTIFIER) {
                return newExportIdentifiers.add(declaration.left.name);
              }
            }
          }
        });
        // old exports exist within list of new exports identifiers: add to map of new exports
        exports.forEach(function(value, key) {
          if (newExportIdentifiers.has(key)) {
            return newExports.set(key, value);
          }
        });
        // new export identifiers added: add to map of new exports
        newExportIdentifiers.forEach(function(key) {
          if (!exports.has(key)) {
            return newExports.set(key, {
              whereUsed: new Set()
            });
          }
        });
        // preserve information about namespace imports
        exportAll = exports.get(EXPORT_ALL_DECLARATION);
        namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);
        if (typeof namespaceImports === 'undefined') {
          namespaceImports = {
            whereUsed: new Set()
          };
        }
        newExports.set(EXPORT_ALL_DECLARATION, exportAll);
        newExports.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);
        return exportList.set(file, newExports);
      };
      updateImportUsage = function(node) {
        var newDefaultImports, newExportAll, newImports, newNamespaceImports, oldDefaultImports, oldExportAll, oldImportPaths, oldImports, oldNamespaceImports;
        if (!unusedExports) {
          return;
        }
        oldImportPaths = importList.get(file);
        if (typeof oldImportPaths === 'undefined') {
          oldImportPaths = new Map();
        }
        oldNamespaceImports = new Set();
        newNamespaceImports = new Set();
        oldExportAll = new Set();
        newExportAll = new Set();
        oldDefaultImports = new Set();
        newDefaultImports = new Set();
        oldImports = new Map();
        newImports = new Map();
        oldImportPaths.forEach(function(value, key) {
          if (value.has(EXPORT_ALL_DECLARATION)) {
            oldExportAll.add(key);
          }
          if (value.has(IMPORT_NAMESPACE_SPECIFIER)) {
            oldNamespaceImports.add(key);
          }
          if (value.has(IMPORT_DEFAULT_SPECIFIER)) {
            oldDefaultImports.add(key);
          }
          return value.forEach(function(val) {
            if (val !== IMPORT_NAMESPACE_SPECIFIER && val !== IMPORT_DEFAULT_SPECIFIER) {
              return oldImports.set(val, key);
            }
          });
        });
        node.body.forEach(function(astNode) {
          var resolvedPath;
          // support for export { value } from 'module'
          if (astNode.type === EXPORT_NAMED_DECLARATION) {
            if (astNode.source) {
              resolvedPath = resolve(astNode.source.raw.replace(/('|")/g, ''), context);
              astNode.specifiers.forEach(function(specifier) {
                var name;
                if (specifier.exported.name === DEFAULT) {
                  name = IMPORT_DEFAULT_SPECIFIER;
                } else {
                  name = specifier.local.name;
                }
                return newImports.set(name, resolvedPath);
              });
            }
          }
          if (astNode.type === EXPORT_ALL_DECLARATION) {
            resolvedPath = resolve(astNode.source.raw.replace(/('|")/g, ''), context);
            newExportAll.add(resolvedPath);
          }
          if (astNode.type === IMPORT_DECLARATION) {
            resolvedPath = resolve(astNode.source.raw.replace(/('|")/g, ''), context);
            if (!resolvedPath) {
              return;
            }
            if (isNodeModule(resolvedPath)) {
              return;
            }
            if (newNamespaceImportExists(astNode.specifiers)) {
              newNamespaceImports.add(resolvedPath);
            }
            if (newDefaultImportExists(astNode.specifiers)) {
              newDefaultImports.add(resolvedPath);
            }
            return astNode.specifiers.forEach(function(specifier) {
              var ref;
              if ((ref = specifier.type) === IMPORT_DEFAULT_SPECIFIER || ref === IMPORT_NAMESPACE_SPECIFIER) {
                return;
              }
              return newImports.set(specifier.imported.name, resolvedPath);
            });
          }
        });
        newExportAll.forEach(function(value) {
          var currentExport, exports, imports, whereUsed;
          if (!oldExportAll.has(value)) {
            imports = oldImportPaths.get(value);
            if (typeof imports === 'undefined') {
              imports = new Set();
            }
            imports.add(EXPORT_ALL_DECLARATION);
            oldImportPaths.set(value, imports);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(EXPORT_ALL_DECLARATION);
            } else {
              exports = new Map();
              exportList.set(value, exports);
            }
            if (typeof currentExport !== 'undefined') {
              return currentExport.whereUsed.add(file);
            } else {
              whereUsed = new Set();
              whereUsed.add(file);
              return exports.set(EXPORT_ALL_DECLARATION, {whereUsed});
            }
          }
        });
        oldExportAll.forEach(function(value) {
          var currentExport, exports, imports;
          if (!newExportAll.has(value)) {
            imports = oldImportPaths.get(value);
            imports.delete(EXPORT_ALL_DECLARATION);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(EXPORT_ALL_DECLARATION);
              if (typeof currentExport !== 'undefined') {
                return currentExport.whereUsed.delete(file);
              }
            }
          }
        });
        newDefaultImports.forEach(function(value) {
          var currentExport, exports, imports, whereUsed;
          if (!oldDefaultImports.has(value)) {
            imports = oldImportPaths.get(value);
            if (typeof imports === 'undefined') {
              imports = new Set();
            }
            imports.add(IMPORT_DEFAULT_SPECIFIER);
            oldImportPaths.set(value, imports);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);
            } else {
              exports = new Map();
              exportList.set(value, exports);
            }
            if (typeof currentExport !== 'undefined') {
              return currentExport.whereUsed.add(file);
            } else {
              whereUsed = new Set();
              whereUsed.add(file);
              return exports.set(IMPORT_DEFAULT_SPECIFIER, {whereUsed});
            }
          }
        });
        oldDefaultImports.forEach(function(value) {
          var currentExport, exports, imports;
          if (!newDefaultImports.has(value)) {
            imports = oldImportPaths.get(value);
            imports.delete(IMPORT_DEFAULT_SPECIFIER);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);
              if (typeof currentExport !== 'undefined') {
                return currentExport.whereUsed.delete(file);
              }
            }
          }
        });
        newNamespaceImports.forEach(function(value) {
          var currentExport, exports, imports, whereUsed;
          if (!oldNamespaceImports.has(value)) {
            imports = oldImportPaths.get(value);
            if (typeof imports === 'undefined') {
              imports = new Set();
            }
            imports.add(IMPORT_NAMESPACE_SPECIFIER);
            oldImportPaths.set(value, imports);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);
            } else {
              exports = new Map();
              exportList.set(value, exports);
            }
            if (typeof currentExport !== 'undefined') {
              return currentExport.whereUsed.add(file);
            } else {
              whereUsed = new Set();
              whereUsed.add(file);
              return exports.set(IMPORT_NAMESPACE_SPECIFIER, {whereUsed});
            }
          }
        });
        oldNamespaceImports.forEach(function(value) {
          var currentExport, exports, imports;
          if (!newNamespaceImports.has(value)) {
            imports = oldImportPaths.get(value);
            imports.delete(IMPORT_NAMESPACE_SPECIFIER);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);
              if (typeof currentExport !== 'undefined') {
                return currentExport.whereUsed.delete(file);
              }
            }
          }
        });
        newImports.forEach(function(value, key) {
          var currentExport, exports, imports, whereUsed;
          if (!oldImports.has(key)) {
            imports = oldImportPaths.get(value);
            if (typeof imports === 'undefined') {
              imports = new Set();
            }
            imports.add(key);
            oldImportPaths.set(value, imports);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(key);
            } else {
              exports = new Map();
              exportList.set(value, exports);
            }
            if (typeof currentExport !== 'undefined') {
              return currentExport.whereUsed.add(file);
            } else {
              whereUsed = new Set();
              whereUsed.add(file);
              return exports.set(key, {whereUsed});
            }
          }
        });
        return oldImports.forEach(function(value, key) {
          var currentExport, exports, imports;
          if (!newImports.has(key)) {
            imports = oldImportPaths.get(value);
            imports.delete(key);
            exports = exportList.get(value);
            if (typeof exports !== 'undefined') {
              currentExport = exports.get(key);
              if (typeof currentExport !== 'undefined') {
                return currentExport.whereUsed.delete(file);
              }
            }
          }
        });
      };
      return {
        'Program:exit': function(node) {
          updateExportUsage(node);
          updateImportUsage(node);
          return checkExportPresence(node);
        },
        ExportDefaultDeclaration: function(node) {
          return checkUsage(node, IMPORT_DEFAULT_SPECIFIER);
        },
        ExportNamedDeclaration: function(node) {
          var ref;
          node.specifiers.forEach(function(specifier) {
            return checkUsage(node, specifier.exported.name);
          });
          if (node.declaration) {
            if ((ref = node.declaration.type) === FUNCTION_DECLARATION || ref === CLASS_DECLARATION || ref === TYPE_ALIAS) {
              checkUsage(node, node.declaration.id.name);
            }
            if (node.declaration.type === VARIABLE_DECLARATION) {
              node.declaration.declarations.forEach(function(declaration) {
                return checkUsage(node, declaration.id.name);
              });
            }
            if (node.declaration.type === ASSIGNMENT_EXPRESSION && node.declaration.left.type === IDENTIFIER) {
              return checkUsage(node, node.declaration.left.name);
            }
          }
        }
      };
    }
  };

}).call(this);
