// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag on declaring variables already declared in the outer scope
   * @author Ilya Volodin
   */
  'use strict';
  var astUtils,
    indexOf = [].indexOf;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow variable declarations from shadowing variables declared in the outer scope',
        category: 'Variables',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-shadow'
      },
      schema: [
        {
          type: 'object',
          properties: {
            builtinGlobals: {
              type: 'boolean'
            },
            hoist: {
              enum: ['all',
        'functions',
        'never']
            },
            allow: {
              type: 'array',
              items: {
                type: 'string'
              }
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks the current context for shadowed variables.
       * @param {Scope} scope - Fixme
       * @returns {void}
       */
      /**
       * Get a range of a variable's identifier node.
       * @param {Object} variable The variable to get.
       * @returns {Array|undefined} The range of the variable's identifier node.
       */
      /**
       * Check if variable name is allowed.
       *
       * @param  {ASTNode} variable The variable to check.
       * @returns {boolean} Whether or not the variable name is allowed.
       */
      /**
       * Checks if a variable of the class name in the class scope of ClassDeclaration.
       *
       * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
       * So we should ignore the variable in the class scope.
       *
       * @param {Object} variable The variable to check.
       * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.
       */
      /**
       * Checks if a variable is in TDZ of scopeVar.
       * @param {Object} variable The variable to check.
       * @param {Object} scopeVar The variable of TDZ.
       * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.
       */
      /**
       * Checks if a variable is inside the initializer of scopeVar.
       *
       * To avoid reporting at declarations such as `var a = function a() {};`.
       * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
       *
       * @param {Object} variable The variable to check.
       * @param {Object} scopeVar The scope variable to look for.
       * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.
       */
      var checkForShadows, getNameRange, isAllowed, isDoIifeParam, isDuplicatedClassNameVariable, isInTdz, isOnInitializer, options, ref, ref1, ref2;
      options = {
        builtinGlobals: Boolean((ref = context.options[0]) != null ? ref.builtinGlobals : void 0),
        hoist: ((ref1 = context.options[0]) != null ? ref1.hoist : void 0) || 'functions',
        allow: ((ref2 = context.options[0]) != null ? ref2.allow : void 0) || []
      };
      isAllowed = function(variable) {
        return options.allow.indexOf(variable.name) !== -1;
      };
      isDoIifeParam = function(variable) {
        var identifier, ref3;
        identifier = (ref3 = variable.identifiers) != null ? ref3[0] : void 0;
        return (identifier != null ? identifier.type : void 0) === 'Identifier' && identifier.parent.type === 'FunctionExpression' && indexOf.call(identifier.parent.params, identifier) >= 0 && identifier.parent.parent.type === 'UnaryExpression' && identifier.parent.parent.operator === 'do';
      };
      isDuplicatedClassNameVariable = function(variable) {
        var block, ref3, ref4;
        ({block} = variable.scope);
        if (((ref3 = block.type) === 'ClassDeclaration' || ref3 === 'ClassExpression') && block.id === variable.identifiers[0]) {
          return true;
        }
        if (((ref4 = block.id) != null ? ref4.type : void 0) === 'Identifier' && block.parent.type === 'AssignmentExpression' && block.parent.left.type === 'Identifier' && block.id.name === block.parent.left.name) {
          return true;
        }
        return false;
      };
      isOnInitializer = function(variable, scopeVar) {
        var inner, innerDef, innerScope, outer, outerDef, outerScope;
        outerScope = scopeVar.scope;
        outerDef = scopeVar.defs[0];
        outer = (outerDef != null ? outerDef.parent : void 0) && outerDef.parent.range;
        innerScope = variable.scope;
        innerDef = variable.defs[0];
        inner = innerDef != null ? innerDef.name.range : void 0;
        return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && ((innerDef.type === 'FunctionName' && innerDef.node.type === 'FunctionExpression') || innerDef.node.type === 'ClassExpression') && outerScope === innerScope.upper;
      };
      getNameRange = function(variable) {
        var def;
        def = variable.defs[0];
        return def != null ? def.name.range : void 0;
      };
      isInTdz = function(variable, scopeVar) {
        var inner, outer, outerDef;
        outerDef = scopeVar.defs[0];
        inner = getNameRange(variable);
        outer = getNameRange(scopeVar);
        // Excepts FunctionDeclaration if is {"hoist":"function"}.
        return inner && outer && inner[1] < outer[0] && !(options.hoist === 'functions' && outerDef && (outerDef.node.type === 'FunctionDeclaration' || (outerDef.node.parent.type === 'AssignmentExpression' && outerDef.node.parent.right.type === 'FunctionExpression')));
      };
      checkForShadows = function(scope) {
        var i, len, results, shadowed, variable, variables;
        ({variables} = scope);
        results = [];
        for (i = 0, len = variables.length; i < len; i++) {
          variable = variables[i];
          if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isDoIifeParam(variable) || isAllowed(variable)) {
            // Skips "arguments" or variables of a class name in the class scope of ClassDeclaration.
            continue;
          }
          // Gets shadowed variable.
          shadowed = astUtils.getVariableByName(scope.upper, variable.name);
          if (shadowed && (shadowed.identifiers.length > 0 || (options.builtinGlobals && 'writeable' in shadowed)) && !isOnInitializer(variable, shadowed) && !(options.hoist !== 'all' && isInTdz(variable, shadowed))) {
            results.push(context.report({
              node: variable.identifiers[0],
              message: "'{{name}}' is already declared in the upper scope.",
              data: variable
            }));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      return {
        'Program:exit': function() {
          var globalScope, results, scope, stack;
          globalScope = context.getScope();
          stack = globalScope.childScopes.slice();
          results = [];
          while (stack.length) {
            scope = stack.pop();
            stack.push(...scope.childScopes);
            results.push(checkForShadows(scope));
          }
          return results;
        }
      };
    }
  };

}).call(this);
