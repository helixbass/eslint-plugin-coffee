// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A rule to set the maximum depth block can be nested in a function.
   * @author Ian Christian Myers
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce a maximum depth that blocks can be nested',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/max-depth'
      },
      schema: [
        {
          oneOf: [
            {
              type: 'integer',
              minimum: 0
            },
            {
              type: 'object',
              properties: {
                maximum: {
                  type: 'integer',
                  minimum: 0
                },
                max: {
                  type: 'integer',
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ]
    },
    create: function(context) {
      /**
       * When parsing is done then pop out the reference
       * @returns {void}
       * @private
       */
      /**
       * Pop the saved block
       * @returns {void}
       * @private
       */
      /**
       * Save the block and Evaluate the node
       * @param {ASTNode} node node to evaluate
       * @returns {void}
       * @private
       */
      /**
       * When parsing a new function, store it in our function stack
       * @returns {void}
       * @private
       */
      var endFunction, functionStack, maxDepth, option, popBlock, pushBlock, startFunction;
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      functionStack = [];
      option = context.options[0];
      maxDepth = 4;
      if (typeof option === 'object' && Object.prototype.hasOwnProperty.call(option, 'maximum') && typeof option.maximum === 'number') {
        maxDepth = option.maximum;
      }
      if (typeof option === 'object' && Object.prototype.hasOwnProperty.call(option, 'max') && typeof option.max === 'number') {
        maxDepth = option.max;
      }
      if (typeof option === 'number') {
        maxDepth = option;
      }
      startFunction = function() {
        return functionStack.push(0);
      };
      endFunction = function() {
        return functionStack.pop();
      };
      pushBlock = function(node) {
        var len;
        len = ++functionStack[functionStack.length - 1];
        if (len > maxDepth) {
          return context.report({
            node,
            message: 'Blocks are nested too deeply ({{depth}}).',
            data: {
              depth: len
            }
          });
        }
      };
      popBlock = function() {
        return functionStack[functionStack.length - 1]--;
      };
      return {
        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------
        Program: startFunction,
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        IfStatement: function(node) {
          if (node.parent.type !== 'IfStatement') {
            return pushBlock(node);
          }
        },
        SwitchStatement: pushBlock,
        TryStatement: pushBlock,
        DoWhileStatement: pushBlock,
        WhileStatement: pushBlock,
        WithStatement: pushBlock,
        ForStatement: pushBlock,
        ForInStatement: pushBlock,
        ForOfStatement: pushBlock,
        For: pushBlock,
        'IfStatement:exit': popBlock,
        'SwitchStatement:exit': popBlock,
        'TryStatement:exit': popBlock,
        'DoWhileStatement:exit': popBlock,
        'WhileStatement:exit': popBlock,
        'WithStatement:exit': popBlock,
        'ForStatement:exit': popBlock,
        'ForInStatement:exit': popBlock,
        'ForOfStatement:exit': popBlock,
        'For:exit': popBlock,
        'FunctionDeclaration:exit': endFunction,
        'FunctionExpression:exit': endFunction,
        'ArrowFunctionExpression:exit': endFunction,
        'Program:exit': endFunction
      };
    }
  };

}).call(this);
