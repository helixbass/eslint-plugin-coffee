// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Source code for spaced-comments rule
   * @author Gyandeep Singh
   */
  'use strict';
  /**
   * Creates RegExp object for `always` mode.
   * Generated pattern for beginning of comment:
   *
   * 1. First, a marker or nothing.
   * 2. Next, a space or an exception pattern sequence.
   *
   * @param {string[]} markers - A marker list.
   * @param {string[]} exceptions - An exception pattern list.
   * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.
   */
  /**
   * Creates string pattern for exceptions.
   * Generated pattern:
   *
   * 1. A space or an exception pattern sequence.
   *
   * @param {string[]} exceptions - An exception pattern list.
   * @returns {string} A regular expression string for exceptions.
   */
  /**
   * Creates RegExp object for `never` mode.
   * Generated pattern for beginning of comment:
   *
   * 1. First, a marker or nothing (captured).
   * 2. Next, a space or a tab.
   *
   * @param {string[]} markers - A marker list.
   * @returns {RegExp} A RegExp object for `never` mode.
   */
  /**
   * Escapes the control characters of a given string.
   * And adds a repeat flag.
   * @param {string} s - A string to escape.
   * @returns {string} An escaped string.
   */
  /**
   * Parses `markers` option.
   * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
   * @param {string[]} [markers] - A marker list.
   * @returns {string[]} A marker list.
   */
  var astUtils, createAlwaysStylePattern, createExceptionsPattern, createNeverStylePattern, escape, escapeAndRepeat, lodash, parseMarkersOption;

  lodash = require('lodash');

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Escapes the control characters of a given string.
   * @param {string} s - A string to escape.
   * @returns {string} An escaped string.
   */
  escape = function(s) {
    return `(?:${lodash.escapeRegExp(s)})`;
  };

  escapeAndRepeat = function(s) {
    return `${escape(s)}+`;
  };

  parseMarkersOption = function(markers) {
    if (markers.indexOf('*') === -1) {
      // `*` is a marker for JSDoc comments.
      return markers.concat('*');
    }
    return markers;
  };

  createExceptionsPattern = function(exceptions) {
    var pattern;
    pattern = '';
    /*
     * A space or an exception pattern sequence.
     * []                 ==> "\s"
     * ["-"]              ==> "(?:\s|\-+$)"
     * ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
     * ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
     */
    if (exceptions.length === 0) {
      // a space.
      pattern += '\\s';
    } else {
      // a space or...
      pattern += '(?:\\s|';
      if (exceptions.length === 1) {
        // a sequence of the exception pattern.
        pattern += escapeAndRepeat(exceptions[0]);
      } else {
        // a sequence of one of the exception patterns.
        pattern += '(?:';
        pattern += exceptions.map(escapeAndRepeat).join('|');
        pattern += ')';
      }
      pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join('')}]))`;
    }
    return pattern;
  };

  createAlwaysStylePattern = function(markers, exceptions) {
    var pattern;
    pattern = '^';
    /*
     * A marker or nothing.
     * ["*"]            ==> "\*?"
     * ["*", "!"]       ==> "(?:\*|!)?"
     * ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
     */
    if (markers.length === 1) {
      // the marker.
      pattern += escape(markers[0]);
    } else {
      // one of markers.
      pattern += '(?:';
      pattern += markers.map(escape).join('|');
      pattern += ')';
    }
    pattern += '?'; // or nothing.
    pattern += createExceptionsPattern(exceptions);
    return new RegExp(pattern);
  };

  createNeverStylePattern = function(markers) {
    var pattern;
    pattern = `^(${markers.map(escape).join('|')})?[ \t]+`;
    return new RegExp(pattern);
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing after the `//` or `/*` in a comment',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/spaced-comment'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['always',
        'never']
        },
        {
          type: 'object',
          properties: {
            exceptions: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            markers: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            line: {
              type: 'object',
              properties: {
                exceptions: {
                  type: 'array',
                  items: {
                    type: 'string'
                  }
                },
                markers: {
                  type: 'array',
                  items: {
                    type: 'string'
                  }
                }
              },
              additionalProperties: false
            },
            block: {
              type: 'object',
              properties: {
                exceptions: {
                  type: 'array',
                  items: {
                    type: 'string'
                  }
                },
                markers: {
                  type: 'array',
                  items: {
                    type: 'string'
                  }
                },
                balanced: {
                  type: 'boolean'
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Reports a given comment if it's invalid.
       * @param {ASTNode} node - a comment node to check.
       * @returns {void}
       */
      /*
       * Parse the second options.
       * If markers don't include `"*"`, it's added automatically for JSDoc
       * comments.
       */
      /**
       * Reports a beginning spacing error with an appropriate message.
       * @param {ASTNode} node - A comment node to check.
       * @param {string} message - An error message to report.
       * @param {Array} match - An array of match results for markers.
       * @param {string} refChar - Character used for reference in the error message.
       * @returns {void}
       */
      /**
       * Reports an ending spacing error with an appropriate message.
       * @param {ASTNode} node - A comment node to check.
       * @param {string} message - An error message to report.
       * @param {string} match - An array of the matched whitespace characters.
       * @returns {void}
       */
      var balanced, checkCommentForSpace, config, ref, reportBegin, reportEnd, requireSpace, sourceCode, styleRules;
      sourceCode = context.getSourceCode();
      // Unless the first option is never, require a space
      requireSpace = context.options[0] !== 'never';
      config = context.options[1] || {};
      balanced = (ref = config.block) != null ? ref.balanced : void 0;
      styleRules = ['block', 'line'].reduce(function(rule, type) {
        var endNeverPattern, exceptions, markers, ref1, ref2;
        markers = parseMarkersOption(((ref1 = config[type]) != null ? ref1.markers : void 0) || config.markers || []);
        exceptions = ((ref2 = config[type]) != null ? ref2.exceptions : void 0) || config.exceptions || [];
        endNeverPattern = '[ \t]+$';
        // Create RegExp object for valid patterns.
        rule[type] = {
          beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
          endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),
          hasExceptions: exceptions.length > 0,
          markers: new RegExp(`^(${markers.map(escape).join('|')})`)
        };
        return rule;
      }, {});
      reportBegin = function(node, message, match, refChar) {
        var commentIdentifier, type;
        type = node.type.toLowerCase();
        commentIdentifier = type === 'block' ? '###' : '#';
        return context.report({
          node,
          fix: function(fixer) {
            var end, start;
            start = node.range[0];
            end = start + commentIdentifier.length;
            if (requireSpace) {
              if (match) {
                end += match[0].length;
              }
              return fixer.insertTextAfterRange([start, end], ' ');
            }
            end += match[0].length;
            return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ''));
          },
          message,
          data: {refChar}
        });
      };
      reportEnd = function(node, message, match) {
        return context.report({
          node,
          fix: function(fixer) {
            var end, start;
            if (requireSpace) {
              return fixer.insertTextAfterRange([node.range[0], node.range[1] - 3], ' ');
            }
            end = node.range[1] - 3;
            start = end - match[0].length;
            return fixer.replaceTextRange([start, end], '');
          },
          message
        });
      };
      checkCommentForSpace = function(node) {
        var beginMatch, commentIdentifier, endMatch, hasMarker, marker, rule, type;
        type = node.type.toLowerCase();
        rule = styleRules[type];
        commentIdentifier = type === 'block' ? '###' : '#';
        // Ignores empty comments.
        if (node.value.length === 0) {
          return;
        }
        beginMatch = rule.beginRegex.exec(node.value);
        endMatch = rule.endRegex.exec(node.value);
        // Checks.
        if (requireSpace) {
          if (!beginMatch) {
            hasMarker = rule.markers.exec(node.value);
            marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
            if (rule.hasExceptions) {
              reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
            } else {
              reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
            }
          }
          if (balanced && type === 'block' && !endMatch) {
            return reportEnd(node, "Expected space or tab before '###' in comment.");
          }
        } else {
          if (beginMatch) {
            if (!beginMatch[1]) {
              reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
            } else {
              reportBegin(node, 'Unexpected space or tab after marker ({{refChar}}) in comment.', beginMatch, beginMatch[1]);
            }
          }
          if (balanced && type === 'block' && endMatch) {
            return reportEnd(node, "Unexpected space or tab before '###' in comment.", endMatch);
          }
        }
      };
      return {
        Program: function() {
          var comments;
          comments = sourceCode.getAllComments();
          return comments.filter(function(token) {
            return token.type !== 'Shebang';
          }).forEach(checkCommentForSpace);
        }
      };
    }
  };

}).call(this);
