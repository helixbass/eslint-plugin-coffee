// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A rule to set the maximum number of line of code in a function.
   * @author Pete Ward <peteward44@gmail.com>
   */
  'use strict';
  /**
   * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.
   * @param {Array} comments An array of comment nodes.
   * @returns {Map.<string,Node>} A map with numeric keys (source code line numbers) and comment token values.
   */
  var OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA, getCommentLineNumbers, getFunctionNameWithKind, isIife;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  ({isIife, getFunctionNameWithKind} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Constants
  //------------------------------------------------------------------------------
  OPTIONS_SCHEMA = {
    type: 'object',
    properties: {
      max: {
        type: 'integer',
        minimum: 0
      },
      skipComments: {
        type: 'boolean'
      },
      skipBlankLines: {
        type: 'boolean'
      },
      IIFEs: {
        type: 'boolean'
      }
    },
    additionalProperties: false
  };

  OPTIONS_OR_INTEGER_SCHEMA = {
    oneOf: [
      OPTIONS_SCHEMA,
      {
        type: 'integer',
        minimum: 1
      }
    ]
  };

  getCommentLineNumbers = function(comments) {
    var map;
    map = new Map();
    if (!comments) {
      return map;
    }
    comments.forEach(function(comment) {
      var i, results;
      i = comment.loc.start.line;
      results = [];
      while (i <= comment.loc.end.line) {
        map.set(i, comment);
        results.push(i++);
      }
      return results;
    });
    return map;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce a maximum number of line of code in a function',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/max-lines-per-function'
      },
      schema: [OPTIONS_OR_INTEGER_SCHEMA]
    },
    create: function(context) {
      /**
       * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property
       * @param {ASTNode} node Node to test
       * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property
       */
      /**
       * Count the lines in the function
       * @param {ASTNode} funcNode Function AST node
       * @returns {void}
       * @private
       */
      var IIFEs, commentLineNumbers, isEmbedded, isFullLineComment, lines, maxLines, option, processFunction, skipBlankLines, skipComments, sourceCode;
      sourceCode = context.getSourceCode();
      ({lines} = sourceCode);
      option = context.options[0];
      maxLines = 50;
      skipComments = false;
      skipBlankLines = false;
      IIFEs = false;
      if (typeof option === 'object') {
        if (typeof option.max === 'number') {
          maxLines = option.max;
        }
        if (typeof option.skipComments === 'boolean') {
          ({skipComments} = option);
        }
        if (typeof option.skipBlankLines === 'boolean') {
          ({skipBlankLines} = option);
        }
        if (typeof option.IIFEs === 'boolean') {
          ({IIFEs} = option);
        }
      } else if (typeof option === 'number') {
        maxLines = option;
      }
      commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Tells if a comment encompasses the entire line.
       * @param {string} line The source line with a trailing comment
       * @param {number} lineNumber The one-indexed line number this is on
       * @param {ASTNode} comment The comment to remove
       * @returns {boolean} If the comment covers the entire line
       */
      isFullLineComment = function(line, lineNumber, comment) {
        var end, isFirstTokenOnLine, isLastTokenOnLine, start;
        ({start, end} = comment.loc);
        isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim();
        isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
        return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
      };
      isEmbedded = function(node) {
        var ref;
        if (!node.parent) {
          return false;
        }
        if (node !== node.parent.value) {
          return false;
        }
        if (node.parent.type === 'MethodDefinition') {
          return true;
        }
        if (node.parent.type === 'Property') {
          return node.parent.method === true || ((ref = node.parent.kind) === 'get' || ref === 'set');
        }
        return false;
      };
      processFunction = function(funcNode) {
        var i, j, line, lineCount, name, node, ref, ref1;
        node = isEmbedded(funcNode) ? funcNode.parent : funcNode;
        if (!IIFEs && isIife(node)) {
          return;
        }
        lineCount = 0;
        for (i = j = ref = node.loc.start.line - 1, ref1 = node.loc.end.line; (ref <= ref1 ? j < ref1 : j > ref1); i = ref <= ref1 ? ++j : --j) {
          line = lines[i];
          if (skipComments && commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
            continue;
          }
          if (skipBlankLines && line.match(/^\s*$/)) {
            continue;
          }
          lineCount++;
        }
        if (lineCount > maxLines) {
          name = getFunctionNameWithKind(funcNode);
          return context.report({
            node,
            message: '{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.',
            data: {name, lineCount, maxLines}
          });
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------
        FunctionDeclaration: processFunction,
        FunctionExpression: processFunction,
        ArrowFunctionExpression: processFunction
      };
    }
  };

}).call(this);
