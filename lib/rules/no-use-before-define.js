// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag use of variables before they are defined
   * @author Ilya Volodin
   */
  'use strict';
  /**
   * Checks whether or not a given variable is a function declaration.
   *
   * @param {eslint-scope.Variable} variable - A variable to check.
   * @returns {boolean} `true` if the variable is a function declaration.
   */
  /**
   * Checks whether or not a given reference is inside of the initializers of a given variable.
   *
   * This returns `true` in the following cases:
   *
   *     var a = a
   *     var [a = a] = list
   *     var {a = a} = obj
   *     for (var a in a) {}
   *     for (var a of a) {}
   *
   * @param {Variable} variable - A variable to check.
   * @param {Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is inside of the initializers.
   */
  /**
   * Checks whether or not a given location is inside of the range of a given node.
   *
   * @param {ASTNode} node - An node to check.
   * @param {number} location - A location to check.
   * @returns {boolean} `true` if the location is inside of the range of the node.
   */
  /**
   * Checks whether or not a given variable is a class declaration in an upper function scope.
   *
   * @param {eslint-scope.Variable} variable - A variable to check.
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the variable is a class declaration.
   */
  /**
   * Checks whether or not a given variable is a variable declaration in an upper function scope.
   * @param {eslint-scope.Variable} variable - A variable to check.
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the variable is a variable declaration.
   */
  /**
   * Parses a given value as options.
   *
   * @param {any} options - A value to parse.
   * @returns {Object} The parsed options.
   */
  var FOR_IN_OF_TYPE, SENTINEL_TYPE, isFunction, isInInitializer, isInPostfixBody, isInRange, isOuterClass, isOuterVariable, parseOptions;

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration|For)$/;

  FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;

  parseOptions = function(options) {
    var classes, functions, variables;
    functions = true;
    classes = true;
    variables = true;
    if (typeof options === 'string') {
      functions = options !== 'nofunc';
    } else if (typeof options === 'object' && options !== null) {
      functions = options.functions !== false;
      classes = options.classes !== false;
      variables = options.variables !== false;
    }
    return {functions, classes, variables};
  };

  isFunction = function(variable, reference) {
    var name;
    ({name} = variable.defs[0]);
    if (!(name.parent.type === 'AssignmentExpression' && name.parent.right.type === 'FunctionExpression')) {
      return false;
    }
    return variable.scope.variableScope !== reference.from.variableScope;
  };

  isOuterClass = function(variable, reference) {
    return variable.defs[0].type === 'ClassName' && variable.scope.variableScope !== reference.from.variableScope;
  };

  isOuterVariable = function(variable, reference) {
    return variable.defs[0].type === 'Variable' && variable.scope.variableScope !== reference.from.variableScope;
  };

  isInRange = function(node, location) {
    return node && node.range[0] <= location && location <= node.range[1];
  };

  isInInitializer = function(variable, reference) {
    var location, node;
    if (variable.scope !== reference.from) {
      return false;
    }
    node = variable.identifiers[0].parent;
    location = reference.identifier.range[1];
    while (node) {
      if (node.type === 'AssignmentExpression') {
        if (isInRange(node.right, location)) {
          return true;
        }
        if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
          return true;
        }
        break;
      } else if (node.type === 'AssignmentPattern') {
        if (isInRange(node.right, location)) {
          return true;
        }
      } else if (SENTINEL_TYPE.test(node.type)) {
        break;
      }
      node = node.parent;
    }
    return false;
  };

  isInPostfixBody = function(variable, reference) {
    var location, node, ref;
    node = variable.identifiers[0].parent;
    location = reference.identifier.range[1];
    while (node) {
      if (node.postfix) {
        return isInRange((ref = node.consequent) != null ? ref : node.body, location);
      }
      node = node.parent;
    }
    return false;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow the use of variables before they are defined',
        category: 'Variables',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-use-before-define'
      },
      schema: [
        {
          oneOf: [
            {
              enum: ['nofunc']
            },
            {
              type: 'object',
              properties: {
                functions: {
                  type: 'boolean'
                },
                classes: {
                  type: 'boolean'
                },
                variables: {
                  type: 'boolean'
                }
              },
              additionalProperties: false
            }
          ]
        }
      ]
    },
    create: function(context) {
      /**
       * Finds and validates all variables in a given scope.
       * @param {Scope} scope The scope object.
       * @returns {void}
       * @private
       */
      /**
       * Determines whether a given use-before-define case should be reported according to the options.
       * @param {eslint-scope.Variable} variable The variable that gets used before being defined
       * @param {eslint-scope.Reference} reference The reference to the variable
       * @returns {boolean} `true` if the usage should be reported
       */
      var findVariablesInScope, isForbidden, options;
      options = parseOptions(context.options[0]);
      isForbidden = function(variable, reference) {
        if (isFunction(variable, reference)) {
          return options.functions;
        }
        if (isOuterClass(variable, reference)) {
          return options.classes;
        }
        if (isOuterVariable(variable, reference)) {
          return options.variables;
        }
        return true;
      };
      findVariablesInScope = function(scope) {
        scope.references.forEach(function(reference) {
          var ref, variable;
          variable = reference.resolved;
          /*
           * Skips when the reference is:
           * - initialization's.
           * - referring to an undefined variable.
           * - referring to a global environment variable (there're no identifiers).
           * - located preceded by the variable (except in initializers).
           * - allowed by options.
           */
          if (reference.init || ((ref = reference.identifier) != null ? ref.declaration : void 0) || !variable || variable.identifiers.length === 0 || (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) || !isForbidden(variable, reference)) {
            return;
          }
          if (isInPostfixBody(variable, reference)) {
            return;
          }
          // Reports.
          return context.report({
            node: reference.identifier,
            message: "'{{name}}' was used before it was defined.",
            data: reference.identifier
          });
        });
        return scope.childScopes.forEach(findVariablesInScope);
      };
      return {
        Program: function() {
          return findVariablesInScope(context.getScope());
        }
      };
    }
  };

}).call(this);
