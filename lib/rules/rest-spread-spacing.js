// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce spacing between rest and spread operators and their expressions.
   * @author Kai Cataldo
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce spacing between rest and spread operators and their expressions',
        category: 'ECMAScript 6',
        recommended: false,
        url: 'https://eslint.org/docs/rules/rest-spread-spacing'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['always',
        'never']
        }
      ]
    },
    create: function(context) {
      var alwaysSpace, checkWhiteSpace, sourceCode;
      sourceCode = context.getSourceCode();
      alwaysSpace = context.options[0] === 'always';
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Checks whitespace between rest/spread operators and their expressions
       * @param {ASTNode} node - The node to check
       * @returns {void}
       */
      checkWhiteSpace = function(node) {
        var hasWhitespace, nextToken, operator, postfix, prevToken, type;
        ({postfix} = node);
        if (postfix) {
          operator = sourceCode.getLastToken(node);
          prevToken = sourceCode.getTokenBefore(operator);
          hasWhitespace = sourceCode.isSpaceBetweenTokens(prevToken, operator);
        } else {
          operator = sourceCode.getFirstToken(node);
          nextToken = sourceCode.getTokenAfter(operator);
          hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
        }
        switch (node.type) {
          case 'SpreadElement':
            type = 'spread';
            if (node.parent.type === 'ObjectExpression') {
              type += ' property';
            }
            break;
          case 'RestElement':
            type = 'rest';
            if (node.parent.type === 'ObjectPattern') {
              type += ' property';
            }
            break;
          case 'ExperimentalSpreadProperty':
            type = 'spread property';
            break;
          case 'ExperimentalRestProperty':
            type = 'rest property';
            break;
          default:
            return;
        }
        if (alwaysSpace && !hasWhitespace) {
          return context.report({
            node,
            loc: {
              line: operator.loc.end.line,
              column: operator.loc.end.column
            },
            message: `Expected whitespace ${postfix ? 'before' : 'after'} {{type}} operator.`,
            data: {type},
            fix: function(fixer) {
              return fixer.replaceTextRange(postfix ? [prevToken.range[1], operator.range[0]] : [operator.range[1], nextToken.range[0]], ' ');
            }
          });
        } else if (!alwaysSpace && hasWhitespace) {
          return context.report({
            node,
            loc: {
              line: operator.loc.end.line,
              column: operator.loc.end.column
            },
            message: `Unexpected whitespace ${postfix ? 'before' : 'after'} {{type}} operator.`,
            data: {type},
            fix: function(fixer) {
              return fixer.removeRange(postfix ? [prevToken.range[1], operator.range[0]] : [operator.range[1], nextToken.range[0]]);
            }
          });
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        SpreadElement: checkWhiteSpace,
        RestElement: checkWhiteSpace,
        ExperimentalSpreadProperty: checkWhiteSpace,
        ExperimentalRestProperty: checkWhiteSpace
      };
    }
  };

}).call(this);
