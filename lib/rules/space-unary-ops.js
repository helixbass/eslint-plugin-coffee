// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview This rule shoud require or disallow spaces before or after unary operations.
   * @author Marcin Kumorek
   */
  'use strict';
  var astUtils;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing before or after unary operators',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/space-unary-ops'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            words: {
              type: 'boolean'
            },
            nonwords: {
              type: 'boolean'
            },
            overrides: {
              type: 'object',
              additionalProperties: {
                type: 'boolean'
              }
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements
       * @param {ASTnode} node AST node
       * @returns {void}
       */
      /**
       * Verifies AwaitExpressions satisfy spacing requirements
       * @param {ASTNode} node AwaitExpression AST node
       * @returns {void}
       */
      /**
       * Verifies YieldExpressions satisfy spacing requirements
       * @param {ASTnode} node AST node
       * @returns {void}
       */
      /**
       * Check Unary Word Operators for spaces after the word operator
       * @param {ASTnode} node AST node
       * @param {Object} firstToken first token from the AST node
       * @param {Object} secondToken second token from the AST node
       * @param {string} word The word to be used for reporting
       * @returns {void}
       */
      /**
       * Gets the value that the override was set to for this operator
       * @param {string} operator Operator
       * @returns {boolean} Whether or not an override enforces a space with this operator
       */
      /**
       * Checks if an override exists for a given operator.
       * @param {string} operator Operator
       * @returns {boolean} Whether or not an override has been provided for the operator
       */
      /**
       * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator
       * @param {ASTnode} node AST node
       * @param {Object} firstToken First token in the expression
       * @param {Object} secondToken Second token in the expression
       * @returns {void}
       */
      /**
       * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
       * @param {ASTnode} node AST node
       * @param {Object} firstToken First token in the expression
       * @param {Object} secondToken Second token in the expression
       * @returns {void}
       */
      /**
       * Verify Unary Word Operator doesn't have spaces after the word operator
       * @param {ASTnode} node AST node
       * @param {Object} firstToken first token from the AST node
       * @param {Object} secondToken second token from the AST node
       * @param {string} word The word to be used for reporting
       * @returns {void}
       */
      /**
       * Verify Unary Word Operator has spaces after the word operator
       * @param {ASTnode} node AST node
       * @param {Object} firstToken first token from the AST node
       * @param {Object} secondToken second token from the AST node
       * @param {string} word The word to be used for reporting
       * @returns {void}
       */
      var checkForSpaces, checkForSpacesAfterAwait, checkForSpacesAfterYield, checkUnaryWordOperatorForSpaces, isFirstBangInBangBangExpression, options, overrideEnforcesSpaces, overrideExistsForOperator, sourceCode, verifyNonWordsDontHaveSpaces, verifyNonWordsHaveSpaces, verifyWordDoesntHaveSpaces, verifyWordHasSpaces;
      options = (context.options && Array.isArray(context.options) && context.options[0]) || {
        words: true,
        nonwords: false
      };
      sourceCode = context.getSourceCode();
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Check if the node is the first "!" in a "!!" convert to Boolean expression
       * @param {ASTnode} node AST node
       * @returns {boolean} Whether or not the node is first "!" in "!!"
       */
      isFirstBangInBangBangExpression = function(node) {
        return node && node.type === 'UnaryExpression' && node.argument.operator === '!' && node.argument && node.argument.type === 'UnaryExpression' && node.argument.operator === '!';
      };
      overrideExistsForOperator = function(operator) {
        return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
      };
      overrideEnforcesSpaces = function(operator) {
        return options.overrides[operator];
      };
      verifyWordHasSpaces = function(node, firstToken, secondToken, word) {
        if (secondToken.range[0] === firstToken.range[1]) {
          return context.report({
            node,
            message: "Unary word operator '{{word}}' must be followed by whitespace.",
            data: {word},
            fix: function(fixer) {
              return fixer.insertTextAfter(firstToken, ' ');
            }
          });
        }
      };
      verifyWordDoesntHaveSpaces = function(node, firstToken, secondToken, word) {
        if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
          if (secondToken.range[0] > firstToken.range[1]) {
            return context.report({
              node,
              message: "Unexpected space after unary word operator '{{word}}'.",
              data: {word},
              fix: function(fixer) {
                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
              }
            });
          }
        }
      };
      checkUnaryWordOperatorForSpaces = function(node, firstToken, secondToken, word) {
        if (overrideExistsForOperator(word)) {
          if (overrideEnforcesSpaces(word)) {
            return verifyWordHasSpaces(node, firstToken, secondToken, word);
          } else {
            return verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
          }
        } else if (options.words) {
          return verifyWordHasSpaces(node, firstToken, secondToken, word);
        } else {
          return verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
        }
      };
      checkForSpacesAfterYield = function(node) {
        var tokens, word;
        tokens = sourceCode.getFirstTokens(node, 3);
        word = 'yield';
        if (!node.argument || node.delegate) {
          return;
        }
        return checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
      };
      checkForSpacesAfterAwait = function(node) {
        var tokens;
        tokens = sourceCode.getFirstTokens(node, 3);
        return checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], 'await');
      };
      verifyNonWordsHaveSpaces = function(node, firstToken, secondToken) {
        if (node.prefix) {
          if (isFirstBangInBangBangExpression(node)) {
            return;
          }
          if (firstToken.range[1] === secondToken.range[0]) {
            return context.report({
              node,
              message: "Unary operator '{{operator}}' must be followed by whitespace.",
              data: {
                operator: firstToken.value
              },
              fix: function(fixer) {
                return fixer.insertTextAfter(firstToken, ' ');
              }
            });
          }
        } else if (firstToken.range[1] === secondToken.range[0]) {
          return context.report({
            node,
            message: "Space is required before unary expressions '{{token}}'.",
            data: {
              token: secondToken.value
            },
            fix: function(fixer) {
              return fixer.insertTextBefore(secondToken, ' ');
            }
          });
        }
      };
      verifyNonWordsDontHaveSpaces = function(node, firstToken, secondToken) {
        if (node.prefix) {
          if (secondToken.range[0] > firstToken.range[1]) {
            return context.report({
              node,
              message: "Unexpected space after unary operator '{{operator}}'.",
              data: {
                operator: firstToken.value
              },
              fix: function(fixer) {
                if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                  return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                }
                return null;
              }
            });
          }
        } else if (secondToken.range[0] > firstToken.range[1]) {
          return context.report({
            node,
            message: "Unexpected space before unary operator '{{operator}}'.",
            data: {
              operator: secondToken.value
            },
            fix: function(fixer) {
              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
            }
          });
        }
      };
      checkForSpaces = function(node) {
        var firstToken, operator, ref, secondToken, tokens;
        if (((ref = node.type) === 'UpdateExpression' || ref === 'UnaryExpression') && !node.prefix) {
          return;
        }
        tokens = sourceCode.getFirstTokens(node, 2);
        firstToken = tokens[0];
        secondToken = tokens[1];
        if ((node.type === 'NewExpression' || node.prefix) && firstToken.type === 'Keyword') {
          checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
          return;
        }
        operator = node.prefix ? tokens[0].value : tokens[1].value;
        if (overrideExistsForOperator(operator)) {
          if (overrideEnforcesSpaces(operator)) {
            return verifyNonWordsHaveSpaces(node, firstToken, secondToken);
          } else {
            return verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
          }
        } else if (options.nonwords) {
          return verifyNonWordsHaveSpaces(node, firstToken, secondToken);
        } else {
          return verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        UnaryExpression: checkForSpaces,
        UpdateExpression: checkForSpaces,
        NewExpression: checkForSpaces,
        YieldExpression: checkForSpacesAfterYield,
        AwaitExpression: checkForSpacesAfterAwait
      };
    }
  };

}).call(this);
