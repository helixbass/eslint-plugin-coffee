// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A rule to disallow modifying variables of class declarations
   * @author Toru Nagashima
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow reassigning class members',
        category: 'ECMAScript 6',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-class-assign'
      },
      schema: [],
      messages: {
        class: "'{{name}}' is a class."
      }
    },
    create: function(context) {
      /**
       * Finds and reports references that are non initializer and writable.
       * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.
       * @returns {void}
       */
      /**
       * Finds and reports references that are non initializer and writable.
       * @param {Variable} variable - A variable to check.
       * @returns {void}
       */
      var checkForClass, checkVariable, report;
      report = function(node) {
        var ref, ref1;
        return context.report({
          node,
          messageId: 'class',
          data: {
            name: (ref = node.name) != null ? ref : (ref1 = node.id) != null ? ref1.name : void 0
          }
        });
      };
      checkVariable = function(variable) {
        return astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
          return report(reference.identifier);
        });
      };
      checkForClass = function(node) {
        var clashingDefinition, ref, ref1, ref2, ref3, ref4;
        context.getDeclaredVariables(node).forEach(checkVariable);
        if (((ref = node.id) != null ? ref.type : void 0) === 'Identifier' && !((ref1 = node.id) != null ? ref1.declaration : void 0) && !(node.parent.type === 'AssignmentExpression' && node.parent.left.type === 'Identifier' && node.parent.left.name === node.id.name)) {
          clashingDefinition = (ref2 = context.getScope().upper.set.get(node.id.name)) != null ? (ref3 = ref2.defs) != null ? (ref4 = ref3[0]) != null ? ref4.node : void 0 : void 0 : void 0;
          if (clashingDefinition != null) {
            return report(clashingDefinition);
          }
        }
      };
      return {
        ClassDeclaration: checkForClass,
        ClassExpression: checkForClass
      };
    }
  };

}).call(this);
