// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to replace assignment expressions with operator assignment
   * @author Brandon Mills
   */
  'use strict';
  /**
   * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)
   * toString calls regardless of whether assignment shorthand is used)
   * @param {ASTNode} node The node on the left side of the expression
   * @returns {boolean} `true` if the node can be fixed
   */
  /**
   * Checks whether an operator is not commuatative and has an operator assignment
   * shorthand form.
   * @param   {string}  operator Operator to check.
   * @returns {boolean}          True if the operator is not commuatative and has
   *     a shorthand form.
   */
  var astUtils, canBeFixed, isCommutativeOperatorWithShorthand, isNonCommutativeOperatorWithShorthand, same, utils;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  utils = require('../util/ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Checks whether an operator is commutative and has an operator assignment
   * shorthand form.
   * @param   {string}  operator Operator to check.
   * @returns {boolean}          True if the operator is commutative and has a
   *     shorthand form.
   */
  isCommutativeOperatorWithShorthand = function(operator) {
    return ['*', '&', '^', '|'].indexOf(operator) >= 0;
  };

  isNonCommutativeOperatorWithShorthand = function(operator) {
    return ['+', '-', '/', '%', '<<', '>>', '>>>', '**', 'and', 'or', '&&', '||', '?'].indexOf(operator) >= 0;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  /**
   * Checks whether two expressions reference the same value. For example:
   *     a = a
   *     a.b = a.b
   *     a[0] = a[0]
   *     a['b'] = a['b']
   * @param   {ASTNode} a Left side of the comparison.
   * @param   {ASTNode} b Right side of the comparison.
   * @returns {boolean}   True if both sides match and reference the same value.
   */
  same = function(a, b) {
    if (a.type !== b.type) {
      return false;
    }
    switch (a.type) {
      case 'Identifier':
        return a.name === b.name;
      case 'Literal':
        return a.value === b.value;
      case 'MemberExpression':
        /*
         * x[0] = x[0]
         * x[y] = x[y]
         * x.y = x.y
         */
        return same(a.object, b.object) && same(a.property, b.property);
      default:
        return false;
    }
  };

  canBeFixed = function(node) {
    return node.type === 'Identifier' || (node.type === 'MemberExpression' && node.object.type === 'Identifier' && (!node.computed || node.property.type === 'Literal'));
  };

  module.exports = {
    meta: {
      docs: {
        description: 'require or disallow assignment operator shorthand where possible',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/operator-assignment'
      },
      schema: [
        {
          enum: ['always',
        'never']
        }
      ],
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Returns the operator token of an AssignmentExpression or BinaryExpression
       * @param {ASTNode} node An AssignmentExpression or BinaryExpression node
       * @returns {Token} The operator token in the node
       */
      /**
       * Warns if an assignment expression uses operator assignment shorthand.
       * @param   {ASTNode} node An AssignmentExpression node.
       * @returns {void}
       */
      /**
       * Ensures that an assignment uses the shorthand form where possible.
       * @param   {ASTNode} node An AssignmentExpression node.
       * @returns {void}
       */
      var getOperatorToken, prohibit, sourceCode, verify;
      sourceCode = context.getSourceCode();
      getOperatorToken = function(node) {
        return sourceCode.getFirstTokenBetween(node.left, node.right, function(token) {
          return token.value === node.operator;
        });
      };
      verify = function(node) {
        var expr, left, operator, ref;
        if (node.operator !== '=' || ((ref = node.right.type) !== 'BinaryExpression' && ref !== 'LogicalExpression')) {
          return;
        }
        ({
          left,
          right: expr
        } = node);
        ({operator} = expr);
        if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
          if (same(left, expr.left)) {
            return context.report({
              node,
              message: 'Assignment can be replaced with operator assignment.',
              fix: function(fixer) {
                var equalsToken, leftText, operatorToken, rightText;
                if (canBeFixed(left)) {
                  equalsToken = getOperatorToken(node);
                  operatorToken = getOperatorToken(expr);
                  leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                  rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);
                  return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);
                }
                return null;
              }
            });
          } else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) {
            /*
             * This case can't be fixed safely.
             * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would
             * change the execution order of the valueOf() functions.
             */
            return context.report({
              node,
              message: 'Assignment can be replaced with operator assignment.'
            });
          }
        }
      };
      prohibit = function(node) {
        if (node.operator !== '=') {
          return context.report({
            node,
            message: 'Unexpected operator assignment shorthand.',
            fix: function(fixer) {
              var leftText, newOperator, operatorToken, rightText;
              if (canBeFixed(node.left)) {
                operatorToken = getOperatorToken(node);
                leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                newOperator = node.operator.slice(0, -1);
                // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.
                if (utils.getPrecedence(node.right) <= utils.getPrecedence({
                  type: (function() {
                    switch (newOperator) {
                      case '||':
                      case 'or':
                      case '&&':
                      case 'and':
                      case '?':
                        return 'LogicalExpression';
                      default:
                        return 'BinaryExpression';
                    }
                  })(),
                  operator: newOperator
                }) && !astUtils.isParenthesised(sourceCode, node.right)) {
                  rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
                } else {
                  rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
                }
                return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
              }
              return null;
            }
          });
        }
      };
      return {
        AssignmentExpression: context.options[0] !== 'never' ? verify : prohibit
      };
    }
  };

}).call(this);
