// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Disallows multiple blank lines.
   * implementation adapted from the no-trailing-spaces rule.
   * @author Greg Cochard
   */
  'use strict';
  var countBy;

  ({countBy} = require('lodash'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow multiple empty lines',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-multiple-empty-lines'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            max: {
              type: 'integer',
              minimum: 0
            },
            maxEOF: {
              type: 'integer',
              minimum: 0
            },
            maxBOF: {
              type: 'integer',
              minimum: 0
            }
          },
          required: ['max'],
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var allLines, max, maxBOF, maxEOF, sourceCode, templateLiteralLines;
      // Use options.max or 2 as default
      max = 2;
      maxEOF = max;
      maxBOF = max;
      if (context.options.length) {
        ({max} = context.options[0]);
        maxEOF = typeof context.options[0].maxEOF !== 'undefined' ? context.options[0].maxEOF : max;
        maxBOF = typeof context.options[0].maxBOF !== 'undefined' ? context.options[0].maxBOF : max;
      }
      sourceCode = context.getSourceCode();
      // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue
      allLines = sourceCode.lines[sourceCode.lines.length - 1] === '' ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
      templateLiteralLines = new Set();
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        TemplateLiteral: function(node) {
          return node.quasis.forEach(function(literalPart) {
            var i, ignoredLine, numNewlines, ref, ref1, results;
            ignoredLine = literalPart.loc.start.line;
            // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.
            // Don't trust loc.end.line (since we're currently just +1'ing the last column of the inclusive location data)
            // while ignoredLine < literalPart.loc.end.line
            //   templateLiteralLines.add ignoredLine
            //   ignoredLine++
            numNewlines = (ref = countBy(literalPart.value.raw)['\n']) != null ? ref : 0;
            results = [];
            for (i = 0, ref1 = numNewlines; (0 <= ref1 ? i < ref1 : i > ref1); 0 <= ref1 ? i++ : i--) {
              templateLiteralLines.add(ignoredLine);
              results.push(ignoredLine++);
            }
            return results;
          });
        },
        'Program:exit': function(node) {
          // Given a list of lines, first get a list of line numbers that are non-empty.
          return allLines.reduce(function(nonEmptyLineNumbers, line, index) {
            if (line.trim() || templateLiteralLines.has(index + 1)) {
              nonEmptyLineNumbers.push(index + 1);
            }
            return nonEmptyLineNumbers;
          // Add a value at the end to allow trailing empty lines to be checked.
          // Given two line numbers of non-empty lines, report the lines between if the difference is too large.
          }, []).concat(allLines.length + 1).reduce(function(lastLineNumber, lineNumber) {
            var maxAllowed, message;
            if (lastLineNumber === 0) {
              message = 'Too many blank lines at the beginning of file. Max of {{max}} allowed.';
              maxAllowed = maxBOF;
            } else if (lineNumber === allLines.length + 1) {
              message = 'Too many blank lines at the end of file. Max of {{max}} allowed.';
              maxAllowed = maxEOF;
            } else {
              message = 'More than {{max}} blank {{pluralizedLines}} not allowed.';
              maxAllowed = max;
            }
            if (lineNumber - lastLineNumber - 1 > maxAllowed) {
              context.report({
                node,
                loc: {
                  start: {
                    line: lastLineNumber + 1,
                    column: 0
                  },
                  end: {
                    line: lineNumber,
                    column: 0
                  }
                },
                message,
                data: {
                  max: maxAllowed,
                  pluralizedLines: maxAllowed === 1 ? 'line' : 'lines'
                },
                fix: function(fixer) {
                  /*
                   * The end of the removal range is usually the start index of the next line.
                   * However, at the end of the file there is no next line, so the end of the
                   * range is just the length of the text.
                   */
                  var lineNumberAfterRemovedLines, rangeEnd, rangeStart;
                  rangeStart = sourceCode.getIndexFromLoc({
                    line: lastLineNumber + 1,
                    column: 0
                  });
                  lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                  rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({
                    line: lineNumberAfterRemovedLines,
                    column: 0
                  }) : sourceCode.text.length;
                  return fixer.removeRange([rangeStart, rangeEnd]);
                }
              });
            }
            return lineNumber;
          }, 0);
        }
      };
    }
  };

}).call(this);
