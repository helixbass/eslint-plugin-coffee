// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Validate closing bracket location in JSX
   * @author Yannick Croissant
   */
  'use strict';
  var docsUrl, has;

  ({has} = require('lodash'));

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Validate closing bracket location in JSX',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-closing-bracket-location')
      },
      fixable: 'code',
      schema: [
        {
          oneOf: [
            {
              enum: [
                'after-props',
                'props-aligned',
                // 'tag-aligned'
                'line-aligned'
              ]
            },
            {
              type: 'object',
              properties: {
                location: {
                  enum: [
                    'after-props',
                    'props-aligned',
                    // 'tag-aligned'
                    'line-aligned'
                  ]
                }
              },
              additionalProperties: false
            },
            {
              type: 'object',
              properties: {
                nonEmpty: {
                  enum: [
                    'after-props',
                    'props-aligned',
                    // 'tag-aligned'
                    'line-aligned',
                    false
                  ]
                },
                selfClosing: {
                  enum: [
                    'after-props',
                    'props-aligned',
                    // 'tag-aligned'
                    'line-aligned',
                    false
                  ]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ]
    },
    create: function(context) {
      /**
       * Get the correct 0-indexed column for the closing bracket, given the
       * expected location.
       * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop
       * @param {String} expectedLocation Expected location for the closing bracket
       * @return {?Number} The correct column for the closing bracket, or null
       */
      /**
       * Get expected location for the closing bracket
       * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop
       * @return {String} Expected location for the closing bracket
       */
      /**
       * Get the characters used for indentation on the line to be matched
       * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop
       * @param {String} expectedLocation Expected location for the closing bracket
       * @param {Number} correctColumn Expected column for the closing bracket
       * @return {String} The characters used for indentation
       */
      /**
       * Get an unique ID for a given JSXOpeningElement
       *
       * @param {ASTNode} node The AST node being checked.
       * @returns {String} Unique ID (based on its range)
       */
      /**
       * Get the locations of the opening bracket, closing bracket, last prop, and
       * start of opening line.
       * @param {ASTNode} node The node to check
       * @return {Object} Locations of the opening bracket, closing bracket, last
       * prop and start of opening line.
       */
      /**
       * Check if the closing bracket is correctly located
       * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop
       * @param {String} expectedLocation Expected location for the closing bracket
       * @return {Boolean} True if the closing bracket is correctly located, false if not
       */
      var DEFAULT_LOCATION, MESSAGE, MESSAGE_LOCATION, config, getCorrectColumn, getExpectedLocation, getIndentation, getOpeningElementId, getTokensLocations, hasCorrectLocation, lastAttributeNode, options, sourceCode;
      MESSAGE = 'The closing bracket must be {{location}}{{details}}';
      MESSAGE_LOCATION = {
        'after-props': 'placed after the last prop',
        'after-tag': 'placed after the opening tag',
        'props-aligned': 'aligned with the last prop',
        // 'tag-aligned': 'aligned with the opening tag'
        'line-aligned': 'aligned with the line containing the opening tag'
      };
      DEFAULT_LOCATION = 'line-aligned';
      sourceCode = context.getSourceCode();
      config = context.options[0];
      options = {
        nonEmpty: DEFAULT_LOCATION,
        selfClosing: DEFAULT_LOCATION
      };
      if (typeof config === 'string') {
        // simple shorthand [1, 'something']
        options.nonEmpty = config;
        options.selfClosing = config;
      } else if (typeof config === 'object') {
        // [1, {location: 'something'}] (back-compat)
        if (has(config, 'location')) {
          options.nonEmpty = config.location;
          options.selfClosing = config.location;
        }
        // [1, {nonEmpty: 'something'}]
        if (has(config, 'nonEmpty')) {
          options.nonEmpty = config.nonEmpty;
        }
        // [1, {selfClosing: 'something'}]
        if (has(config, 'selfClosing')) {
          options.selfClosing = config.selfClosing;
        }
      }
      getExpectedLocation = function(tokens) {
        var requested;
        requested = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
        // Is always after the opening tag if there is no props
        if (tokens.lastProp == null) {
          return 'after-tag';
        // Is always after the last prop if this one is on the same line as the opening bracket
        } else if (tokens.opening.line === tokens.lastProp.lastLine) {
          return 'after-props';
        // Aligning with prop that's on opening line can cause indentation error
        } else if (tokens.opening.line === tokens.lastProp.firstLine && requested === 'props-aligned') {
          return 'line-aligned';
        } else {
          // Else use configuration dependent on selfClosing property
          return requested;
        }
      };
      getCorrectColumn = function(tokens, expectedLocation) {
        switch (expectedLocation) {
          case 'props-aligned':
            return tokens.lastProp.column;
          case 'tag-aligned':
            return tokens.opening.column;
          case 'line-aligned':
            return tokens.openingStartOfLine.column;
          default:
            return null;
        }
      };
      hasCorrectLocation = function(tokens, expectedLocation) {
        var correctColumn;
        switch (expectedLocation) {
          case 'after-tag':
            return tokens.tag.line === tokens.closing.line;
          case 'after-props':
            return tokens.lastProp.lastLine === tokens.closing.line;
          case 'props-aligned':
          case 'tag-aligned':
          case 'line-aligned':
            correctColumn = getCorrectColumn(tokens, expectedLocation);
            return correctColumn === tokens.closing.column;
          default:
            return true;
        }
      };
      getIndentation = function(tokens, expectedLocation, correctColumn) {
        var indentation, spaces;
        spaces = [];
        switch (expectedLocation) {
          case 'props-aligned':
            indentation = /^\s*/.exec(sourceCode.lines[tokens.lastProp.firstLine - 1])[0];
            break;
          case 'tag-aligned':
          case 'line-aligned':
            indentation = /^\s*/.exec(sourceCode.lines[tokens.opening.line - 1])[0];
            break;
          default:
            indentation = '';
        }
        if (indentation.length + 1 < correctColumn) {
          // Non-whitespace characters were included in the column offset
          spaces = new Array(+correctColumn + 1 - indentation.length);
        }
        return indentation + spaces.join(' ');
      };
      getTokensLocations = function(node) {
        var closing, lastProp, opening, openingLine, openingStartOfLine, tag;
        opening = sourceCode.getFirstToken(node).loc.start;
        closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
        tag = sourceCode.getFirstToken(node.name).loc.start;
        if (node.attributes.length) {
          lastProp = node.attributes[node.attributes.length - 1];
          lastProp = {
            column: sourceCode.getFirstToken(lastProp).loc.start.column,
            firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
            lastLine: sourceCode.getLastToken(lastProp).loc.end.line
          };
        }
        openingLine = sourceCode.lines[opening.line - 1];
        openingStartOfLine = {
          column: /^\s*/.exec(openingLine)[0].length,
          line: opening.line
        };
        return {
          tag,
          opening,
          closing,
          lastProp,
          selfClosing: node.selfClosing,
          openingStartOfLine
        };
      };
      getOpeningElementId = function(node) {
        return node.range.join(':');
      };
      lastAttributeNode = {};
      return {
        JSXAttribute: function(node) {
          return lastAttributeNode[getOpeningElementId(node.parent)] = node;
        },
        JSXSpreadAttribute: function(node) {
          return lastAttributeNode[getOpeningElementId(node.parent)] = node;
        },
        'JSXOpeningElement:exit': function(node) {
          var attributeNode, cachedLastAttributeEndPos, correctColumn, data, expectedLocation, expectedNextLine, tokens;
          attributeNode = lastAttributeNode[getOpeningElementId(node)];
          cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;
          tokens = getTokensLocations(node);
          expectedLocation = getExpectedLocation(tokens);
          if (hasCorrectLocation(tokens, expectedLocation)) {
            return;
          }
          data = {
            location: MESSAGE_LOCATION[expectedLocation],
            details: ''
          };
          correctColumn = getCorrectColumn(tokens, expectedLocation);
          if (correctColumn !== null) {
            expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;
            data.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? ' on the next line)' : ')'}`;
          }
          return context.report({
            node,
            loc: tokens.closing,
            message: MESSAGE,
            data,
            fix: function(fixer) {
              var closingTag;
              closingTag = tokens.selfClosing ? '/>' : '>';
              switch (expectedLocation) {
                case 'after-tag':
                  if (cachedLastAttributeEndPos) {
                    return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? '\n' : '') + closingTag);
                  }
                  return fixer.replaceTextRange([node.name.range[1], node.range[1]], (expectedNextLine ? '\n' : ' ') + closingTag);
                case 'after-props':
                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? '\n' : '') + closingTag);
                case 'props-aligned':
                case 'tag-aligned':
                case 'line-aligned':
                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], `\n${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`);
                default:
                  return true;
              }
            }
          });
        }
      };
    }
  };

}).call(this);
