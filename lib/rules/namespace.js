// Generated by CoffeeScript 2.5.0
(function() {
  var Exports, declaredScope, docsUrl, importDeclaration;

  ({
    default: declaredScope
  } = require('eslint-module-utils/declaredScope'));

  ({
    default: Exports
  } = require('../eslint-plugin-import-export-map'));

  ({
    default: importDeclaration
  } = require('eslint-plugin-import/lib/importDeclaration'));

  ({
    default: docsUrl
  } = require('eslint-plugin-import/lib/docsUrl'));

  module.exports = {
    meta: {
      type: 'problem',
      docs: {
        url: docsUrl('namespace')
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowComputed: {
              description: 'If `false`, will report computed (and thus, un-lintable) references ' + 'to namespace members.',
              type: 'boolean',
              default: false
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var allowComputed, makeMessage, namespaces, testKey;
      // read options
      ({allowComputed = false} = context.options[0] || {});
      namespaces = new Map();
      makeMessage = function(last, namepath) {
        return `'${last.name}' not found in ${namepath.length > 1 ? 'deeply ' : ''}imported namespace '${namepath.join('.')}'.`;
      };
      // DFS traverse child namespaces
      testKey = function(pattern, namespace, path) {
        var dependencyExportMap, property, ref, ref1, results;
        if (!(namespace instanceof Exports)) {
          return;
        }
        if (pattern.type !== 'ObjectPattern') {
          return;
        }
        ref = pattern.properties;
        results = [];
        for (property of ref) {
          if (((ref1 = property.type) === 'ExperimentalRestProperty' || ref1 === 'RestElement') || !property.key) {
            continue;
          }
          if (property.key.type !== 'Identifier') {
            context.report({
              node: property,
              message: 'Only destructure top-level names.'
            });
            continue;
          }
          if (!namespace.has(property.key.name)) {
            context.report({
              node: property,
              message: makeMessage(property.key, path)
            });
            continue;
          }
          path.push(property.key.name);
          dependencyExportMap = namespace.get(property.key.name);
          // could be null when ignored or ambiguous
          if (dependencyExportMap !== null) {
            testKey(property.value, dependencyExportMap.namespace, path);
          }
          results.push(path.pop());
        }
        return results;
      };
      return {
        // pick up all imports at body entry time, to properly respect hoisting
        Program: function({body}) {
          var processBodyStatement;
          processBodyStatement = function(declaration) {
            var imports, meta, ref, results, specifier;
            if (declaration.type !== 'ImportDeclaration') {
              return;
            }
            if (declaration.specifiers.length === 0) {
              return;
            }
            imports = Exports.get(declaration.source.value, context);
            if (imports == null) {
              return null;
            }
            if (imports.errors.length) {
              imports.reportErrors(context, declaration);
              return;
            }
            ref = declaration.specifiers;
            results = [];
            for (specifier of ref) {
              switch (specifier.type) {
                case 'ImportNamespaceSpecifier':
                  if (!imports.size) {
                    context.report(specifier, `No exported names found in module '${declaration.source.value}'.`);
                  }
                  results.push(namespaces.set(specifier.local.name, imports));
                  break;
                case 'ImportDefaultSpecifier':
                case 'ImportSpecifier':
                  // default to 'default' for default http://i.imgur.com/nj6qAWy.jpg
                  meta = imports.get(specifier.imported ? specifier.imported.name : 'default');
                  if (!(meta != null ? meta.namespace : void 0)) {
                    break;
                  }
                  results.push(namespaces.set(specifier.local.name, meta.namespace));
                  break;
                default:
                  results.push(void 0);
              }
            }
            return results;
          };
          return body.forEach(processBodyStatement);
        },
        // same as above, but does not add names to local map
        ExportNamespaceSpecifier: function(namespace) {
          var declaration, imports;
          declaration = importDeclaration(context);
          imports = Exports.get(declaration.source.value, context);
          if (imports == null) {
            return null;
          }
          if (imports.errors.length) {
            imports.reportErrors(context, declaration);
            return;
          }
          if (!imports.size) {
            return context.report(namespace, `No exported names found in module '${declaration.source.value}'.`);
          }
        },
        // todo: check for possible redefinition
        MemberExpression: function(dereference) {
          var exported, namepath, namespace;
          if (dereference.object.type !== 'Identifier') {
            return;
          }
          if (!namespaces.has(dereference.object.name)) {
            return;
          }
          if (dereference.parent.type === 'AssignmentExpression' && dereference.parent.left === dereference) {
            context.report(dereference.parent, `Assignment to member of namespace '${dereference.object.name}'.`);
          }
          // go deep
          namespace = namespaces.get(dereference.object.name);
          namepath = [dereference.object.name];
          // while property is namespace and parent is member expression, keep validating
          while (namespace instanceof Exports && dereference.type === 'MemberExpression') {
            if (dereference.computed) {
              if (!allowComputed) {
                context.report(dereference.property, `Unable to validate computed reference to imported namespace '${dereference.object.name}'.`);
              }
              return;
            }
            if (!namespace.has(dereference.property.name)) {
              context.report(dereference.property, makeMessage(dereference.property, namepath));
              break;
            }
            exported = namespace.get(dereference.property.name);
            if (exported == null) {
              return;
            }
            // stash and pop
            namepath.push(dereference.property.name);
            ({namespace} = exported);
            dereference = dereference.parent;
          }
        },
        VariableDeclarator: function({id, init}) {
          if (init == null) {
            return;
          }
          if (init.type !== 'Identifier') {
            return;
          }
          if (!namespaces.has(init.name)) {
            return;
          }
          // check for redefinition in intermediate scopes
          if (declaredScope(context, init.name) !== 'module') {
            return;
          }
          return testKey(id, namespaces.get(init.name), [init.name]);
        },
        AssignmentExpression: function({left, right}) {
          if (right.type !== 'Identifier') {
            return;
          }
          if (!namespaces.has(right.name)) {
            return;
          }
          // check for redefinition in intermediate scopes
          if (declaredScope(context, right.name) !== 'module') {
            return;
          }
          return testKey(left, namespaces.get(right.name), [right.name]);
        },
        JSXMemberExpression: function({object, property}) {
          var namespace;
          if (!namespaces.has(object.name)) {
            return;
          }
          namespace = namespaces.get(object.name);
          if (!namespace.has(property.name)) {
            return context.report({
              node: property,
              message: makeMessage(property, [object.name])
            });
          }
        }
      };
    }
  };

}).call(this);
