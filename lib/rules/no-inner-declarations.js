// Generated by CoffeeScript 2.3.1
(function() {
  /**
   * @fileoverview Rule to enforce declarations in program or function body root.
   * @author Brandon Mills
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow variable or `function` declarations in nested blocks',
        category: 'Possible Errors',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-inner-declarations'
      },
      schema: [
        {
          enum: ['functions',
        'both']
        }
      ]
    },
    create: function(context) {
      /**
       * Ensure that a given node is at a program or function body's root.
       * @param {ASTNode} node Declaration node to check.
       * @returns {void}
       */
      /**
       * Find the nearest Program or Function ancestor node.
       * @returns {Object} Ancestor's type and distance from node.
       */
      var check, getAssignmentExpression, getEnclosingExpressionStatement, nearestBody;
      nearestBody = function(enclosingExpressionStatement) {
        var ancestor, generation, ref;
        ancestor = enclosingExpressionStatement.parent;
        generation = 1;
        while (((ref = ancestor != null ? ancestor.type : void 0) !== 'Program' && ref !== 'FunctionDeclaration' && ref !== 'FunctionExpression' && ref !== 'ArrowFunctionExpression')) {
          generation += 1;
          ancestor = ancestor.parent;
        }
        return {
          // Type of containing ancestor
          type: ancestor.type,
          // Separation between ancestor and node
          distance: generation
        };
      };
      getEnclosingExpressionStatement = function(assignmentExpression) {
        var ancestor;
        ancestor = assignmentExpression.parent;
        while (ancestor != null) {
          switch (ancestor.type) {
            case 'BlockStatement':
              return;
            case 'ExpressionStatement':
              return ancestor;
          }
          ancestor = ancestor.parent;
        }
        return null;
      };
      getAssignmentExpression = function(node) {
        var ancestor, prevAncestor;
        prevAncestor = node;
        ancestor = node.parent;
        while (ancestor != null) {
          switch (ancestor.type) {
            case 'AssignmentExpression':
              return (prevAncestor === ancestor.left ? ancestor : void 0);
            case 'FunctionExpression':
              return;
            // when 'AssignmentPattern'
            //   return if prevAncestor is ancestor.right
            case 'Property':
              if (ancestor.parent.type === 'ObjectPattern' && prevAncestor === ancestor.key) {
                return;
              }
          }
          prevAncestor = ancestor;
          ancestor = ancestor.parent;
        }
        return null;
      };
      check = function(node) {
        var assignmentExpression, body, enclosingExpressionStatement, isFunctionDeclaration, valid;
        if (!node.declaration) {
          return;
        }
        isFunctionDeclaration = node.parent.type === 'AssignmentExpression' && node.parent.right.type === 'FunctionExpression';
        if (!(isFunctionDeclaration || context.options[0] === 'both')) {
          return;
        }
        if (!(assignmentExpression = getAssignmentExpression(node))) {
          return;
        }
        if ((enclosingExpressionStatement = getEnclosingExpressionStatement(assignmentExpression))) {
          body = nearestBody(enclosingExpressionStatement);
          valid = (body.type === 'Program' && body.distance === 1) || body.distance === 2;
          if (valid) {
            return;
          }
        }
        return context.report({
          node,
          message: 'Move {{type}} declaration to {{body}} root.',
          data: {
            type: isFunctionDeclaration ? 'function' : 'variable',
            body: body.type === 'Program' ? 'program' : 'function body'
          }
        });
      };
      return {
        Identifier: check
      };
    }
  };

}).call(this);
