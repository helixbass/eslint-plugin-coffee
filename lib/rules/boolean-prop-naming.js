// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforces consistent naming for boolean props
   * @author Ev Haus
   */
  'use strict';
  var Components, docsUrl, has, propsUtil;

  ({has} = require('lodash'));

  Components = require('../util/react/Components');

  // Components = require 'eslint-plugin-react/lib/util/Components'
  propsUtil = require('eslint-plugin-react/lib/util/props');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        category: 'Stylistic Issues',
        description: 'Enforces consistent naming for boolean props',
        recommended: false,
        url: docsUrl('boolean-prop-naming')
      },
      schema: [
        {
          additionalProperties: false,
          properties: {
            propTypeNames: {
              items: {
                type: 'string'
              },
              minItems: 1,
              type: 'array',
              uniqueItems: true
            },
            rule: {
              default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',
              minLength: 1,
              type: 'string'
            },
            message: {
              minLength: 1,
              type: 'string'
            }
          },
          type: 'object'
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Returns the prop key to ensure we handle the following cases:
       * propTypes: {
       *   full: React.PropTypes.bool,
       *   short: PropTypes.bool,
       *   direct: bool,
       *   required: PropTypes.bool.isRequired
       * }
       * @param {Object} node The node we're getting the name of
       */
      /**
       * Returns the name of the given node (prop)
       * @param {Object} node The node we're getting the name of
       */
      /**
       * Reports invalid prop naming
       * @param {Object} component The component to process
       */
      /**
       * Checks and mark props with invalid naming
       * @param {Object} node The component node we're testing
       * @param {Array} proptypes A list of Property object (for each proptype defined)
       */
      var checkPropWrapperArguments, config, getPropKey, getPropName, objectTypeAnnotations, propTypeNames, propWrapperFunctions, reportInvalidNaming, rule, sourceCode, validatePropNaming;
      sourceCode = context.getSourceCode();
      config = context.options[0] || {};
      rule = config.rule ? new RegExp(config.rule) : null;
      propTypeNames = config.propTypeNames || ['bool'];
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      // Remembers all Flowtype object definitions
      objectTypeAnnotations = new Map();
      getPropKey = function(node) {
        var name, ref, ref1;
        if ((ref = node.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
          // Check for `ExperimentalSpreadProperty` (ESLint 3/4) and `SpreadElement` (ESLint 5)
          // so we can skip validation of those fields.
          // Otherwise it will look for `node.value.property` which doesn't exist and breaks ESLint.
          return null;
        }
        if (node.value.property) {
          ({name} = node.value.property);
          if (name === 'isRequired') {
            if ((ref1 = node.value.object) != null ? ref1.property : void 0) {
              return node.value.object.property.name;
            }
            return null;
          }
          return name;
        }
        if (node.value.type === 'Identifier') {
          return node.value.name;
        }
        return null;
      };
      getPropName = function(node) {
        if (node.type === 'ObjectTypeProperty') {
          // Due to this bug https://github.com/babel/babel-eslint/issues/307
          // we can't get the name of the Flow object key name. So we have
          // to hack around it for now.
          return sourceCode.getFirstToken(node).value;
        }
        return node.key.name;
      };
      validatePropNaming = function(node, proptypes) {
        var component, invalidProps;
        component = components.get(node) || node;
        invalidProps = component.invalidProps || [];
        (proptypes || []).forEach(function(prop) {
          var flowCheck, propKey, regularCheck;
          propKey = getPropKey(prop);
          flowCheck = prop.type === 'ObjectTypeProperty' && prop.value.type === 'BooleanTypeAnnotation' && rule.test(getPropName(prop)) === false;
          regularCheck = propKey && propTypeNames.indexOf(propKey) >= 0 && rule.test(getPropName(prop)) === false;
          if (flowCheck || regularCheck) {
            return invalidProps.push(prop);
          }
        });
        return components.set(node, {invalidProps});
      };
      reportInvalidNaming = function(component) {
        return component.invalidProps.forEach(function(propNode) {
          var propName;
          propName = getPropName(propNode);
          return context.report({
            node: propNode,
            message: config.message || "Prop name ({{ propName }}) doesn't match rule ({{ pattern }})",
            data: {
              component: propName,
              propName,
              pattern: config.rule
            }
          });
        });
      };
      checkPropWrapperArguments = function(node, args) {
        if (!node || !Array.isArray(args)) {
          return;
        }
        return args.filter(function(arg) {
          return arg.type === 'ObjectExpression';
        }).forEach(function(object) {
          return validatePropNaming(node, object.properties);
        });
      };
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        ClassProperty: function(node) {
          var ref, ref1;
          if (!rule || !propsUtil.isPropTypesDeclaration(node)) {
            return;
          }
          if (node.value && node.value.type === 'CallExpression' && propWrapperFunctions.has(sourceCode.getText(node.value.callee))) {
            checkPropWrapperArguments(node, node.value.arguments);
          }
          if ((ref = node.value) != null ? ref.properties : void 0) {
            validatePropNaming(node, node.value.properties);
          }
          if ((ref1 = node.typeAnnotation) != null ? ref1.typeAnnotation : void 0) {
            return validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);
          }
        },
        MemberExpression: function(node) {
          var component, right;
          if (!rule || !propsUtil.isPropTypesDeclaration(node)) {
            return;
          }
          component = utils.getRelatedComponent(node);
          if (!component || !node.parent.right) {
            return;
          }
          ({right} = node.parent);
          if (right.type === 'CallExpression' && propWrapperFunctions.has(sourceCode.getText(right.callee))) {
            checkPropWrapperArguments(component.node, right.arguments);
            return;
          }
          return validatePropNaming(component.node, node.parent.right.properties);
        },
        ObjectExpression: function(node) {
          if (!rule) {
            return;
          }
          // Search for the proptypes declaration
          return node.properties.forEach(function(property) {
            if (!propsUtil.isPropTypesDeclaration(property)) {
              return;
            }
            return validatePropNaming(node, property.value.properties);
          });
        },
        TypeAlias: function(node) {
          // Cache all ObjectType annotations, we will check them at the end
          if (node.right.type === 'ObjectTypeAnnotation') {
            return objectTypeAnnotations.set(node.id.name, node.right);
          }
        },
        'Program:exit': function() {
          var list;
          if (!rule) {
            return;
          }
          list = components.list();
          Object.keys(list).forEach(function(component) {
            var annotation, propType, typeNode;
            // If this is a functional component that uses a global type, check it
            if (list[component].node.type === 'FunctionDeclaration' && list[component].node.params && list[component].node.params.length && list[component].node.params[0].typeAnnotation) {
              typeNode = list[component].node.params[0].typeAnnotation;
              annotation = typeNode.typeAnnotation;
              if (annotation.type === 'GenericTypeAnnotation') {
                propType = objectTypeAnnotations.get(annotation.id.name);
              } else if (annotation.type === 'ObjectTypeAnnotation') {
                propType = annotation;
              }
              if (propType) {
                validatePropNaming(list[component].node, propType.properties);
              }
            }
            if (!has(list, component) || list[component].invalidProps || [].length) {
              return reportInvalidNaming(list[component]);
            }
          });
          // Reset cache
          return objectTypeAnnotations.clear();
        }
      };
    })
  };

}).call(this);
