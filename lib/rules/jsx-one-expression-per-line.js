// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Limit to one expression per line in JSX
   * @author Mark Ivan Allen <Vydia.com>
   */
  'use strict';
  var docsUrl, optionDefaults;

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  optionDefaults = {
    allow: 'none'
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Limit to one expression per line in JSX',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-one-expression-per-line')
      },
      // fixable: 'whitespace'
      schema: [
        {
          type: 'object',
          properties: {
            allow: {
              enum: ['none',
        'literal',
        'single-child']
            }
          },
          default: optionDefaults,
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var handleJSX, nodeDescriptor, nodeKey, options, sourceCode;
      options = {...optionDefaults, ...context.options[0]};
      sourceCode = context.getSourceCode();
      nodeKey = function(node) {
        return `${node.loc.start.line},${node.loc.start.column}`;
      };
      nodeDescriptor = function(n) {
        if (n.openingElement) {
          return n.openingElement.name.name;
        } else {
          return sourceCode.getText(n).replace(/\n/g, '');
        }
      };
      handleJSX = function(node) {
        var children, childrenGroupedByLine, closingElement, closingElementEndLine, closingElementStartLine, fixDetailsByNode, onlyChild, openingElement, openingElementEndLine, openingElementStartLine, ref;
        ({children} = node);
        if (!(children != null ? children.length : void 0)) {
          return;
        }
        openingElement = node.openingElement || node.openingFragment;
        closingElement = node.closingElement || node.closingFragment;
        openingElementStartLine = openingElement.loc.start.line;
        openingElementEndLine = openingElement.loc.end.line;
        closingElementStartLine = closingElement.loc.start.line;
        closingElementEndLine = closingElement.loc.end.line;
        if (children.length === 1) {
          onlyChild = children[0];
          if (openingElementStartLine === openingElementEndLine && openingElementEndLine === closingElementStartLine && closingElementStartLine === closingElementEndLine && closingElementEndLine === onlyChild.loc.start.line && onlyChild.loc.start.line === onlyChild.loc.end.line) {
            if (options.allow === 'single-child' || (options.allow === 'literal' && ((ref = onlyChild.type) === 'Literal' || ref === 'JSXText'))) {
              return;
            }
          }
        }
        childrenGroupedByLine = {};
        fixDetailsByNode = {};
        children.forEach(function(child) {
          var countNewLinesAfterContent, countNewLinesBeforeContent, endLine, raw, ref1, ref2, ref3, startLine;
          countNewLinesBeforeContent = 0;
          countNewLinesAfterContent = 0;
          if ((ref1 = child.type) === 'Literal' || ref1 === 'JSXText') {
            // TODO: this is only necessary b/c JSXFragments aren't currently getting transformed Babel -> espree
            raw = (ref2 = (ref3 = child.extra) != null ? ref3.raw : void 0) != null ? ref2 : child.raw;
            if (/^\s*$/.test(raw)) {
              return;
            }
            countNewLinesBeforeContent = (raw.match(/^ *\n/g) || []).length;
            countNewLinesAfterContent = (raw.match(/\n *$/g) || []).length;
          }
          startLine = child.loc.start.line + countNewLinesBeforeContent;
          endLine = child.loc.end.line - countNewLinesAfterContent;
          // if startLine is endLine TODO: >= is only necessary because of column + 1 in AST I think?
          if (startLine >= endLine) {
            return (childrenGroupedByLine[startLine] != null ? childrenGroupedByLine[startLine] : childrenGroupedByLine[startLine] = []).push(child);
          } else {
            (childrenGroupedByLine[startLine] != null ? childrenGroupedByLine[startLine] : childrenGroupedByLine[startLine] = []).push(child);
            return (childrenGroupedByLine[endLine] != null ? childrenGroupedByLine[endLine] : childrenGroupedByLine[endLine] = []).push(child);
          }
        });
        Object.keys(childrenGroupedByLine).forEach(function(_line) {
          var firstIndex, lastIndex, line;
          line = parseInt(_line, 10);
          firstIndex = 0;
          lastIndex = childrenGroupedByLine[line].length - 1;
          return childrenGroupedByLine[line].forEach(function(child, i) {
            var key, leadingNewLine, leadingSpace, nextChild, prevChild, source, spaceBetweenNext, spaceBetweenPrev, trailingNewLine, trailingSpace;
            if (i === firstIndex) {
              if (line === openingElementEndLine) {
                prevChild = openingElement;
              }
            } else {
              prevChild = childrenGroupedByLine[line][i - 1];
            }
            if (i === lastIndex) {
              if (line === closingElementStartLine) {
                nextChild = closingElement;
              }
            } else {

            }
            // We don't need to append a trailing because the next child will prepend a leading.
            // nextChild = childrenGroupedByLine[line][i + 1];
            spaceBetweenPrev = function() {
              var ref1, ref2;
              return (((ref1 = prevChild.type) === 'Literal' || ref1 === 'JSXText') && / $/.test(prevChild.raw)) || (((ref2 = child.type) === 'Literal' || ref2 === 'JSXText') && /^ /.test(child.raw)) || sourceCode.isSpaceBetweenTokens(prevChild, child);
            };
            spaceBetweenNext = function() {
              var ref1, ref2;
              return (((ref1 = nextChild.type) === 'Literal' || ref1 === 'JSXText') && /^ /.test(nextChild.raw)) || (((ref2 = child.type) === 'Literal' || ref2 === 'JSXText') && / $/.test(child.raw)) || sourceCode.isSpaceBetweenTokens(child, nextChild);
            };
            if (!prevChild && !nextChild) {
              return;
            }
            source = sourceCode.getText(child);
            leadingSpace = !!(prevChild && spaceBetweenPrev());
            trailingSpace = !!(nextChild && spaceBetweenNext());
            leadingNewLine = !!prevChild;
            trailingNewLine = !!nextChild;
            key = nodeKey(child);
            if (!fixDetailsByNode[key]) {
              fixDetailsByNode[key] = {
                node: child,
                source,
                descriptor: nodeDescriptor(child)
              };
            }
            if (leadingSpace) {
              fixDetailsByNode[key].leadingSpace = true;
            }
            if (leadingNewLine) {
              fixDetailsByNode[key].leadingNewLine = true;
            }
            if (trailingNewLine) {
              fixDetailsByNode[key].trailingNewLine = true;
            }
            if (trailingSpace) {
              return fixDetailsByNode[key].trailingSpace = true;
            }
          });
        });
        return Object.keys(fixDetailsByNode).forEach(function(key) {
          var descriptor, details, leadingNewLineString, leadingSpaceString, nodeToReport, replaceText, source, trailingNewLineString, trailingSpaceString;
          details = fixDetailsByNode[key];
          ({
            node: nodeToReport,
            descriptor
          } = details);
          source = details.source.replace(/(^ +| +(?=\n)*$)/g, '');
          leadingSpaceString = details.leadingSpace ? "\n{' '}" : '';
          trailingSpaceString = details.trailingSpace ? "{' '}\n" : '';
          leadingNewLineString = details.leadingNewLine ? '\n' : '';
          trailingNewLineString = details.trailingNewLine ? '\n' : '';
          // eslint-disable-next-line coffee/no-unused-vars
          replaceText = `${leadingSpaceString}${leadingNewLineString}${source}${trailingNewLineString}${trailingSpaceString}`;
          return context.report({
            node: nodeToReport,
            message: `\`${descriptor}\` must be placed on a new line`
          });
        });
      };
      return {
        // fix: (fixer) -> fixer.replaceText nodeToReport, replaceText
        JSXElement: handleJSX,
        JSXFragment: handleJSX
      };
    }
  };

}).call(this);
