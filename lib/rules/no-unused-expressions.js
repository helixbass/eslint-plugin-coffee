// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Flag expressions in statement position that do not side effect
   * @author Michael Ficarra
   */
  'use strict';
  var last;

  ({last} = require('lodash'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow unused expressions',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-unused-expressions'
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowShortCircuit: {
              type: 'boolean'
            },
            // allowTernary: type: 'boolean'
            allowTaggedTemplates: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * @param {ASTNode} node - a Program or BlockStatement node
       * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body
       */
      /**
       * @param {ASTNode} node - any node
       * @param {ASTNode[]} ancestors - the given node's ancestors
       * @returns {boolean} whether the given node is considered a directive in its current position
       */
      /**
       * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.
       * @param {ASTNode} node - any node
       * @returns {boolean} whether the given node is a valid expression
       */
      /**
       * @param {ASTNode} node - any node
       * @returns {boolean} whether the given node structurally represents a directive
       */
      /**
       * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination
       * @param {a[]} list - the input list
       * @returns {a[]} the leading sequence of members in the given list that pass the given predicate
       */
      var allowShortCircuit, allowTaggedTemplates, config, directives, isBlockWhereSequenceIsExpected, isDirective, isValidExpression, looksLikeDirective, shouldTreatAsConditional, takeWhile;
      config = context.options[0] || {};
      allowShortCircuit = config.allowShortCircuit || false;
      // allowTernary = config.allowTernary or no
      allowTaggedTemplates = config.allowTaggedTemplates || false;
      looksLikeDirective = function(node) {
        return node.type === 'ExpressionStatement' && node.expression.type === 'Literal' && typeof node.expression.value === 'string';
      };
      takeWhile = function(predicate, list) {
        var i;
        i = 0;
        while (i < list.length) {
          if (!predicate(list[i])) {
            return list.slice(0, i);
          }
          ++i;
        }
        return list.slice();
      };
      directives = function(node) {
        return takeWhile(looksLikeDirective, node.body);
      };
      isDirective = function(node, ancestors) {
        var grandparent, parent;
        parent = ancestors[ancestors.length - 1];
        grandparent = ancestors[ancestors.length - 2];
        return (parent.type === 'Program' || (parent.type === 'BlockStatement' && /Function/.test(grandparent.type))) && directives(parent).indexOf(node) >= 0;
      };
      shouldTreatAsConditional = function(node) {
        if (node.type === 'ConditionalExpression') {
          return true;
        }
        if (node.type !== 'IfStatement') {
          return false;
        }
        if (node.parent.type === 'Program') {
          return false;
        }
        if (node.parent.type === 'BlockStatement') {
          return shouldTreatAsConditional(node.parent.parent);
        }
        if (node.parent.type === 'IfStatement') {
          return shouldTreatAsConditional(node.parent);
        }
        return true;
      };
      isBlockWhereSequenceIsExpected = function(node) {
        if (node.type !== 'BlockStatement') {
          return;
        }
        if (node.parent.type === 'TemplateLiteral') {
          return true;
        }
        if (shouldTreatAsConditional(node.parent)) {
          return true;
        }
        return false;
      };
      isValidExpression = function(node) {
        if (node.returns) {
          return true;
        }
        if (node.type === 'PassthroughLiteral') {
          return true;
        }
        if (node.parent.type === 'ExpressionStatement' && node.parent === last(node.parent.parent.body) && isBlockWhereSequenceIsExpected(node.parent.parent)) {
          return true;
        }
        if (shouldTreatAsConditional(node)) {
          // if allowTernary
          // Recursive check for ternary and logical expressions
          return isValidExpression(node.consequent) && (!node.alternate || isValidExpression(node.alternate));
        }
        if (allowShortCircuit) {
          if (node.type === 'LogicalExpression') {
            return isValidExpression(node.right);
          }
        }
        if (allowTaggedTemplates && node.type === 'TaggedTemplateExpression') {
          return true;
        }
        // our ConditionalExpression could have statements
        return /^(?:Optional)?(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) || /Statement/.test(node.type) || (node.type === 'UnaryExpression' && ['delete', 'void', 'do'].indexOf(node.operator) >= 0);
      };
      return {
        ExpressionStatement: function(node) {
          if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
            return context.report({
              node,
              message: 'Expected an assignment or function call and instead saw an expression.'
            });
          }
        }
      };
    }
  };

}).call(this);
