// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Disallow redundant return statements
   * @author Teddy Katz
   */
  'use strict';
  /**
   * Checks whether the given return statement is in a `finally` block or not.
   *
   * @param {ASTNode} node - The return statement node to check.
   * @returns {boolean} `true` if the node is in a `finally` block.
   */
  /**
   * Checks whether it can remove the given return statement or not.
   *
   * @param {ASTNode} node - The return statement node to check.
   * @returns {boolean} `true` if the node is removeable.
   */
  var FixTracker, astUtils, isAwaitOrYieldReturn, isInFinally, isRemovable, remove, utils;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  utils = require('../util/ast-utils');

  FixTracker = (function() {
    try {
      return require('eslint/lib/util/fix-tracker');
    } catch (error) {
      return require('eslint/lib/rules/utils/fix-tracker');
    }
  })();

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Removes the given element from the array.
   *
   * @param {Array} array - The source array to remove.
   * @param {any} element - The target item to remove.
   * @returns {void}
   */
  remove = function(array, element) {
    var index;
    index = array.indexOf(element);
    if (index !== -1) {
      return array.splice(index, 1);
    }
  };

  isRemovable = function(node) {
    if (node.parent.type === 'BlockStatement' && node.parent.parent.type === 'IfStatement' && node.parent.body.length === 1 && node === node.parent.body[0]) {
      return false;
    }
    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
  };

  isInFinally = function(node) {
    var currentNode;
    currentNode = node;
    while ((currentNode != null ? currentNode.parent : void 0) && !astUtils.isFunction(currentNode)) {
      if (currentNode.parent.type === 'TryStatement' && currentNode.parent.finalizer === currentNode) {
        return true;
      }
      currentNode = currentNode.parent;
    }
    return false;
  };

  isAwaitOrYieldReturn = function(node) {
    var ref;
    return (ref = node.parent.type) === 'AwaitExpression' || ref === 'YieldExpression';
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow redundant return statements',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-useless-return'
      },
      fixable: 'code',
      schema: []
    },
    create: function(context) {
      /**
       * Collects useless return statements from the given previous segments.
       *
       * A previous segment may be an unreachable segment.
       * In that case, the information object of the unreachable segment is not
       * initialized because `onCodePathSegmentStart` event is not notified for
       * unreachable segments.
       * This goes to the previous segments of the unreachable segment recursively
       * if the unreachable segment was generated by a return statement. Otherwise,
       * this ignores the unreachable segment.
       *
       * This behavior would simulate code paths for the case that the return
       * statement does not exist.
       *
       * @param {ASTNode[]} uselessReturns - The collected return statements.
       * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.
       * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call
       * @returns {ASTNode[]} `uselessReturns`.
       */
      /**
       * Checks whether the given segment is terminated by a return statement or not.
       *
       * @param {CodePathSegment} segment - The segment to check.
       * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
       */
      /**
       * Removes the return statements on the current segments from the useless
       * return statement list.
       *
       * This function will be called at every statement except FunctionDeclaration,
       * BlockStatement, and BreakStatement.
       *
       * - FunctionDeclarations are always executed whether it's returned or not.
       * - BlockStatements do nothing.
       * - BreakStatements go the next merely.
       *
       * @returns {void}
       */
      /**
       * Removes the return statements on the given segment from the useless return
       * statement list.
       *
       * This segment may be an unreachable segment.
       * In that case, the information object of the unreachable segment is not
       * initialized because `onCodePathSegmentStart` event is not notified for
       * unreachable segments.
       * This goes to the previous segments of the unreachable segment recursively
       * if the unreachable segment was generated by a return statement. Otherwise,
       * this ignores the unreachable segment.
       *
       * This behavior would simulate code paths for the case that the return
       * statement does not exist.
       *
       * @param {CodePathSegment} segment - The segment to get return statements.
       * @returns {void}
       */
      var getUselessReturns, isReturned, markReturnStatementsOnCurrentSegmentsAsUsed, markReturnStatementsOnSegmentAsUsed, scopeInfo, segmentInfoMap, usedUnreachableSegments;
      segmentInfoMap = new WeakMap();
      usedUnreachableSegments = new WeakSet();
      scopeInfo = null;
      isReturned = function(segment) {
        var info;
        info = segmentInfoMap.get(segment);
        return !info || info.returned;
      };
      getUselessReturns = function(uselessReturns, prevSegments, providedTraversedSegments) {
        var segment, traversedSegments;
        traversedSegments = providedTraversedSegments || new WeakSet();
        for (segment of prevSegments) {
          if (!segment.reachable) {
            if (!traversedSegments.has(segment)) {
              traversedSegments.add(segment);
              getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
            }
            continue;
          }
          uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);
        }
        return uselessReturns;
      };
      markReturnStatementsOnSegmentAsUsed = function(segment) {
        var info, node, ref;
        if (!segment.reachable) {
          usedUnreachableSegments.add(segment);
          segment.allPrevSegments.filter(isReturned).filter(function(prevSegment) {
            return !usedUnreachableSegments.has(prevSegment);
          }).forEach(markReturnStatementsOnSegmentAsUsed);
          return;
        }
        info = segmentInfoMap.get(segment);
        ref = info.uselessReturns;
        for (node of ref) {
          remove(scopeInfo.uselessReturns, node);
        }
        return info.uselessReturns = [];
      };
      markReturnStatementsOnCurrentSegmentsAsUsed = function() {
        return scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
      };
      return {
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        // Makes and pushs a new scope information.
        onCodePathStart: function(codePath) {
          return scopeInfo = {
            upper: scopeInfo,
            uselessReturns: [],
            codePath
          };
        },
        // Reports useless return statements if exist.
        onCodePathEnd: function() {
          var node, ref;
          ref = scopeInfo.uselessReturns;
          for (node of ref) {
            context.report({
              node,
              loc: node.loc,
              message: 'Unnecessary return statement.',
              // eslint-disable-next-line coffee/no-loop-func
              fix: function(fixer) {
                if (isRemovable(node)) {
                  /*
                   * Extend the replacement range to include the
                   * entire function to avoid conflicting with
                   * no-else-return.
                   * https://github.com/eslint/eslint/issues/8026
                   */
                  return new FixTracker(fixer, context.getSourceCode()).retainEnclosingFunction(node).remove(node);
                }
                return null;
              }
            });
          }
          return scopeInfo = scopeInfo.upper;
        },
        /*
         * Initializes segments.
         * NOTE: This event is notified for only reachable segments.
         */
        onCodePathSegmentStart: function(segment) {
          var info;
          info = {
            uselessReturns: getUselessReturns([], segment.allPrevSegments),
            returned: false
          };
          // Stores the info.
          return segmentInfoMap.set(segment, info);
        },
        // Adds ReturnStatement node to check whether it's useless or not.
        ReturnStatement: function(node) {
          var info, ref, segment;
          if (node.argument) {
            markReturnStatementsOnCurrentSegmentsAsUsed();
          }
          if (node.argument || utils.isInLoop(node) || isInFinally(node) || isAwaitOrYieldReturn(node)) {
            return;
          }
          ref = scopeInfo.codePath.currentSegments;
          for (segment of ref) {
            info = segmentInfoMap.get(segment);
            if (info) {
              info.uselessReturns.push(node);
              info.returned = true;
            }
          }
          return scopeInfo.uselessReturns.push(node);
        },
        /*
         * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
         * Removes return statements of the current segments from the useless return statement list.
         */
        ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        For: markReturnStatementsOnCurrentSegmentsAsUsed,
        IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
      };
    }
  };

}).call(this);
