// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Report missing `key` props in iterators/collection literals.
   * @author Ben Mosher
   */
  'use strict';
  var docsUrl, hasProp;

  hasProp = require('jsx-ast-utils/hasProp');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Report missing `key` props in iterators/collection literals',
        category: 'Possible Errors',
        recommended: true,
        url: docsUrl('jsx-key')
      },
      schema: []
    },
    create: function(context) {
      var checkIteratorElement, getReturnExpression;
      checkIteratorElement = function(node) {
        if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {
          return context.report({
            node,
            message: 'Missing "key" prop for element in iterator'
          });
        }
      };
      getReturnExpression = function(body) {
        var i, item, len, ref;
        for (i = 0, len = body.length; i < len; i++) {
          item = body[i];
          if (item.type === 'ReturnStatement') {
            return item.argument;
          }
          if ((ref = item.expression) != null ? ref.returns : void 0) {
            return item.expression;
          }
        }
        return null;
      };
      return {
        JSXElement: function(node) {
          if (hasProp(node.openingElement.attributes, 'key')) {
            return;
          }
          if (node.parent.type === 'ArrayExpression') {
            return context.report({
              node,
              message: 'Missing "key" prop for element in array'
            });
          }
        },
        // Array.prototype.map
        CallExpression: function(node) {
          var fn, isArrFn, isFn, ref, returnExpression;
          if (node.callee && node.callee.type !== 'MemberExpression') {
            return;
          }
          if (((ref = node.callee) != null ? ref.property : void 0) && node.callee.property.name !== 'map') {
            return;
          }
          fn = node.arguments[0];
          isFn = fn && fn.type === 'FunctionExpression';
          isArrFn = fn && fn.type === 'ArrowFunctionExpression';
          if (isArrFn && fn.body.type === 'JSXElement') {
            checkIteratorElement(fn.body);
          }
          if (isFn || isArrFn) {
            if (fn.body.type === 'BlockStatement') {
              returnExpression = getReturnExpression(fn.body.body);
              if (returnExpression) {
                return checkIteratorElement(returnExpression);
              }
            }
          }
        }
      };
    }
  };

}).call(this);
