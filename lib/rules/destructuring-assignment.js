// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce consistent usage of destructuring assignment of props, state, and context.
   */

  'use strict';
  var Components, DEFAULT_OPTION, docsUrl, isDeclarationAssignment;

  Components = require('../util/react/Components');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  DEFAULT_OPTION = 'always';

  module.exports = {
    meta: {
      docs: {
        description: 'Enforce consistent usage of destructuring assignment of props, state, and context',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('destructuring-assignment')
      },
      schema: [
        {
          type: 'string',
          enum: ['always',
        'never']
        },
        {
          type: 'object',
          properties: {
            ignoreClassFields: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * @param {ASTNode} node We expect either an ArrowFunctionExpression,
       *   FunctionDeclaration, or FunctionExpression
       */
      /**
       * Checks if a prop is being assigned a value props.bar = 'bar'
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean}
       */
      var configuration, handleClassUsage, handleSFCUsage, handleStatelessComponent, ignoreClassFields, isAssignmentToProp, isInClassProperty;
      configuration = context.options[0] || DEFAULT_OPTION;
      ignoreClassFields = (context.options[1] && context.options[1].ignoreClassFields === true) || false;
      isAssignmentToProp = function(node) {
        var ref;
        return ((ref = node.parent) != null ? ref.type : void 0) === 'AssignmentExpression' && node.parent.left === node;
      };
      handleStatelessComponent = function(node) {
        var destructuringContext, destructuringProps, ref, ref1;
        destructuringProps = ((ref = node.params) != null ? ref[0] : void 0) && node.params[0].type === 'ObjectPattern';
        destructuringContext = ((ref1 = node.params) != null ? ref1[1] : void 0) && node.params[1].type === 'ObjectPattern';
        if (destructuringProps && components.get(node) && configuration === 'never') {
          return context.report({
            node,
            message: 'Must never use destructuring props assignment in SFC argument'
          });
        } else if (destructuringContext && components.get(node) && configuration === 'never') {
          return context.report({
            node,
            message: 'Must never use destructuring context assignment in SFC argument'
          });
        }
      };
      handleSFCUsage = function(node) {
        var isPropUsed, ref;
        // props.aProp || context.aProp
        isPropUsed = ((ref = node.object.name) === 'props' || ref === 'context') && !isAssignmentToProp(node);
        if (isPropUsed && configuration === 'always') {
          return context.report({
            node,
            message: `Must use destructuring ${node.object.name} assignment`
          });
        }
      };
      isInClassProperty = function(node) {
        var curNode;
        curNode = node.parent;
        while (curNode) {
          if (curNode.type === 'ClassProperty') {
            return true;
          }
          curNode = curNode.parent;
        }
        return false;
      };
      handleClassUsage = function(node) {
        var isPropUsed, ref;
        // this.props.Aprop || this.context.aProp || this.state.aState
        isPropUsed = node.object.type === 'MemberExpression' && node.object.object.type === 'ThisExpression' && ((ref = node.object.property.name) === 'props' || ref === 'context' || ref === 'state') && !isAssignmentToProp(node);
        if (isPropUsed && configuration === 'always' && !(ignoreClassFields && isInClassProperty(node))) {
          return context.report({
            node,
            message: `Must use destructuring ${node.object.property.name} assignment`
          });
        }
      };
      return {
        FunctionDeclaration: handleStatelessComponent,
        ArrowFunctionExpression: handleStatelessComponent,
        FunctionExpression: handleStatelessComponent,
        MemberExpression: function(node) {
          var SFCComponent, classComponent;
          SFCComponent = components.get(context.getScope(node).block);
          classComponent = utils.getParentComponent(node);
          if (SFCComponent) {
            handleSFCUsage(node);
          }
          if (classComponent) {
            return handleClassUsage(node, classComponent);
          }
        },
        VariableDeclarator: function(node) {
          var SFCComponent, classComponent, destructuring, destructuringClass, destructuringSFC, ref, ref1;
          classComponent = utils.getParentComponent(node);
          SFCComponent = components.get(context.getScope(node).block);
          destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
          // let {foo} = props;
          destructuringSFC = destructuring && ((ref = node.init.name) === 'props' || ref === 'context');
          // let {foo} = this.props;
          destructuringClass = destructuring && node.init.object && node.init.object.type === 'ThisExpression' && ((ref1 = node.init.property.name) === 'props' || ref1 === 'context' || ref1 === 'state');
          if (SFCComponent && destructuringSFC && configuration === 'never') {
            context.report({
              node,
              message: `Must never use destructuring ${node.init.name} assignment`
            });
          }
          if (classComponent && destructuringClass && configuration === 'never' && !(ignoreClassFields && node.parent.type === 'ClassProperty')) {
            return context.report({
              node,
              message: `Must never use destructuring ${node.init.property.name} assignment`
            });
          }
        },
        AssignmentExpression: function(node) {
          var SFCComponent, classComponent, destructuring, destructuringClass, destructuringSFC, left, ref, ref1, ref2, right;
          if (!isDeclarationAssignment(node)) {
            return;
          }
          ({left, right} = node);
          classComponent = utils.getParentComponent(node);
          SFCComponent = components.get(context.getScope(node).block);
          destructuring = left.type === 'ObjectPattern';
          // let {foo} = props;
          destructuringSFC = destructuring && ((ref = right.name) === 'props' || ref === 'context');
          // let {foo} = this.props;
          destructuringClass = destructuring && ((ref1 = right.object) != null ? ref1.type : void 0) === 'ThisExpression' && ((ref2 = right.property.name) === 'props' || ref2 === 'context' || ref2 === 'state');
          if (SFCComponent && destructuringSFC && configuration === 'never') {
            context.report({
              node,
              message: `Must never use destructuring ${right.name} assignment`
            });
          }
          if (classComponent && destructuringClass && configuration === 'never' && !(ignoreClassFields && node.parent.type === 'ClassProperty')) {
            return context.report({
              node,
              message: `Must never use destructuring ${right.property.name} assignment`
            });
          }
        }
      };
    })
  };

}).call(this);
