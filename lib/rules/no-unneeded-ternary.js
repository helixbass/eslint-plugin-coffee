// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag no-unneeded-ternary
   * @author Gyandeep Singh
   */
  'use strict';
  var BOOLEAN_OPERATORS, OPERATOR_INVERSES, astUtils;

  astUtils = require('../eslint-ast-utils');

  // Operators that always result in a boolean value
  BOOLEAN_OPERATORS = new Set(['==', 'is', '!=', 'isnt', '>', '>=', '<', '<=', 'in', 'not in', 'of', 'not of', 'instanceof']);

  OPERATOR_INVERSES = {
    '==': '!=',
    '!=': '==',
    is: 'isnt',
    isnt: 'is'
  };

  // Operators like < and >= are not true inverses, since both will return false with NaN.

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow ternary operators when simpler alternatives exist',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-unneeded-ternary'
      },
      schema: [
        {
          type: 'object',
          properties: {
            defaultAssignment: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Creates an expression that represents the boolean inverse of the expression represented by the original node
       * @param {ASTNode} node A node representing an expression
       * @returns {string} A string representing an inverted expression
       */
      /**
       * Tests if a given node always evaluates to a boolean value
       * @param {ASTNode} node - An expression node
       * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value
       */
      /**
       * Test if the node is a boolean literal
       * @param {ASTNode} node - The node to report.
       * @returns {boolean} True if the its a boolean literal
       * @private
       */
      /**
       * Test if the node matches the pattern id ? id : expression
       * @param {ASTNode} node - The ConditionalExpression to check.
       * @returns {boolean} True if the pattern is matched, and false otherwise
       * @private
       */
      var checkConditional, defaultAssignment, getLoneExpression, invertExpression, isBooleanExpression, isBooleanLiteral, justIdentifierName, matchesDefaultAssignment, options, sourceCode;
      options = context.options[0] || {};
      defaultAssignment = options.defaultAssignment !== false;
      sourceCode = context.getSourceCode();
      isBooleanLiteral = function(node) {
        return node && node.type === 'Literal' && typeof node.value === 'boolean';
      };
      invertExpression = function(node) {
        var operatorToken, text;
        if (node.type === 'BinaryExpression' && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
          operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, function(token) {
            return token.value === node.operator;
          });
          text = sourceCode.getText();
          return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
        }
        if (astUtils.getPrecedence(node) < astUtils.getPrecedence({
          type: 'UnaryExpression'
        })) {
          return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
        }
        if (node.type === 'UnaryExpression' && node.operator === 'not') {
          return `!!${astUtils.getParenthesisedText(sourceCode, node.argument)}`;
        }
        return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
      };
      isBooleanExpression = function(node) {
        var ref;
        return (node.type === 'BinaryExpression' && BOOLEAN_OPERATORS.has(node.operator)) || (node.type === 'UnaryExpression' && ((ref = node.operator) === '!' || ref === 'not'));
      };
      getLoneExpression = function(node) {
        if (!(node.type === 'BlockStatement' && node.body.length === 1 && node.body[0].type === 'ExpressionStatement')) {
          return node;
        }
        return node.body[0].expression;
      };
      justIdentifierName = function(node) {
        var expression;
        expression = getLoneExpression(node);
        if (expression.type !== 'Identifier') {
          return;
        }
        return expression.name;
      };
      matchesDefaultAssignment = function(node) {
        var consequentIdentifierName, testIdentifierName;
        if (!node.alternate) {
          return;
        }
        if (!(testIdentifierName = justIdentifierName(node.test))) {
          return;
        }
        if (!(consequentIdentifierName = justIdentifierName(node.consequent))) {
          return;
        }
        return testIdentifierName === consequentIdentifierName;
      };
      checkConditional = function(node) {
        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
          return context.report({
            node,
            loc: node.consequent.loc.start,
            message: 'Unnecessary use of boolean literals in conditional expression.',
            fix: function(fixer) {
              if (node.consequent.value === node.alternate.value) {
                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`
                return (node.test.type === 'Identifier' ? fixer.replaceText(node, node.consequent.name) : null);
              }
              if ((!node.inverted && node.alternate.value) || (node.inverted && !node.alternate.value)) {
                // Replace `foo() ? false : true` with `!(foo())`
                return fixer.replaceText(node, invertExpression(node.test));
              }
              // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.
              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
            }
          });
        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
          return context.report({
            node,
            loc: node.consequent.loc.start,
            message: 'Unnecessary use of conditional expression for default assignment.',
            fix: function(fixer) {
              var alternate, isAlternateParenthesised, nodeAlternate, ref;
              alternate = getLoneExpression(node.alternate);
              nodeAlternate = astUtils.getParenthesisedText(sourceCode, alternate);
              if ((ref = alternate.type) === 'ConditionalExpression' || ref === 'IfStatement' || ref === 'YieldExpression') {
                isAlternateParenthesised = astUtils.isParenthesised(sourceCode, alternate);
                nodeAlternate = isAlternateParenthesised ? nodeAlternate : `(${nodeAlternate})`;
              }
              return fixer.replaceText(node, `${astUtils.getParenthesisedText(sourceCode, node.test)} or ${nodeAlternate}`);
            }
          });
        }
      };
      return {
        ConditionalExpression: checkConditional,
        IfStatement: checkConditional
      };
    }
  };

}).call(this);
