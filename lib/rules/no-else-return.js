// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag `else` after a `return` in `if`
   * @author Ian Christian Myers
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------

  // astUtils = require '../eslint-ast-utils'

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow `else` blocks after `return` statements in `if` statements',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-else-return'
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowElseIf: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      // fixable: 'code'
      messages: {
        unexpected: "Unnecessary 'else' after 'return'."
      }
    },
    create: function(context) {
      /**
       * Check whether a node returns in every codepath.
       * @param {Node} node The node to be checked
       * @returns {boolean} `true` if it returns on every codepath.
       */
      /**
       * If the consequent is an IfStatement, check to see if it has an else
       * and both its consequent and alternate path return, meaning this is
       * a nested case of rule violation.  If-Else not considered currently.
       *
       * @param {Node} node The consequent node
       * @returns {boolean} True if this is a nested rule violation
       */
      /**
       * Check to see if the node is a ReturnStatement
       *
       * @param {Node} node The node being evaluated
       * @returns {boolean} True if node is a return
       */
      /**
       * Check the consequent/body node to make sure it is not
       * a ReturnStatement or an IfStatement that returns on both
       * code paths.
       *
       * @param {Node} node The consequent or body node
       * @param {Node} alternate The alternate node
       * @returns {boolean} `true` if it is a Return/If node that always returns.
       */
      /**
       * Check the if statement
       * @returns {void}
       * @param {Node} node The node for the if statement to check
       * @private
       */
      /**
       * Check the if statement, but don't catch else-if blocks.
       * @returns {void}
       * @param {Node} node The node for the if statement to check
       * @private
       */
      /**
       * Check to see if the node is valid for evaluation,
       * meaning it has an else.
       *
       * @param {Node} node The node being evaluated
       * @returns {boolean} True if the node is valid
       */
      /**
       * Naive return checking, does not iterate through the whole
       * BlockStatement because we make the assumption that the ReturnStatement
       * will be the last node in the body of the BlockStatement.
       *
       * @param {Node} node The consequent/alternate node
       * @returns {boolean} True if it has a return
       */
      var allowElseIf, alwaysReturns, checkForIf, checkForReturn, checkForReturnOrIf, checkIfWithElse, checkIfWithoutElse, displayReport, hasElse, isNested, naiveHasReturn, sourceCode;
      sourceCode = context.getSourceCode();
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Display the context report if rule is violated
       *
       * @param {Node} node The 'else' node
       * @returns {void}
       */
      displayReport = function(node) {
        return context.report({
          node,
          messageId: 'unexpected'
        });
      };
      checkForReturn = function(node) {
        return node.type === 'ReturnStatement';
      };
      naiveHasReturn = function(node) {
        var body, lastChildNode;
        if (node.type === 'BlockStatement') {
          ({body} = node);
          lastChildNode = body[body.length - 1];
          return lastChildNode && checkForReturn(lastChildNode);
        }
        return checkForReturn(node);
      };
      hasElse = function(node) {
        return node.alternate && node.consequent;
      };
      checkForIf = function(node) {
        return node.type === 'IfStatement' && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
      };
      checkForReturnOrIf = function(node) {
        return checkForReturn(node) || checkForIf(node);
      };
      alwaysReturns = function(node) {
        if (node.type === 'BlockStatement') {
          // If we have a BlockStatement, check each consequent body node.
          return node.body.some(checkForReturnOrIf);
        }
        /*
         * If not a block statement, make sure the consequent isn't a
         * ReturnStatement or an IfStatement with returns on both paths.
         */
        return checkForReturnOrIf(node);
      };
      isNested = function(childIf) {
        var elseToken;
        elseToken = sourceCode.getTokenBefore(childIf, {
          filter: function({value}) {
            return value === 'else';
          }
        });
        if (!elseToken) {
          return true;
        }
        return elseToken.loc.start.line < childIf.loc.start.line;
      };
      checkIfWithoutElse = function(node) {
        var alternate, consequents, currentNode, parent;
        ({parent} = node);
        /*
         * Fixing this would require splitting one statement into two, so no error should
         * be reported if this node is in a position where only one statement is allowed.
         */
        // return unless astUtils.STATEMENT_LIST_PARENTS.has parent.type
        if (parent.type === 'IfStatement' && node === parent.alternate && !isNested(node)) {
          return;
        }
        consequents = [];
        currentNode = node;
        while (currentNode.type === 'IfStatement' && !(currentNode !== node && isNested(currentNode))) {
          if (!currentNode.alternate) {
            return;
          }
          consequents.push(currentNode.consequent);
          ({alternate} = currentNode);
          currentNode = currentNode.alternate;
        }
        if (consequents.every(alwaysReturns)) {
          return displayReport(alternate);
        }
      };
      checkIfWithElse = function(node) {
        var alternate;
        ({alternate} = node);
        /*
         * Fixing this would require splitting one statement into two, so no error should
         * be reported if this node is in a position where only one statement is allowed.
         */
        // return unless astUtils.STATEMENT_LIST_PARENTS.has parent.type
        if (alternate && alwaysReturns(node.consequent)) {
          return displayReport(alternate);
        }
      };
      allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);
      return {
        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------
        'IfStatement:exit': allowElseIf ? checkIfWithoutElse : checkIfWithElse
      };
    }
  };

}).call(this);
