// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule that warns when identifier names are shorter or longer
   * than the values provided in configuration.
   * @author Burak Yigit Kaya aka BYK
   */
  'use strict';
  var indexOf = [].indexOf;

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce minimum and maximum identifier lengths',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/id-length'
      },
      schema: [
        {
          type: 'object',
          properties: {
            min: {
              type: 'number'
            },
            max: {
              type: 'number'
            },
            exceptions: {
              type: 'array',
              uniqueItems: true,
              items: {
                type: 'string'
              }
            },
            properties: {
              enum: ['always',
        'never']
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var exceptions, isSupportedExpression, maxLength, minLength, options, properties, ref, ref1;
      options = context.options[0] || {};
      minLength = (ref = options.min) != null ? ref : 2;
      maxLength = (ref1 = options.max) != null ? ref1 : 2e308;
      properties = options.properties !== 'never';
      exceptions = (options.exceptions ? options.exceptions : []).reduce(function(obj, item) {
        obj[item] = true;
        return obj;
      }, {});
      isSupportedExpression = function(node, parent) {
        var assigningToMemberExpression, currentNode, prevNode;
        prevNode = node;
        currentNode = parent;
        while (currentNode != null) {
          switch (currentNode.type) {
            case 'MemberExpression':
              if (prevNode !== currentNode.property) {
                return false;
              }
              if (!properties) {
                return false;
              }
              if (currentNode.computed) {
                return false;
              }
              assigningToMemberExpression = true;
              break;
            case 'AssignmentPattern':
              if (prevNode !== currentNode.left) {
                return false;
              }
              break;
            case 'ObjectPattern':
            case 'ArrayPattern':
              break;
            case 'ObjectExpression':
              return currentNode.parent.type === 'AssignmentExpression';
            // when 'VariableDeclarator'
            //   (parent, node) -> parent.id is node
            case 'AssignmentExpression':
              if (prevNode !== currentNode.left) {
                return false;
              }
              if (assigningToMemberExpression) {
                return true;
              }
              if (node.declaration) {
                return true;
              }
              return false;
            case 'Property':
              if (currentNode.parent.type === 'ObjectExpression') {
                if (!properties) {
                  return false;
                }
              }
              if (!(prevNode === currentNode[currentNode.parent.type === 'ObjectPattern' ? 'value' : 'key'])) {
                return false;
              }
              break;
            case 'ClassDeclaration':
              return prevNode === currentNode.id;
            case 'FunctionDeclaration':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
              return prevNode === currentNode.id || indexOf.call(currentNode.params, prevNode) >= 0;
            case 'MethodDefinition':
              return prevNode === currentNode.key && !currentNode.computed;
            case 'CatchClause':
              return prevNode === currentNode.param;
            case 'ImportDefaultSpecifier':
            case 'RestElement':
              return true;
            default:
              if (node.declaration) {
                return true;
              }
              return false;
          }
          prevNode = currentNode;
          currentNode = currentNode.parent;
        }
      };
      return {
        Identifier: function(node) {
          var isLong, isShort, isValidExpression, name, parent;
          ({name, parent} = node);
          isShort = name.length < minLength;
          isLong = name.length > maxLength;
          if (!(isShort || isLong) || exceptions[name]) {
            return;
          }
          isValidExpression = isSupportedExpression(node, parent);
          if (isValidExpression) {
            return context.report({
              node,
              message: isShort ? "Identifier name '{{name}}' is too short (< {{min}})." : "Identifier name '{{name}}' is too long (> {{max}}).",
              data: {
                name,
                min: minLength,
                max: maxLength
              }
            });
          }
        }
      };
    }
  };

}).call(this);
