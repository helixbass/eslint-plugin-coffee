// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent definitions of unused prop types
   * @author Evgueni Naverniouk
   */
  'use strict';
  var ASYNC_SAFE_LIFE_CYCLE_METHODS, Components, DIRECT_NEXT_PROPS_REGEX, DIRECT_PREV_PROPS_REGEX, DIRECT_PROPS_REGEX, LIFE_CYCLE_METHODS, astUtil, docsUrl, versionUtil,
    hasProp = {}.hasOwnProperty;

  // As for exceptions for props.children or props.className (and alike) look at
  // https://github.com/yannickcr/eslint-plugin-react/issues/7
  Components = require('../util/react/Components');

  astUtil = require('../util/react/ast');

  versionUtil = require('eslint-plugin-react/lib/util/version');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Constants
  // ------------------------------------------------------------------------------
  DIRECT_PROPS_REGEX = /^props\s*(\.|\[)/;

  DIRECT_NEXT_PROPS_REGEX = /^nextProps\s*(\.|\[)/;

  DIRECT_PREV_PROPS_REGEX = /^prevProps\s*(\.|\[)/;

  LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];

  ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Prevent definitions of unused prop types',
        category: 'Best Practices',
        recommended: false,
        url: docsUrl('no-unused-prop-types')
      },
      schema: [
        {
          type: 'object',
          properties: {
            customValidators: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            skipShapeProps: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Retrieve the name of a key node
       * @param {ASTNode} node The AST node with the key.
       * @return {string} the name of the key
       */
      /**
       * Retrieve the name of a property node
       * @param {ASTNode} node The AST node with the property.
       * @return {string} the name of the property or undefined if not found
       */
      /**
       * Handle both stateless functions and setState updater functions.
       * @param {ASTNode} node We expect either an ArrowFunctionExpression,
       *   FunctionDeclaration, or FunctionExpression
       */
      /**
       * Checks if the prop has spread operator.
       * @param {ASTNode} node The AST node being marked.
       * @returns {Boolean} True if the prop has spread operator, false if not.
       */
      /**
       * Check if we are in a class constructor
       * @return {boolean} true if we are in a class constructor, false if not
       */
      /**
       * Check if we are in a lifecycle method
       * @return {boolean} true if we are in a class constructor, false if not
       */
      /**
       * Check if the current node is in a setState updater method
       * @return {boolean} true if we are in a setState updater, false if not
       */
      /**
       * Returns true if the given node is inside a React Component lifecycle
       * method.
       * @param {ASTNode} node The AST node being checked.
       * @return {Boolean} True if the node is inside a lifecycle method
       */
      /**
       * Returns true if the given node is a React Component lifecycle method
       * @param {ASTNode} node The AST node being checked.
       * @return {Boolean} True if the node is a lifecycle method
       */
      /**
       * Checks if a prop init name matches common naming patterns
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if the prop name matches
       */
      /**
       * Checks if we are using a prop
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if we are using a prop, false if not.
       */
      /**
       * Checks if a prop is used
       * @param {ASTNode} node The AST node being checked.
       * @param {Object} prop Declared prop object
       * @returns {Boolean} True if the prop is used, false if not.
       */
      /**
       * @param {ASTNode} node We expect either an ArrowFunctionExpression,
       *   FunctionDeclaration, or FunctionExpression
       */
      /**
       * Mark a prop type as used
       * @param {ASTNode} node The AST node being marked.
       */
      /**
       * Checks if the component must be validated
       * @param {Object} component The component to process
       * @returns {Boolean} True if the component must be validated, false if not.
       */
      /**
       * Used to recursively loop through each declared prop type
       * @param {Object} component The component to process
       * @param {Array} props List of props to validate
       */
      /**
       * Reports unused proptypes for a given component
       * @param {Object} component The component to process
       */
      /**
       * Removes quotes from around an identifier.
       * @param {string} the identifier to strip
       */
      var UNUSED_MESSAGE, checkAsyncSafeLifeCycles, configuration, defaults, getKeyValue, getPropertyName, handleCustomValidators, handleFunctionLikeExpressions, handleSetStateUpdater, hasSpreadOperator, inConstructor, inLifeCycleMethod, inSetStateUpdater, isInLifeCycleMethod, isNodeALifeCycleMethod, isPropArgumentInSetStateUpdater, isPropAttributeName, isPropTypesUsage, isPropUsed, markDestructuredFunctionArgumentsAsUsed, markPropTypesAsUsed, mustBeValidated, reportUnusedPropType, reportUnusedPropTypes, sourceCode, stripQuotes;
      sourceCode = context.getSourceCode();
      checkAsyncSafeLifeCycles = versionUtil.testReactVersion(context, '16.3.0');
      defaults = {
        skipShapeProps: true,
        customValidators: []
      };
      configuration = {...defaults, ...(context.options[0] || {})};
      UNUSED_MESSAGE = "'{{name}}' PropType is defined but prop is never used"; 
      inLifeCycleMethod = function() {
        var name, ref, ref1, scope;
        scope = context.getScope();
        while (scope) {
          if ((ref = scope.block) != null ? (ref1 = ref.parent) != null ? ref1.key : void 0 : void 0) {
            ({name} = scope.block.parent.key);
            if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
              return true;
            }
            if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {
              return true;
            }
          }
          scope = scope.upper;
        }
        return false;
      };
      inSetStateUpdater = function() {
        var ref, ref1, ref2, scope;
        scope = context.getScope();
        while (scope) {
          // Make sure we are in the updater not the callback
          if (((ref = scope.block) != null ? (ref1 = ref.parent) != null ? ref1.type : void 0 : void 0) === 'CallExpression' && ((ref2 = scope.block.parent.callee.property) != null ? ref2.name : void 0) === 'setState' && scope.block.parent.arguments[0].start === scope.block.start) {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      isPropArgumentInSetStateUpdater = function(node) {
        var ref, scope;
        scope = context.getScope();
        while (scope) {
          // Make sure we are in the updater not the callback
          if (((ref = scope.block) != null ? ref.parent : void 0) && scope.block.parent.type === 'CallExpression' && scope.block.parent.callee.property && scope.block.parent.callee.property.name === 'setState' && scope.block.parent.arguments[0].start === scope.block.start && scope.block.parent.arguments[0].params && scope.block.parent.arguments[0].params.length > 1) {
            return scope.block.parent.arguments[0].params[1].name === node.object.name;
          }
          scope = scope.upper;
        }
        return false;
      };
      isPropTypesUsage = function(node) {
        var isClassUsage, isStatelessFunctionUsage;
        isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && ((node.object.type === 'ThisExpression' && node.property.name === 'props') || isPropArgumentInSetStateUpdater(node));
        isStatelessFunctionUsage = node.object.name === 'props';
        return isClassUsage || isStatelessFunctionUsage || inLifeCycleMethod();
      };
      mustBeValidated = function(component) {
        return Boolean(component && !component.ignoreUnusedPropTypesValidation);
      };
      isNodeALifeCycleMethod = function(node) {
        var nodeKeyName, ref;
        nodeKeyName = (ref = node.key) != null ? ref.name : void 0;
        if (node.kind === 'constructor') {
          return true;
        }
        if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
          return true;
        }
        if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {
          return true;
        }
        return false;
      };
      isInLifeCycleMethod = function(node) {
        var ref;
        if (((ref = node.type) === 'MethodDefinition' || ref === 'Property') && isNodeALifeCycleMethod(node)) {
          return true;
        }
        if (node.parent) {
          return isInLifeCycleMethod(node.parent);
        }
        return false;
      };
      isPropAttributeName = function(node) {
        var ref, ref1;
        return (ref = ((ref1 = node.init) != null ? ref1 : node.right).name) === 'props' || ref === 'nextProps' || ref === 'prevProps';
      };
      isPropUsed = function(node, prop) {
        var i, l, usedProp, usedPropTypes;
        usedPropTypes = node.usedPropTypes || [];
        i = 0;
        l = usedPropTypes.length;
        while (i < l) {
          usedProp = usedPropTypes[i];
          if (prop.type === 'shape' || prop.name === '__ANY_KEY__' || usedProp.name === prop.name) {
            return true;
          }
          i++;
        }
        return false;
      };
      hasSpreadOperator = function(node) {
        var tokens;
        tokens = sourceCode.getTokens(node);
        return tokens.length && tokens[0].value === '...';
      };
      stripQuotes = function(string) {
        return string.replace(/^'|'$/g, '');
      };
      getKeyValue = function(node) {
        var key, ref, tokens;
        if (node.type === 'ObjectTypeProperty') {
          tokens = context.getFirstTokens(node, 2);
          return ((ref = tokens[0].value) === '+' || ref === '-' ? tokens[1].value : stripQuotes(tokens[0].value));
        }
        key = node.key || node.argument;
        if (key.type === 'Identifier') {
          return key.name;
        } else {
          return key.value;
        }
      };
      inConstructor = function() {
        var ref, scope;
        scope = context.getScope();
        while (scope) {
          if (((ref = scope.block) != null ? ref.parent : void 0) && scope.block.parent.kind === 'constructor') {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      getPropertyName = function(node) {
        var isDirectNextProp, isDirectPrevProp, isDirectProp, isDirectSetStateProp, isInClassComponent, isNotInConstructor, isNotInLifeCycleMethod, isNotInSetStateUpdater, property;
        isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
        isDirectNextProp = DIRECT_NEXT_PROPS_REGEX.test(sourceCode.getText(node));
        isDirectPrevProp = DIRECT_PREV_PROPS_REGEX.test(sourceCode.getText(node));
        isDirectSetStateProp = isPropArgumentInSetStateUpdater(node);
        isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
        isNotInConstructor = !inConstructor(node);
        isNotInLifeCycleMethod = !inLifeCycleMethod();
        isNotInSetStateUpdater = !inSetStateUpdater();
        if ((isDirectProp || isDirectNextProp || isDirectPrevProp || isDirectSetStateProp) && isInClassComponent && isNotInConstructor && isNotInLifeCycleMethod && isNotInSetStateUpdater) {
          return void 0;
        }
        if (!isDirectProp && !isDirectNextProp && !isDirectPrevProp && !isDirectSetStateProp) {
          node = node.parent;
        }
        ({property} = node);
        if (property) {
          switch (property.type) {
            case 'Identifier':
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
              return property.name;
            case 'MemberExpression':
              return void 0;
            case 'Literal':
              if (typeof property.value === 'string') {
                // Accept computed properties that are literal strings
                return property.value;
              }
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
              break;
            default:
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
          }
        }
        return void 0;
      };
      markPropTypesAsUsed = function(node, parentNames) {
        var allNames, component, currentNode, genericDestructuring, ignoreUnusedPropTypesValidation, j, k, left, len, len1, name, propName, properties, property, ref, ref1, ref2, ref3, ref4, ref5, ref6, thisDestructuring, type, usedPropTypes;
        parentNames || (parentNames = []);
        switch (node.type) {
          case 'MemberExpression':
            name = getPropertyName(node);
            if (name) {
              allNames = parentNames.concat(name);
              if (node.parent.type === 'MemberExpression') {
                markPropTypesAsUsed(node.parent, allNames);
              }
              // Do not mark computed props as used.
              type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
            } else {
              left = (ref = node.parent.id) != null ? ref : node.parent.left;
              if ((left != null ? (ref1 = left.properties) != null ? ref1.length : void 0 : void 0) && getKeyValue(left.properties[0])) {
                type = 'destructuring';
                ({properties} = left);
              }
            }
            break;
          case 'ArrowFunctionExpression':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
            if (!node.params.length) {
              break;
            }
            type = 'destructuring';
            ({properties} = node.params[0]);
            if (inSetStateUpdater()) {
              ({properties} = (ref2 = node.params[1]) != null ? ref2 : {});
            }
            break;
          case 'VariableDeclarator':
          case 'AssignmentExpression':
            left = (ref3 = node.id) != null ? ref3 : node.left;
            ref4 = left.properties;
            // let {props: {firstname}} = this
            // let {firstname} = props
            for (j = 0, len = ref4.length; j < len; j++) {
              property = ref4[j];
              thisDestructuring = property.key && ((property.key.name === 'props' || property.key.value === 'props') && property.value.type === 'ObjectPattern');
              genericDestructuring = isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));
              if (thisDestructuring) {
                ({properties} = property.value);
              } else if (genericDestructuring) {
                ({properties} = left);
              } else {
                continue;
              }
              type = 'destructuring';
            }
            break;
          default:
            throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);
        }
        component = components.get(utils.getParentComponent());
        usedPropTypes = (component != null ? component.usedPropTypes : void 0) || [];
        ignoreUnusedPropTypesValidation = (component != null ? component.ignoreUnusedPropTypesValidation : void 0) || false;
        switch (type) {
          case 'direct':
            if (Object.prototype[name]) {
              // Ignore Object methods
              break;
            }
            usedPropTypes.push({name, allNames});
            break;
          case 'destructuring':
            ref5 = properties || [];
            for (k = 0, len1 = ref5.length; k < len1; k++) {
              property = ref5[k];
              if (hasSpreadOperator(property) || property.computed) {
                ignoreUnusedPropTypesValidation = true;
              }
              propName = getKeyValue(property);
              currentNode = node;
              allNames = [];
              while (currentNode.property && currentNode.property.name !== 'props') {
                allNames.unshift(currentNode.property.name);
                currentNode = currentNode.object;
              }
              allNames.push(propName);
              if (propName) {
                usedPropTypes.push({
                  allNames,
                  name: propName
                });
              }
            }
        }
        return components.set((ref6 = component != null ? component.node : void 0) != null ? ref6 : node, {usedPropTypes, ignoreUnusedPropTypesValidation});
      };
      reportUnusedPropType = function(component, props) {
        // Skip props that check instances
        if (props === true) {
          return;
        }
        return Object.keys(props || {}).forEach(function(key) {
          var prop;
          prop = props[key];
          // Skip props that check instances
          if (prop === true) {
            return;
          }
          if (prop.type === 'shape' && configuration.skipShapeProps) {
            return;
          }
          if (prop.node && !isPropUsed(component, prop)) {
            context.report(prop.node, UNUSED_MESSAGE, {
              name: prop.fullName
            });
          }
          if (prop.children) {
            return reportUnusedPropType(component, prop.children);
          }
        });
      };
      reportUnusedPropTypes = function(component) {
        return reportUnusedPropType(component, component.declaredPropTypes);
      };
      markDestructuredFunctionArgumentsAsUsed = function(node) {
        var destructuring, ref, ref1;
        destructuring = ((ref = node.params) != null ? (ref1 = ref[0]) != null ? ref1.type : void 0 : void 0) === 'ObjectPattern';
        if (destructuring && components.get(node)) {
          return markPropTypesAsUsed(node);
        }
      };
      handleSetStateUpdater = function(node) {
        var ref;
        if (!(((ref = node.params) != null ? ref.length : void 0) >= 2 && inSetStateUpdater())) {
          return;
        }
        return markPropTypesAsUsed(node);
      };
      handleFunctionLikeExpressions = function(node) {
        handleSetStateUpdater(node);
        return markDestructuredFunctionArgumentsAsUsed(node);
      };
      handleCustomValidators = function(component) {
        var propTypes;
        propTypes = component.declaredPropTypes;
        if (!propTypes) {
          return;
        }
        return Object.keys(propTypes).forEach(function(key) {
          var node;
          ({node} = propTypes[key]);
          if (astUtil.isFunctionLikeExpression(node)) {
            return markPropTypesAsUsed(node);
          }
        });
      };
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        VariableDeclarator: function(node) {
          var destructuring, statelessDestructuring, thisDestructuring;
          destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
          // let {props: {firstname}} = this
          thisDestructuring = destructuring && node.init.type === 'ThisExpression';
          // let {firstname} = props
          statelessDestructuring = destructuring && isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));
          if (!thisDestructuring && !statelessDestructuring) {
            return;
          }
          return markPropTypesAsUsed(node);
        },
        AssignmentExpression: function(node) {
          var destructuring, statelessDestructuring, thisDestructuring;
          destructuring = node.left.type === 'ObjectPattern';
          // let {props: {firstname}} = this
          thisDestructuring = destructuring && node.right.type === 'ThisExpression';
          // let {firstname} = props
          statelessDestructuring = destructuring && isPropAttributeName(node) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node));
          if (!(thisDestructuring || statelessDestructuring)) {
            return;
          }
          return markPropTypesAsUsed(node);
        },
        FunctionDeclaration: handleFunctionLikeExpressions,
        ArrowFunctionExpression: handleFunctionLikeExpressions,
        FunctionExpression: handleFunctionLikeExpressions,
        MemberExpression: function(node) {
          if (isPropTypesUsage(node)) {
            return markPropTypesAsUsed(node);
          }
        },
        ObjectPattern: function(node) {
          // If the object pattern is a destructured props object in a lifecycle
          // method -- mark it for used props.
          if (isNodeALifeCycleMethod(node.parent.parent)) {
            return node.properties.forEach(function(property, i) {
              if (i === 0) {
                return markPropTypesAsUsed(node.parent);
              }
            });
          }
        },
        'Program:exit': function() {
          var _, component, list, results;
          list = components.list();
          results = [];
          for (_ in list) {
            if (!hasProp.call(list, _)) continue;
            component = list[_];
            if (!(mustBeValidated(component))) {
              continue;
            }
            handleCustomValidators(component);
            results.push(reportUnusedPropTypes(component));
          }
          return results;
        }
      };
    })
  };

}).call(this);
