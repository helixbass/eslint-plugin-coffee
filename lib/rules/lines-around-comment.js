// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforces empty lines around comments.
   * @author Jamund Ferguson
   */
  'use strict';
  /**
   * Return an array with with any line numbers that contain comments.
   * @param {Array} comments An array of comment tokens.
   * @returns {Array} An array of line numbers.
   */
  var astUtils, getCommentLineNums, getEmptyLineNums, lodash;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  lodash = require('lodash');

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Return an array with with any line numbers that are empty.
   * @param {Array} lines An array of each line of the file.
   * @returns {Array} An array of line numbers.
   */
  getEmptyLineNums = function(lines) {
    var emptyLines;
    emptyLines = lines.map(function(line, i) {
      return {
        code: line.trim(),
        num: i + 1
      };
    }).filter(function(line) {
      return !line.code;
    }).map(function(line) {
      return line.num;
    });
    return emptyLines;
  };

  getCommentLineNums = function(comments) {
    var lines;
    lines = [];
    comments.forEach(function(token) {
      var end, start;
      start = token.loc.start.line;
      end = token.loc.end.line;
      return lines.push(start, end);
    });
    return lines;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require empty lines around comments',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/lines-around-comment'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            beforeBlockComment: {
              type: 'boolean'
            },
            afterBlockComment: {
              type: 'boolean'
            },
            beforeLineComment: {
              type: 'boolean'
            },
            afterLineComment: {
              type: 'boolean'
            },
            allowBlockStart: {
              type: 'boolean'
            },
            allowBlockEnd: {
              type: 'boolean'
            },
            allowClassStart: {
              type: 'boolean'
            },
            allowClassEnd: {
              type: 'boolean'
            },
            allowObjectStart: {
              type: 'boolean'
            },
            allowObjectEnd: {
              type: 'boolean'
            },
            allowArrayStart: {
              type: 'boolean'
            },
            allowArrayEnd: {
              type: 'boolean'
            },
            ignorePattern: {
              type: 'string'
            },
            applyDefaultIgnorePatterns: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if a comment token has lines around it (ignores inline comments)
       * @param {token} token The Comment token.
       * @param {Object} opts Options to determine the newline.
       * @param {boolean} opts.after Should have a newline after this line.
       * @param {boolean} opts.before Should have a newline before this line.
       * @returns {void}
       */
      /**
       * Returns whether or not comments are on lines starting with or ending with code
       * @param {token} token The comment token to check.
       * @returns {boolean} True if the comment is not alone.
       */
      /**
       * Returns the parent node that contains the given token.
       * @param {token} token The token to check.
       * @returns {ASTNode} The parent node that contains the given token.
       */
      /**
       * Returns whether or not comments are at the array end or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at array end.
       */
      /**
       * Returns whether or not comments are at the array start or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at array start.
       */
      /**
       * Returns whether or not comments are at the block end or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at block end.
       */
      /**
       * Returns whether or not comments are at the block start or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at block start.
       */
      /**
       * Returns whether or not comments are at the class end or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at class end.
       */
      /**
       * Returns whether or not comments are at the class start or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at class start.
       */
      /**
       * Returns whether or not comments are at the object end or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at object end.
       */
      /**
       * Returns whether or not comments are at the object start or not.
       * @param {token} token The Comment token.
       * @returns {boolean} True if the comment is at object start.
       */
      /**
       * Returns whether or not comments are at the parent end or not.
       * @param {token} token The Comment token.
       * @param {string} nodeType The parent type to check against.
       * @returns {boolean} True if the comment is at parent end.
       */
      /**
       * Returns whether or not comments are at the parent start or not.
       * @param {token} token The Comment token.
       * @param {string} nodeType The parent type to check against.
       * @returns {boolean} True if the comment is at parent start.
       */
      /**
       * Returns whether or not comments are inside a node type or not.
       * @param {ASTNode} parent The Comment parent node.
       * @param {string} nodeType The parent type to check against.
       * @returns {boolean} True if the comment is inside nodeType.
       */
      var applyDefaultIgnorePatterns, checkForEmptyLine, codeAroundComment, commentAndEmptyLines, commentLines, comments, customIgnoreRegExp, defaultIgnoreRegExp, emptyLines, getParentNodeOfToken, hasExplicitDelimiter, ignorePattern, isCommentAtArrayEnd, isCommentAtArrayStart, isCommentAtBlockEnd, isCommentAtBlockStart, isCommentAtClassEnd, isCommentAtClassStart, isCommentAtObjectEnd, isCommentAtObjectStart, isCommentAtParentEnd, isCommentAtParentStart, isParentNodeType, lines, numLines, options, sourceCode;
      options = context.options[0] ? {...context.options[0]} : {};
      ({ignorePattern} = options);
      defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
      customIgnoreRegExp = new RegExp(ignorePattern);
      applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
      options.beforeLineComment || (options.beforeLineComment = false);
      options.afterLineComment || (options.afterLineComment = false);
      options.beforeBlockComment = typeof options.beforeBlockComment !== 'undefined' ? options.beforeBlockComment : true;
      options.afterBlockComment || (options.afterBlockComment = false);
      options.allowBlockStart || (options.allowBlockStart = false);
      options.allowBlockEnd || (options.allowBlockEnd = false);
      sourceCode = context.getSourceCode();
      ({lines} = sourceCode);
      numLines = lines.length + 1;
      comments = sourceCode.getAllComments();
      commentLines = getCommentLineNums(comments);
      emptyLines = getEmptyLineNums(lines);
      commentAndEmptyLines = commentLines.concat(emptyLines);
      codeAroundComment = function(token) {
        var currentToken;
        currentToken = token;
        currentToken = sourceCode.getTokenBefore(currentToken, {
          includeComments: true
        });
        while (currentToken && astUtils.isCommentToken(currentToken)) {
          currentToken = sourceCode.getTokenBefore(currentToken, {
            includeComments: true
          });
        }
        if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
          return true;
        }
        currentToken = token;
        currentToken = sourceCode.getTokenAfter(currentToken, {
          includeComments: true
        });
        while (currentToken && astUtils.isCommentToken(currentToken)) {
          currentToken = sourceCode.getTokenAfter(currentToken, {
            includeComments: true
          });
        }
        if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
          return true;
        }
        return false;
      };
      isParentNodeType = function(parent, nodeType) {
        return parent.type === nodeType || (parent.body && parent.body.type === nodeType) || (parent.consequent && parent.consequent.type === nodeType);
      };
      getParentNodeOfToken = function(token) {
        return sourceCode.getNodeByRangeIndex(token.range[0]);
      };
      hasExplicitDelimiter = function(node) {
        if (/^Array/.test(node.type)) {
          return true;
        }
        if (/^Object/.test(node.type)) {
          return !node.implicit;
        }
        return false;
      };
      isCommentAtParentStart = function(token, nodeType) {
        var parent;
        parent = getParentNodeOfToken(token);
        return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === (nodeType === 'SwitchCase' || hasExplicitDelimiter(parent) ? 1 : 0);
      };
      isCommentAtParentEnd = function(token, nodeType) {
        var parent;
        parent = getParentNodeOfToken(token);
        return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === (nodeType === 'SwitchCase' || hasExplicitDelimiter(parent) ? 1 : 0);
      };
      isCommentAtBlockStart = function(token) {
        return isCommentAtParentStart(token, 'ClassBody') || isCommentAtParentStart(token, 'BlockStatement') || isCommentAtParentStart(token, 'SwitchCase');
      };
      isCommentAtBlockEnd = function(token) {
        return isCommentAtParentEnd(token, 'ClassBody') || isCommentAtParentEnd(token, 'BlockStatement') || isCommentAtParentEnd(token, 'SwitchCase') || isCommentAtParentEnd(token, 'SwitchStatement');
      };
      isCommentAtClassStart = function(token) {
        return isCommentAtParentStart(token, 'ClassBody');
      };
      isCommentAtClassEnd = function(token) {
        return isCommentAtParentEnd(token, 'ClassBody');
      };
      isCommentAtObjectStart = function(token) {
        return isCommentAtParentStart(token, 'ObjectExpression') || isCommentAtParentStart(token, 'ObjectPattern');
      };
      isCommentAtObjectEnd = function(token) {
        return isCommentAtParentEnd(token, 'ObjectExpression') || isCommentAtParentEnd(token, 'ObjectPattern');
      };
      isCommentAtArrayStart = function(token) {
        return isCommentAtParentStart(token, 'ArrayExpression') || isCommentAtParentStart(token, 'ArrayPattern');
      };
      isCommentAtArrayEnd = function(token) {
        return isCommentAtParentEnd(token, 'ArrayExpression') || isCommentAtParentEnd(token, 'ArrayPattern');
      };
      checkForEmptyLine = function(token, opts) {
        var after, arrayEndAllowed, arrayStartAllowed, before, blockEndAllowed, blockStartAllowed, classEndAllowed, classStartAllowed, commentIsNotAlone, exceptionEndAllowed, exceptionStartAllowed, lineStart, nextLineNum, nextTokenOrComment, objectEndAllowed, objectStartAllowed, prevLineNum, previousTokenOrComment, range;
        if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
          return;
        }
        if (ignorePattern && customIgnoreRegExp.test(token.value)) {
          return;
        }
        ({after, before} = opts);
        prevLineNum = token.loc.start.line - 1;
        nextLineNum = token.loc.end.line + 1;
        commentIsNotAlone = codeAroundComment(token);
        blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token));
        blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token));
        classStartAllowed = options.allowClassStart && isCommentAtClassStart(token);
        classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token);
        objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token);
        objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token);
        arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token);
        arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
        exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
        exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
        // ignore top of the file and bottom of the file
        if (prevLineNum < 1) {
          before = false;
        }
        if (nextLineNum >= numLines) {
          after = false;
        }
        // we ignore all inline comments
        if (commentIsNotAlone) {
          return;
        }
        previousTokenOrComment = sourceCode.getTokenBefore(token, {
          includeComments: true
        });
        nextTokenOrComment = sourceCode.getTokenAfter(token, {
          includeComments: true
        });
        // check for newline before
        if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
          lineStart = token.range[0] - token.loc.start.column;
          range = [lineStart, lineStart];
          context.report({
            node: token,
            message: 'Expected line before comment.',
            fix: function(fixer) {
              return fixer.insertTextBeforeRange(range, '\n');
            }
          });
        }
        // check for newline after
        if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
          return context.report({
            node: token,
            message: 'Expected line after comment.',
            fix: function(fixer) {
              return fixer.insertTextAfter(token, '\n');
            }
          });
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        Program: function() {
          return comments.forEach(function(token) {
            if (token.type === 'Line') {
              if (options.beforeLineComment || options.afterLineComment) {
                return checkForEmptyLine(token, {
                  after: options.afterLineComment,
                  before: options.beforeLineComment
                });
              }
            } else if (token.type === 'Block') {
              if (options.beforeBlockComment || options.afterBlockComment) {
                return checkForEmptyLine(token, {
                  after: options.afterBlockComment,
                  before: options.beforeBlockComment
                });
              }
            }
          });
        }
      };
    }
  };

}).call(this);
