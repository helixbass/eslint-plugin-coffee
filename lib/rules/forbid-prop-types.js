// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Forbid certain propTypes
   */
  'use strict';
  var DEFAULTS, astUtil, docsUrl, propsUtil, variableUtil;

  variableUtil = require('../util/react/variable');

  propsUtil = require('../util/react/props');

  astUtil = require('../util/react/ast');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Constants
  // ------------------------------------------------------------------------------
  DEFAULTS = ['any', 'array', 'object'];

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Forbid certain propTypes',
        category: 'Best Practices',
        recommended: false,
        url: docsUrl('forbid-prop-types')
      },
      schema: [
        {
          type: 'object',
          properties: {
            forbid: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            checkContextTypes: {
              type: 'boolean'
            },
            checkChildContextTypes: {
              type: 'boolean'
            }
          },
          additionalProperties: true
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if propTypes declarations are forbidden
       * @param {Array} declarations The array of AST nodes being checked.
       * @returns {void}
       */
      var checkChildContextTypes, checkContextTypes, checkNode, checkProperties, configuration, isForbidden, propWrapperFunctions, shouldCheckChildContextTypes, shouldCheckContextTypes;
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      configuration = context.options[0] || {};
      checkContextTypes = configuration.checkContextTypes || false;
      checkChildContextTypes = configuration.checkChildContextTypes || false;
      isForbidden = function(type) {
        var forbid;
        forbid = configuration.forbid || DEFAULTS;
        return forbid.indexOf(type) >= 0;
      };
      shouldCheckContextTypes = function(node) {
        if (checkContextTypes && propsUtil.isContextTypesDeclaration(node)) {
          return true;
        }
        return false;
      };
      shouldCheckChildContextTypes = function(node) {
        if (checkChildContextTypes && propsUtil.isChildContextTypesDeclaration(node)) {
          return true;
        }
        return false;
      };
      checkProperties = function(declarations) {
        return declarations.forEach(function(declaration) {
          var target, value;
          if (declaration.type !== 'Property') {
            return;
          }
          ({value} = declaration);
          if (value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {
            value = value.object;
          }
          if (value.type === 'CallExpression' && value.callee.type === 'MemberExpression') {
            value = value.callee;
          }
          if (value.property) {
            target = value.property.name;
          } else if (value.type === 'Identifier') {
            target = value.name;
          }
          if (isForbidden(target)) {
            return context.report({
              node: declaration,
              message: `Prop type \`${target}\` is forbidden`
            });
          }
        });
      };
      checkNode = function(node) {
        var innerNode, propTypesObject, ref;
        switch (node != null ? node.type : void 0) {
          case 'ObjectExpression':
            return checkProperties(node.properties);
          case 'Identifier':
            propTypesObject = variableUtil.findVariableByName(context, node.name);
            if (propTypesObject != null ? propTypesObject.properties : void 0) {
              return checkProperties(propTypesObject.properties);
            }
            break;
          case 'CallExpression':
            innerNode = (ref = node.arguments) != null ? ref[0] : void 0;
            if (propWrapperFunctions.has(node.callee.name) && innerNode) {
              return checkNode(innerNode);
            }
        }
      };
      return {
        ClassProperty: function(node) {
          if (!propsUtil.isPropTypesDeclaration(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
            return;
          }
          return checkNode(node.value);
        },
        MemberExpression: function(node) {
          if (!propsUtil.isPropTypesDeclaration(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
            return;
          }
          return checkNode(node.parent.right);
        },
        MethodDefinition: function(node) {
          var returnStatement;
          if (!propsUtil.isPropTypesDeclaration(node) && !shouldCheckContextTypes(node) && !shouldCheckChildContextTypes(node)) {
            return;
          }
          returnStatement = astUtil.findReturnStatement(node);
          if (returnStatement != null ? returnStatement.argument : void 0) {
            return checkNode(returnStatement.argument);
          }
        },
        ObjectExpression: function(node) {
          return node.properties.forEach(function(property) {
            if (!property.key) {
              return;
            }
            if (!propsUtil.isPropTypesDeclaration(property) && !shouldCheckContextTypes(property) && !shouldCheckChildContextTypes(property)) {
              return;
            }
            if (property.value.type === 'ObjectExpression') {
              return checkProperties(property.value.properties);
            }
          });
        }
      };
    }
  };

}).call(this);
