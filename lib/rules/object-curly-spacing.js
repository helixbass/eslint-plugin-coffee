// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Disallows or enforces spaces inside of object literals.
   * @author Jamund Ferguson
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing inside braces',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/object-curly-spacing'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['always',
        'never']
        },
        {
          type: 'object',
          properties: {
            arraysInObjects: {
              type: 'boolean'
            },
            objectsInObjects: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Reports a given export node if spacing in curly braces is invalid.
       * @param {ASTNode} node - An ExportNamedDeclaration node to check.
       * @returns {void}
       */
      /**
       * Reports a given import node if spacing in curly braces is invalid.
       * @param {ASTNode} node - An ImportDeclaration node to check.
       * @returns {void}
       */
      /**
       * Reports a given object node if spacing in curly braces is invalid.
       * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.
       * @returns {void}
       */
      /**
       * Gets '}' token of an object node.
       *
       * Because the last token of object patterns might be a type annotation,
       * this traverses tokens preceded by the last property, then returns the
       * first '}' token.
       *
       * @param {ASTNode} node - The node to get. This node is an
       *      ObjectExpression or an ObjectPattern. And this node has one or
       *      more properties.
       * @returns {Token} '}' token.
       */
      /**
       * Determines whether an option is set, relative to the spacing option.
       * If spaced is "always", then check whether option is set to false.
       * If spaced is "never", then check whether option is set to true.
       * @param {Object} option - The option to exclude.
       * @returns {boolean} Whether or not the property is excluded.
       */
      /**
       * Reports that there shouldn't be a space before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Reports that there should be a space after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Reports that there should be a space before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Determines if spacing in curly braces is valid.
       * @param {ASTNode} node The AST node to check.
       * @param {Token} first The first token to check (should be the opening brace)
       * @param {Token} second The second token to check (should be first after the opening brace)
       * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
       * @param {Token} last The last token to check (should be closing brace)
       * @returns {void}
       */
      var checkForExport, checkForImport, checkForObject, getClosingBraceOfObject, isOptionSet, options, reportNoBeginningSpace, reportNoEndingSpace, reportRequiredBeginningSpace, reportRequiredEndingSpace, sourceCode, spaced, validateBraceSpacing;
      spaced = context.options[0] === 'always';
      sourceCode = context.getSourceCode();
      isOptionSet = function(option) {
        if (context.options[1]) {
          return context.options[1][option] === !spaced;
        } else {
          return false;
        }
      };
      options = {
        spaced,
        arraysInObjectsException: isOptionSet('arraysInObjects'),
        objectsInObjectsException: isOptionSet('objectsInObjects')
      };
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Reports that there shouldn't be a space after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      reportNoBeginningSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          message: "There should be no space after '{{token}}'.",
          data: {
            token: token.value
          },
          fix: function(fixer) {
            var nextToken;
            nextToken = context.getSourceCode().getTokenAfter(token);
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      };
      reportNoEndingSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          message: "There should be no space before '{{token}}'.",
          data: {
            token: token.value
          },
          fix: function(fixer) {
            var previousToken;
            previousToken = context.getSourceCode().getTokenBefore(token);
            return fixer.removeRange([previousToken.range[1], token.range[0]]);
          }
        });
      };
      reportRequiredBeginningSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          message: "A space is required after '{{token}}'.",
          data: {
            token: token.value
          },
          fix: function(fixer) {
            return fixer.insertTextAfter(token, ' ');
          }
        });
      };
      reportRequiredEndingSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          message: "A space is required before '{{token}}'.",
          data: {
            token: token.value
          },
          fix: function(fixer) {
            return fixer.insertTextBefore(token, ' ');
          }
        });
      };
      validateBraceSpacing = function(node, first, second, penultimate, last) {
        var closingCurlyBraceMustBeSpaced, firstSpaced, lastSpaced, penultimateType, shouldCheckPenultimate;
        if (astUtils.isTokenOnSameLine(first, second)) {
          firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
          if (options.spaced && !firstSpaced) {
            reportRequiredBeginningSpace(node, first);
          }
          if (!options.spaced && firstSpaced) {
            reportNoBeginningSpace(node, first);
          }
        }
        if (astUtils.isTokenOnSameLine(penultimate, last)) {
          shouldCheckPenultimate = (options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate)) || (options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate));
          penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
          closingCurlyBraceMustBeSpaced = ((options.arraysInObjectsException && penultimateType === 'ArrayExpression') || (options.objectsInObjectsException && (penultimateType === 'ObjectExpression' || penultimateType === 'ObjectPattern'))) ? !options.spaced : options.spaced;
          lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
          if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
            reportRequiredEndingSpace(node, last);
          }
          if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
            return reportNoEndingSpace(node, last);
          }
        }
      };
      getClosingBraceOfObject = function(node) {
        var lastProperty;
        lastProperty = node.properties[node.properties.length - 1];
        return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
      };
      checkForObject = function(node) {
        var first, last, penultimate, second;
        if (node.implicit) {
          return;
        }
        if (node.properties.length === 0) {
          return;
        }
        first = sourceCode.getFirstToken(node);
        last = getClosingBraceOfObject(node);
        second = sourceCode.getTokenAfter(first);
        penultimate = sourceCode.getTokenBefore(last);
        return validateBraceSpacing(node, first, second, penultimate, last);
      };
      checkForImport = function(node) {
        var first, firstSpecifier, last, lastSpecifier, penultimate, second;
        if (node.specifiers.length === 0) {
          return;
        }
        firstSpecifier = node.specifiers[0];
        lastSpecifier = node.specifiers[node.specifiers.length - 1];
        if (lastSpecifier.type !== 'ImportSpecifier') {
          return;
        }
        if (firstSpecifier.type !== 'ImportSpecifier') {
          firstSpecifier = node.specifiers[1];
        }
        first = sourceCode.getTokenBefore(firstSpecifier);
        last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken);
        second = sourceCode.getTokenAfter(first);
        penultimate = sourceCode.getTokenBefore(last);
        return validateBraceSpacing(node, first, second, penultimate, last);
      };
      checkForExport = function(node) {
        var first, firstSpecifier, last, lastSpecifier, penultimate, second;
        if (node.specifiers.length === 0) {
          return;
        }
        firstSpecifier = node.specifiers[0];
        lastSpecifier = node.specifiers[node.specifiers.length - 1];
        first = sourceCode.getTokenBefore(firstSpecifier);
        last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken);
        second = sourceCode.getTokenAfter(first);
        penultimate = sourceCode.getTokenBefore(last);
        return validateBraceSpacing(node, first, second, penultimate, last);
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        // var {x} = y;
        ObjectPattern: checkForObject,
        // var y = {x: 'y'}
        ObjectExpression: checkForObject,
        // import {y} from 'x';
        ImportDeclaration: checkForImport,
        // export {name} from 'yo';
        ExportNamedDeclaration: checkForExport
      };
    }
  };

}).call(this);
