// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to disallow mixed binary operators.
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Checks whether any group which includes both given operator exists or not.
   *
   * @param {Array.<string[]>} groups - A list of groups to check.
   * @param {string} left - An operator.
   * @param {string} right - Another operator.
   * @returns {boolean} `true` if such group existed.
   */
  /**
   * Normalizes options.
   *
   * @param {Object|undefined} options - A options object to normalize.
   * @returns {Object} Normalized option object.
   */
  var ALL_OPERATORS, ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, DEFAULT_GROUPS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TARGET_NODE_TYPE, astUtils, getPrecedence, includesBothInAGroup, normalizeOptions;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  ({getPrecedence} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  ARITHMETIC_OPERATORS = ['+', '-', '*', '/', '%', '**'];

  BITWISE_OPERATORS = ['&', '|', '^', '~', '<<', '>>', '>>>'];

  COMPARISON_OPERATORS = ['==', '!=', 'is', 'isnt', '>', '>=', '<', '<='];

  LOGICAL_OPERATORS = ['&&', '||', 'and', 'or', '?'];

  RELATIONAL_OPERATORS = ['in', 'instanceof', 'of', 'not in', 'not of'];

  ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS);

  DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];

  TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;

  normalizeOptions = function(options) {
    var allowSamePrecedence, groups, hasGroups;
    hasGroups = (options != null ? options.groups : void 0) && options.groups.length > 0;
    groups = hasGroups ? options.groups : DEFAULT_GROUPS;
    allowSamePrecedence = (options != null ? options.allowSamePrecedence : void 0) !== false;
    return {groups, allowSamePrecedence};
  };

  includesBothInAGroup = function(groups, left, right) {
    return groups.some(function(group) {
      return group.indexOf(left) !== -1 && group.indexOf(right) !== -1;
    });
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow mixed binary operators',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-mixed-operators'
      },
      schema: [
        {
          type: 'object',
          properties: {
            groups: {
              type: 'array',
              items: {
                type: 'array',
                items: {
                  enum: ALL_OPERATORS
                },
                minItems: 2,
                uniqueItems: true
              },
              uniqueItems: true
            },
            allowSamePrecedence: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks between the operator of this node and the operator of the
       * parent node.
       *
       * @param {ASTNode} node - A node to check.
       * @returns {void}
       */
      /**
       * Gets the operator token of a given node.
       *
       * @param {ASTNode} node - A node to check. This is a BinaryExpression
       *      node or a LogicalExpression node.
       * @returns {Token} The operator token of the node.
       */
      /**
       * Checks whether the operator of a given node is mixed with parent
       * node's operator or not.
       *
       * @param {ASTNode} node - A node to check. This is a BinaryExpression
       *      node or a LogicalExpression node. This parent node is one of
       *      them, too.
       * @returns {boolean} `true` if the node was mixed.
       */
      /**
       * Reports both the operator of a given node and the operator of the
       * parent node.
       *
       * @param {ASTNode} node - A node to check. This is a BinaryExpression
       *      node or a LogicalExpression node. This parent node is one of
       *      them, too.
       * @returns {void}
       */
      /**
       * Checks whether a given node should be ignored by options or not.
       *
       * @param {ASTNode} node - A node to check. This is a BinaryExpression
       *      node or a LogicalExpression node. This parent node is one of
       *      them, too.
       * @returns {boolean} `true` if the node should be ignored.
       */
      var check, getOperatorToken, isMixedWithParent, options, reportBothOperators, shouldIgnore, sourceCode;
      sourceCode = context.getSourceCode();
      options = normalizeOptions(context.options[0]);
      shouldIgnore = function(node) {
        var a, b;
        a = node;
        b = node.parent;
        return !includesBothInAGroup(options.groups, a.operator, b.operator) || (options.allowSamePrecedence && getPrecedence(a) === getPrecedence(b));
      };
      isMixedWithParent = function(node) {
        return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
      };
      getOperatorToken = function(node) {
        return sourceCode.getTokenAfter(node.left, astUtils.isNotClosingParenToken);
      };
      reportBothOperators = function(node) {
        var data, left, message, parent, right;
        ({parent} = node);
        left = parent.left === node ? node : parent;
        right = parent.left !== node ? node : parent;
        message = "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
        data = {
          leftOperator: left.operator,
          rightOperator: right.operator
        };
        context.report({
          node: left,
          loc: getOperatorToken(left).loc.start,
          message,
          data
        });
        return context.report({
          node: right,
          loc: getOperatorToken(right).loc.start,
          message,
          data
        });
      };
      check = function(node) {
        if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
          return reportBothOperators(node);
        }
      };
      return {
        BinaryExpression: check,
        LogicalExpression: check
      };
    }
  };

}).call(this);
