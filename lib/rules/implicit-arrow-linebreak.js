// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview enforce the location of arrow function bodies
   * @author Sharmila Jesupaul
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce the location of arrow function bodies',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/implicit-arrow-linebreak'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['beside',
        'below']
        }
      ]
    },
    create: function(context) {
      /**
       * Validates the location of an arrow function body
       * @param {ASTNode} node The arrow function body
       * @param {string} keywordName The applicable keyword name for the arrow function body
       * @returns {void}
       */
      var getOption, sourceCode, validateExpression;
      sourceCode = context.getSourceCode();
      //----------------------------------------------------------------------
      // Helpers
      //----------------------------------------------------------------------
      /**
       * Gets the applicable preference for a particular keyword
       * @returns {string} The applicable option for the keyword, e.g. 'beside'
       */
      getOption = function() {
        return context.options[0] || 'beside';
      };
      validateExpression = function(node) {
        var body, fixerTarget, hasParens, option, tokenBefore;
        if (!(node.body.type !== 'BlockStatement' || (node.body.body.length === 1 && node.body.body[0].type === 'ExpressionStatement'))) {
          return;
        }
        ({body} = node);
        if (body.type === 'BlockStatement') {
          body = body.body[0];
        }
        option = getOption();
        tokenBefore = sourceCode.getTokenBefore(body);
        hasParens = tokenBefore.value === '(';
        // return if node.type is 'BlockStatement'
        fixerTarget = body;
        if (hasParens) {
          // Gets the first token before the function body that is not an open paren
          tokenBefore = sourceCode.getTokenBefore(body, function(token) {
            return token.value !== '(';
          });
          fixerTarget = sourceCode.getTokenAfter(tokenBefore);
        }
        if (tokenBefore.loc.end.line === fixerTarget.loc.start.line && option === 'below') {
          return context.report({
            node: fixerTarget,
            message: 'Expected a linebreak before this expression.',
            fix: function(fixer) {
              return fixer.insertTextBefore(fixerTarget, '\n');
            }
          });
        } else if (tokenBefore.loc.end.line !== fixerTarget.loc.start.line && option === 'beside') {
          return context.report({
            node: fixerTarget,
            message: 'Expected no linebreak before this expression.',
            fix: function(fixer) {
              return fixer.replaceTextRange([tokenBefore.range[1], fixerTarget.range[0]], ' ');
            }
          });
        }
      };
      return {
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        FunctionExpression: validateExpression,
        ArrowFunctionExpression: validateExpression
      };
    }
  };

}).call(this);
