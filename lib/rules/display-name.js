// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent missing displayName in a React component definition
   * @author Yannick Croissant
   */
  'use strict';
  var Components, astUtil, docsUrl, has, isDeclarationAssignment;

  has = require('has');

  Components = require('../util/react/Components');

  astUtil = require('../util/react/ast');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Prevent missing displayName in a React component definition',
        category: 'Best Practices',
        recommended: true,
        url: docsUrl('display-name')
      },
      schema: [
        {
          type: 'object',
          properties: {
            ignoreTranspilerName: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Checks if the component have a name set by the transpiler
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if component has a name, false if not.
       */
      /**
       * Checks if we are declaring a display name
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if we are declaring a display name, false if not.
       */
      /**
       * Mark a prop type as declared
       * @param {ASTNode} node The AST node being checked.
       */
      /**
       * Reports missing display name for a given component
       * @param {Object} component The component to process
       */
      var MISSING_MESSAGE, config, hasTranspilerName, ignoreTranspilerName, isDisplayNameDeclaration, markDisplayNameAsDeclared, reportMissingDisplayName;
      config = context.options[0] || {};
      ignoreTranspilerName = config.ignoreTranspilerName || false;
      MISSING_MESSAGE = 'Component definition is missing display name';
      isDisplayNameDeclaration = function(node) {
        switch (node.type) {
          case 'ClassProperty':
            return node.key && node.key.name === 'displayName';
          case 'Identifier':
            return node.name === 'displayName';
          case 'Literal':
            return node.value === 'displayName';
          default:
            return false;
        }
      };
      markDisplayNameAsDeclared = function(node) {
        return components.set(node, {
          hasDisplayName: true
        });
      };
      reportMissingDisplayName = function(component) {
        return context.report({
          node: component.node,
          message: MISSING_MESSAGE,
          data: {
            component: component.name
          }
        });
      };
      hasTranspilerName = function(node) {
        var namedClass, namedFunctionDeclaration, namedFunctionExpression, namedObjectAssignment, namedObjectDeclaration, ref, ref1, ref2;
        namedObjectAssignment = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'AssignmentExpression' && (!node.parent.parent.left.object || node.parent.parent.left.object.name !== 'module' || node.parent.parent.left.property.name !== 'exports');
        namedObjectDeclaration = node.type === 'ObjectExpression' && node.parent && node.parent.parent && node.parent.parent.type === 'VariableDeclarator';
        namedClass = ((ref = node.type) === 'ClassDeclaration' || ref === 'ClassExpression') && node.id && node.id.name;
        namedFunctionDeclaration = ((ref1 = node.type) === 'FunctionDeclaration' || ref1 === 'FunctionExpression') && node.id && node.id.name;
        namedFunctionExpression = astUtil.isFunctionLikeExpression(node) && node.parent && (((ref2 = node.parent) != null ? ref2.type : void 0) === 'VariableDeclarator' || node.parent.method === true || (node.parent.type === 'Property' && node === node.parent.value && node.parent.parent.type === 'ObjectExpression') || (isDeclarationAssignment(node.parent) && node.parent.left.name)) && (!node.parent.parent || !utils.isES5Component(node.parent.parent));
        if (namedObjectAssignment || namedObjectDeclaration || namedClass || namedFunctionDeclaration || namedFunctionExpression) {
          return true;
        }
        return false;
      };
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        ClassProperty: function(node) {
          if (!isDisplayNameDeclaration(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        MemberExpression: function(node) {
          var component;
          // console.log {node}
          if (!isDisplayNameDeclaration(node.property)) {
            return;
          }
          component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          return markDisplayNameAsDeclared(component.node);
        },
        FunctionExpression: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        FunctionDeclaration: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        ArrowFunctionExpression: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        MethodDefinition: function(node) {
          if (!isDisplayNameDeclaration(node.key)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        ClassExpression: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        ClassDeclaration: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        ObjectExpression: function(node) {
          if (ignoreTranspilerName || !hasTranspilerName(node)) {
            // Search for the displayName declaration
            node.properties.forEach(function(property) {
              if (!property.key || !isDisplayNameDeclaration(property.key)) {
                return;
              }
              return markDisplayNameAsDeclared(node);
            });
            return;
          }
          return markDisplayNameAsDeclared(node);
        },
        'Program:exit': function() {
          var component, list, results;
          list = components.list();
// Report missing display name for all components
          results = [];
          for (component in list) {
            if (!has(list, component) || list[component].hasDisplayName) {
              continue;
            }
            results.push(reportMissingDisplayName(list[component]));
          }
          return results;
        }
      };
    })
  };

}).call(this);
