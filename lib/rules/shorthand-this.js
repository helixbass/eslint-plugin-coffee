// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview This rule monitors usage of shorthand `@` for `this`
   * @author Julian Rosse
   */
  'use strict';
  var isObjectShorthand, isProperty, isStaticProperty, isThisParam,
    indexOf = [].indexOf;

  isProperty = function(node) {
    var parent;
    ({parent} = node);
    return parent.type === 'MemberExpression' && node === parent.object;
  };

  isThisParam = function(node) {
    var parent;
    if (!isProperty(node)) {
      return false;
    }
    ({parent} = node);
    return parent.parent.type === 'FunctionExpression' && indexOf.call(parent.parent.params, parent) >= 0;
  };

  isObjectShorthand = function(node) {
    var parent;
    if (!isProperty(node)) {
      return false;
    }
    ({parent} = node);
    return parent.parent.type === 'Property' && parent.parent.shorthand;
  };

  isStaticProperty = function(node) {
    var parent;
    ({parent} = node);
    return (parent != null ? parent.type : void 0) === 'ClassProperty' && node === parent.staticClassName;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'monitor usage of shorthand "@" for "this"',
        category: 'Stylistic Issues',
        recommended: false
      },
      // url: 'https://eslint.org/docs/rules/space-unary-ops'
      schema: [
        {
          enum: ['always',
        'never',
        'allow']
        },
        {
          type: 'object',
          properties: {
            forbidStandalone: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var allowed, forbidLonghand, forbidLonghandStandalone, forbidShorthand, forbidStandalone, ref, ref1, ref2, ref3;
      allowed = (ref = (ref1 = context.options) != null ? ref1[0] : void 0) != null ? ref : 'always';
      ({forbidStandalone} = (ref2 = (ref3 = context.options) != null ? ref3[1] : void 0) != null ? ref2 : {});
      forbidLonghand = allowed === 'always';
      forbidLonghandStandalone = forbidLonghand && !forbidStandalone;
      forbidShorthand = allowed === 'never';
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        ThisExpression: function(node) {
          var isShorthand, isStandalone;
          isShorthand = !!node.shorthand;
          isStandalone = !isProperty(node);
          if (isThisParam(node) || isObjectShorthand(node) || isStaticProperty(node)) {
            return;
          }
          if (isShorthand) {
            if (forbidShorthand) {
              context.report({
                node,
                message: "Use 'this' instead of '@'"
              });
              return;
            }
            if (isStandalone && forbidStandalone) {
              return context.report({
                node,
                message: "Use 'this' instead of standalone '@'"
              });
            }
          } else if ((isStandalone && forbidLonghandStandalone) || (!isStandalone && forbidLonghand)) {
            return context.report({
              node,
              message: "Use '@' instead of 'this'"
            });
          }
        }
      };
    }
  };

}).call(this);
