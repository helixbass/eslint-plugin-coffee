// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Look for useless escapes in strings and regexes
   * @author Onur Temizkan
   */
  'use strict';
  /**
   * Parses a regular expression into a list of characters with character class info.
   * @param {string} regExpText The raw text used to create the regular expression
   * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.
   * @example
   *
   * parseRegExp('a\\b[cd-]')
   *
   * returns:
   * [
   *   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},
   *   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},
   *   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},
   *   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},
   *   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}
   * ]
   */
  var REGEX_GENERAL_ESCAPES, REGEX_NON_CHARCLASS_ESCAPES, VALID_STRING_ESCAPES, astUtils, parseRegExp, union;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  /**
   * Returns the union of two sets.
   * @param {Set} setA The first set
   * @param {Set} setB The second set
   * @returns {Set} The union of the two sets
   */
  union = function(setA, setB) {
    return new Set((function*() {
      yield* setA;
      return (yield* setB);
    })());
  };

  VALID_STRING_ESCAPES = union(new Set('\\nrvtbfux'), astUtils.LINEBREAKS);

  REGEX_GENERAL_ESCAPES = new Set('\\bcdDfnpPrsStvwWxu0123456789]/');

  REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set('^/.$*+?[{}|()Bk'));

  parseRegExp = function(regExpText) {
    var charList;
    charList = [];
    regExpText.split('').reduce(function(state, char, index) {
      if (!state.escapeNextChar) {
        if (char === '\\') {
          return Object.assign(state, {
            escapeNextChar: true
          });
        }
        if (char === '[' && !state.inCharClass) {
          return Object.assign(state, {
            inCharClass: true,
            startingCharClass: true
          });
        }
        if (char === ']' && state.inCharClass) {
          if (charList.length && charList[charList.length - 1].inCharClass) {
            charList[charList.length - 1].endsCharClass = true;
          }
          return Object.assign(state, {
            inCharClass: false,
            startingCharClass: false
          });
        }
      }
      charList.push({
        text: char,
        index,
        escaped: state.escapeNextChar,
        inCharClass: state.inCharClass,
        startsCharClass: state.startingCharClass,
        endsCharClass: false,
        nextChar: regExpText[index + 1]
      });
      return Object.assign(state, {
        escapeNextChar: false,
        startingCharClass: false
      });
    }, {
      escapeNextChar: false,
      inCharClass: false,
      startingCharClass: false
    });
    return charList;
  };

  module.exports = {
    meta: {
      docs: {
        description: 'disallow unnecessary escape characters',
        category: 'Best Practices',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-useless-escape'
      },
      schema: []
    },
    create: function(context) {
      /**
       * Checks if a node has an escape.
       *
       * @param {ASTNode} node - node to check.
       * @returns {void}
       */
      /**
       * Reports a node
       * @param {ASTNode} node The node to report
       * @param {number} startOffset The backslash's offset from the start of the node
       * @param {string} character The uselessly escaped character (not including the backslash)
       * @returns {void}
       */
      /**
       * Checks if the escape character in given string slice is unnecessary.
       *
       * @private
       * @param {ASTNode} node - node to validate.
       * @param {string} match - string slice to validate.
       * @returns {void}
       */
      var check, report, sourceCode, validateString;
      sourceCode = context.getSourceCode();
      report = function(node, startOffset, character) {
        return context.report({
          node,
          loc: sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset),
          message: 'Unnecessary escape character: \\{{character}}.',
          data: {character}
        });
      };
      validateString = function(node, match, value) {
        /*
         * Warn if `\{` is not preceded by `#`. If preceded by `#`, escaping
         * is necessary and the rule should not warn. If preceded by `/#`, the rule
         * will warn for the `/#` instead, as it is the first unnecessarily escaped character.
         */
        var escapedChar, followingQuotes, getNumFoundQuotes, isClosingQuote, isQuoteEscape, isTemplateElement, isUnnecessaryEscape, precedingQuotes, quote, ref, ref1;
        isTemplateElement = node.type === 'TemplateElement';
        escapedChar = match[0][1];
        isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
        if (isTemplateElement) {
          ({quote} = node.parent);
          isQuoteEscape = (quote != null) && escapedChar === quote[0];
          if (isQuoteEscape && quote.length === 3) {
            isQuoteEscape = false;
            followingQuotes = RegExp(`^(?:\\\\?${quote[0]})+`).exec(value.slice((match.index + match[0].length)));
            precedingQuotes = RegExp(`(?:\\\\?${quote[0]})+$`).exec(value.slice(0, match.index));
            isClosingQuote = match.index + match[0].length === value.length;
            // eslint-disable-next-line coffee/no-inner-declarations
            getNumFoundQuotes = function(quotesMatch) {
              if (!quotesMatch) {
                return 0;
              }
              return quotesMatch[0].match(RegExp(`${quote[0]}`, "g")).length;
            };
            if (isClosingQuote || getNumFoundQuotes(followingQuotes) + getNumFoundQuotes(precedingQuotes) >= 2) {
              isQuoteEscape = true;
            }
          }
        } else {
          isQuoteEscape = escapedChar === node.raw[0];
        }
        if (isTemplateElement || ((ref = node.extra) != null ? (ref1 = ref.raw) != null ? ref1[0] : void 0 : void 0) === '"') {
          if (escapedChar === '#') {
            // Warn if `\#` is not followed by `{`
            isUnnecessaryEscape = match.input[match.index + 2] !== '{';
          } else if (escapedChar === '{') {
            isUnnecessaryEscape = match.input[match.index - 1] !== '#';
          }
        }
        if (isUnnecessaryEscape && !isQuoteEscape) {
          return report(node, match.index + 1, match[0].slice(1));
        }
      };
      check = function(node) {
        var isInterpolatedRegex, isTemplateElement, match, pattern, ref, ref1, ref2, ref3, ref4, ref5, ref6, results, value;
        isTemplateElement = node.type === 'TemplateElement';
        // Don't report tagged template literals, because the backslash character is accessible to the tag function.
        if (isTemplateElement && ((ref = node.parent) != null ? (ref1 = ref.parent) != null ? ref1.type : void 0 : void 0) === 'TaggedTemplateExpression' && node.parent === node.parent.parent.quasi) {
          return;
        }
        isInterpolatedRegex = isTemplateElement && ((ref2 = node.parent) != null ? (ref3 = ref2.parent) != null ? ref3.type : void 0 : void 0) === 'InterpolatedRegExpLiteral';
        if (typeof node.value === 'string' || (isTemplateElement && !isInterpolatedRegex)) {
          /*
           * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
           * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
           */
          if ((ref4 = node.parent.type) === 'JSXAttribute' || ref4 === 'JSXElement' || ref4 === 'JSXFragment') {
            return;
          }
          value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
          pattern = /\\[^\d]/g;
          results = [];
          while (match = pattern.exec(value)) {
            results.push(validateString(node, match, value));
          }
          return results;
        } else if (node.regex || isInterpolatedRegex) {
          /*
           * The '-' character is a special case, because it's only valid to escape it if it's in a character
           * class, and is not at either edge of the character class. To account for this, don't consider '-'
           * characters to be valid in general, and filter out '-' characters that appear in the middle of a
           * character class.
           */
          return parseRegExp((ref5 = (ref6 = node.regex) != null ? ref6.pattern : void 0) != null ? ref5 : node.value.raw).filter(function(charInfo) {
            return !(charInfo.text === '-' && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass);
          /*
           * The '^' character is also a special case; it must always be escaped outside of character classes, but
           * it only needs to be escaped in character classes if it's at the beginning of the character class. To
           * account for this, consider it to be a valid escape character outside of character classes, and filter
           * out '^' characters that appear at the start of a character class.
           */
          }).filter(function(charInfo) {
            return !(charInfo.text === '^' && charInfo.startsCharClass);
          // Filter out characters that aren't escaped.
          }).filter(function(charInfo) {
            return charInfo.escaped;
          // Filter out escaped heregex interpolations
          }).filter(function(charInfo) {
            return !(charInfo.text === '#' && charInfo.nextChar === '{' && (isInterpolatedRegex || node.delimiter === '///'));
          // Filter out characters that are valid to escape, based on their position in the regular expression.
          }).filter(function(charInfo) {
            return !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text);
          // Report all the remaining characters.
          }).forEach(function(charInfo) {
            return report(node, charInfo.index, charInfo.text);
          });
        }
      };
      return {
        Literal: check,
        TemplateElement: check
      };
    }
  };

}).call(this);
