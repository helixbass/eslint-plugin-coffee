// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to ensure newline per method call when chaining calls
   * @author Rajendra Patil
   * @author Burak Yigit Kaya
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require a newline after each call in a method chain',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/newline-per-chained-call'
      },
      // fixable: 'whitespace'
      schema: [
        {
          type: 'object',
          properties: {
            ignoreChainWithDepth: {
              type: 'integer',
              minimum: 1,
              maximum: 10
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Get the prefix of a given MemberExpression node.
       * If the MemberExpression node is a computed value it returns a
       * left bracket. If not it returns a period.
       *
       * @param  {ASTNode} node - A MemberExpression node to get
       * @returns {string} The prefix of the node.
       */
      /**
       * Gets the property text of a given MemberExpression node.
       * If the text is multiline, this returns only the first line.
       *
       * @param {ASTNode} node - A MemberExpression node to get.
       * @returns {string} The property text of the node.
       */
      var getPrefix, getPropertyText, ignoreChainWithDepth, options, sourceCode;
      options = context.options[0] || {};
      ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
      sourceCode = context.getSourceCode();
      getPrefix = function(node) {
        if (node.computed) {
          return '[';
        } else {
          return '.';
        }
      };
      getPropertyText = function(node) {
        var lines, prefix, suffix;
        prefix = getPrefix(node);
        lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
        suffix = node.computed && lines.length === 1 ? ']' : '';
        return prefix + lines[0] + suffix;
      };
      return {
        'CallExpression:exit': function(node) {
          var callee, depth, parent, ref;
          if (!(((ref = node.callee) != null ? ref.type : void 0) === 'MemberExpression' && !node.callee.computed)) {
            return;
          }
          ({callee} = node);
          parent = callee.object;
          depth = 1;
          while ((parent != null ? parent.callee : void 0) && !parent.callee.computed) {
            depth += 1;
            parent = parent.callee.object;
          }
          if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
            return context.report({
              node: callee.property,
              loc: callee.property.loc.start,
              message: 'Expected line break before `{{callee}}`.',
              data: {
                callee: getPropertyText(callee)
              }
            });
          }
        }
      };
    }
  };

  // fix: (fixer) ->
//   firstTokenAfterObject = sourceCode.getTokenAfter(
//     callee.object
//     astUtils.isNotClosingParenToken
//   )

  //   fixer.insertTextBefore firstTokenAfterObject, '\n'

}).call(this);
