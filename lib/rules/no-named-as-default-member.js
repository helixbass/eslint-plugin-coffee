// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to warn about potentially confused use of name exports
   * @author Desmond Brand
   * @copyright 2016 Desmond Brand. All rights reserved.
   * See LICENSE in root directory for full license.
   */
  var Exports, docsUrl, importDeclaration;

  ({
    default: Exports
  } = require('../eslint-plugin-import-export-map'));

  ({
    default: importDeclaration
  } = require('eslint-plugin-import/lib/importDeclaration'));

  ({
    default: docsUrl
  } = require('eslint-plugin-import/lib/docsUrl'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      type: 'suggestion',
      docs: {
        url: docsUrl('no-named-as-default-member')
      }
    },
    create: function(context) {
      var allPropertyLookups, fileImports, handleDestructuringAssignment, handleImportDefault, handleProgramExit, handlePropLookup, storePropertyLookup;
      fileImports = new Map();
      allPropertyLookups = new Map();
      handleImportDefault = function(node) {
        var declaration, exportMap;
        declaration = importDeclaration(context);
        exportMap = Exports.get(declaration.source.value, context);
        if (exportMap == null) {
          return;
        }
        if (exportMap.errors.length) {
          exportMap.reportErrors(context, declaration);
          return;
        }
        return fileImports.set(node.local.name, {
          exportMap,
          sourcePath: declaration.source.value
        });
      };
      storePropertyLookup = function(objectName, propName, node) {
        var lookups;
        lookups = allPropertyLookups.get(objectName) || [];
        lookups.push({node, propName});
        return allPropertyLookups.set(objectName, lookups);
      };
      handlePropLookup = function(node) {
        var objectName, propName;
        objectName = node.object.name;
        propName = node.property.name;
        return storePropertyLookup(objectName, propName, node);
      };
      handleDestructuringAssignment = function(node) {
        var id, init, isDestructure, key, objectName, ref, results, x;
        if (node.type === 'AssignmentExpression') {
          ({
            left: id,
            right: init
          } = node);
        } else {
          ({id, init} = node);
        }
        isDestructure = id.type === 'ObjectPattern' && (init != null ? init.type : void 0) === 'Identifier';
        if (!isDestructure) {
          return;
        }
        objectName = init.name;
        ref = id.properties;
        results = [];
        for (x of ref) {
          ({key} = x);
          if (key == null) {
            continue; // true for rest properties
          }
          results.push(storePropertyLookup(objectName, key.name, key));
        }
        return results;
      };
      handleProgramExit = function() {
        return allPropertyLookups.forEach(function(lookups, objectName) {
          var fileImport, node, propName, results, x;
          fileImport = fileImports.get(objectName);
          if (fileImport == null) {
            return;
          }
          results = [];
          for (x of lookups) {
            ({propName, node} = x);
            // the default import can have a "default" property
            if (propName === 'default') {
              continue;
            }
            if (!fileImport.exportMap.namespace.has(propName)) {
              continue;
            }
            results.push(context.report({
              node,
              message: `Caution: \`${objectName}\` also has a named export ` + `\`${propName}\`. Check if you meant to write ` + `\`import {${propName}} from '${fileImport.sourcePath}'\` ` + 'instead.'
            }));
          }
          return results;
        });
      };
      return {
        ImportDefaultSpecifier: handleImportDefault,
        MemberExpression: handlePropLookup,
        VariableDeclarator: handleDestructuringAssignment,
        AssignmentExpression: handleDestructuringAssignment,
        'Program:exit': handleProgramExit
      };
    }
  };

}).call(this);
