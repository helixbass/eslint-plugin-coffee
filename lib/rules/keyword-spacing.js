// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to enforce spacing before and after keywords.
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Checks whether or not a given token is a "Template" token starts with "}".
   *
   * @param {Token} token - A token to check.
   * @returns {boolean} `true` if the token is a "Template" token starts with "}".
   */
  var CHECK_TYPE, KEYS, NEXT_TOKEN, NEXT_TOKEN_M, PREV_TOKEN, PREV_TOKEN_M, TEMPLATE_CLOSE_PAREN, TEMPLATE_OPEN_PAREN, astUtils, isCloseParenOfTemplate, isOpenParenOfTemplate, keywords;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  keywords = require('../eslint-keywords');

  //------------------------------------------------------------------------------
  // Constants
  //------------------------------------------------------------------------------
  PREV_TOKEN = /^(?:[)\]}>])$/; // [-=] > |

  NEXT_TOKEN = /^(?:[-=]>|[([{<~!]|\+\+?|--?)$/;

  PREV_TOKEN_M = /^[)\]}>*]$/;

  NEXT_TOKEN_M = /^[{*]$/;

  TEMPLATE_OPEN_PAREN = /\$\{$/;

  TEMPLATE_CLOSE_PAREN = /^\}/;

  CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;

  KEYS = keywords.concat(['as', 'async', 'await', 'from', 'get', 'let', 'of', 'set', 'yield', 'then', 'when', 'unless', 'until', 'not']);

  (function() {    // check duplications.
    var i, j, ref, results;
    KEYS.sort();
    results = [];
    for (i = j = 1, ref = KEYS.length; (1 <= ref ? j < ref : j > ref); i = 1 <= ref ? ++j : --j) {
      if (KEYS[i] === KEYS[i - 1]) {
        throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
      } else {
        results.push(void 0);
      }
    }
    return results;
  })();

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Checks whether or not a given token is a "Template" token ends with "${".
   *
   * @param {Token} token - A token to check.
   * @returns {boolean} `true` if the token is a "Template" token ends with "${".
   */
  isOpenParenOfTemplate = function(token) {
    return token.type === 'Template' && TEMPLATE_OPEN_PAREN.test(token.value);
  };

  isCloseParenOfTemplate = function(token) {
    return token.type === 'Template' && TEMPLATE_CLOSE_PAREN.test(token.value);
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing before and after keywords',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/keyword-spacing'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            before: {
              type: 'boolean'
            },
            after: {
              type: 'boolean'
            },
            overrides: {
              type: 'object',
              properties: KEYS.reduce(function(retv,
        key) {
                retv[key] = {
                  type: 'object',
                  properties: {
                    before: {
                      type: 'boolean'
                    },
                    after: {
                      type: 'boolean'
                    }
                  },
                  additionalProperties: false
                };
                return retv;
              },
        {}),
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Reports a given token if usage of spacing preceded by the token is
       * invalid.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp|undefined} pattern - Optional. A pattern of the next
       *      token to check.
       * @returns {void}
       */
      /**
       * Reports a given token if usage of spacing around the token is invalid.
       *
       * @param {Token} token - A token to report.
       * @returns {void}
       */
      /**
       * Reports the first token of a given node if the first token is a keyword
       * and usage of spacing around the token is invalid.
       *
       * @param {ASTNode|null} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports the previous token of a given node if the token is a keyword and
       * usage of spacing around the token is invalid.
       *
       * @param {ASTNode|null} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports a given token if usage of spacing followed by the token is
       * invalid.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
       *      token to check.
       * @returns {void}
       */
      /**
       * Reports the first token of a given node if the first token is a keyword
       * and usage of spacing followed by the token is invalid.
       *
       * This is used for unary operators (e.g. `typeof`), `function`, and `super`.
       * Other rules are handling usage of spacing preceded by those keywords.
       *
       * @param {ASTNode|null} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `class` and `extends` keywords of a given node if usage of
       * spacing around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `do` and `while` keywords of a given node if usage of spacing
       * around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `for` and `in` keywords of a given node if usage of spacing
       * around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `for` and `of` keywords of a given node if usage of spacing
       * around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `async` or `function` keywords of a given node if usage of
       * spacing around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `if` and `else` keywords of a given node if usage of spacing
       * around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `as` keyword of a given node if usage of spacing around this
       * keyword is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `import`, `export`, `as`, and `from` keywords of a given node if
       * usage of spacing around those keywords is invalid.
       *
       * This rule handles the `*` token in module declarations.
       *
       *     import*as A from "./a"; /*error Expected space(s) after "import".
       *                               error Expected space(s) before "as".
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `static`, `get`, and `set` keywords of a given node if usage of
       * spacing around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports `try`, `catch`, and `finally` keywords of a given node if usage
       * of spacing around those keywords is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      /**
       * Reports a given token if there are not space(s) after the token.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp} pattern - A pattern of the next token to check.
       * @returns {void}
       */
      /**
       * Reports a given token if there are not space(s) before the token.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp} pattern - A pattern of the previous token to check.
       * @returns {void}
       */
      /**
       * Parses the option object and determines check methods for each keyword.
       *
       * @param {Object|undefined} options - The option object to parse.
       * @returns {Object} - Normalized option object.
       *      Keys are keywords (there are for every keyword).
       *      Values are instances of `{"before": function, "after": function}`.
       */
      /**
       * Reports a given token if there are space(s) after the token.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp} pattern - A pattern of the next token to check.
       * @returns {void}
       */
      /**
       * Reports a given token if there are space(s) before the token.
       *
       * @param {Token} token - A token to report.
       * @param {RegExp} pattern - A pattern of the previous token to check.
       * @returns {void}
       */
      var checkMethodMap, checkSpacingAfter, checkSpacingAround, checkSpacingAroundFirstToken, checkSpacingAroundTokenBefore, checkSpacingBefore, checkSpacingBeforeFirstToken, checkSpacingForAwaitExpression, checkSpacingForClass, checkSpacingForDoWhileStatement, checkSpacingForFor, checkSpacingForForInStatement, checkSpacingForForOfStatement, checkSpacingForFunction, checkSpacingForIfStatement, checkSpacingForImportNamespaceSpecifier, checkSpacingForModuleDeclaration, checkSpacingForProperty, checkSpacingForTryStatement, checkSpacingForWhileStatement, expectSpaceAfter, expectSpaceBefore, parseOptions, sourceCode, unexpectSpaceAfter, unexpectSpaceBefore;
      sourceCode = context.getSourceCode();
      expectSpaceBefore = function(token, pattern) {
        var prevToken;
        prevToken = sourceCode.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
          return context.report({
            loc: token.loc.start,
            message: 'Expected space(s) before "{{value}}".',
            data: token,
            fix: function(fixer) {
              return fixer.insertTextBefore(token, ' ');
            }
          });
        }
      };
      unexpectSpaceBefore = function(token, pattern) {
        var prevToken;
        prevToken = sourceCode.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
          return context.report({
            loc: token.loc.start,
            message: 'Unexpected space(s) before "{{value}}".',
            data: token,
            fix: function(fixer) {
              return fixer.removeRange([prevToken.range[1], token.range[0]]);
            }
          });
        }
      };
      expectSpaceAfter = function(token, pattern) {
        var nextToken;
        nextToken = sourceCode.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
          return context.report({
            loc: token.loc.start,
            message: 'Expected space(s) after "{{value}}".',
            data: token,
            fix: function(fixer) {
              return fixer.insertTextAfter(token, ' ');
            }
          });
        }
      };
      unexpectSpaceAfter = function(token, pattern) {
        var nextToken;
        nextToken = sourceCode.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
          return context.report({
            loc: token.loc.start,
            message: 'Unexpected space(s) after "{{value}}".',
            data: token,
            fix: function(fixer) {
              return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
          });
        }
      };
      parseOptions = function(options) {
        var after, before, defaultValue, j, key, len, override, overrides, retv, thisAfter, thisBefore;
        before = !options || options.before !== false;
        after = !options || options.after !== false;
        defaultValue = {
          before: before ? expectSpaceBefore : unexpectSpaceBefore,
          after: after ? expectSpaceAfter : unexpectSpaceAfter
        };
        overrides = (options != null ? options.overrides : void 0) || {};
        retv = Object.create(null);
        for (j = 0, len = KEYS.length; j < len; j++) {
          key = KEYS[j];
          override = overrides[key];
          if (override) {
            thisBefore = 'before' in override ? override.before : before;
            thisAfter = 'after' in override ? override.after : after;
            retv[key] = {
              before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
              after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
            };
          } else {
            retv[key] = defaultValue;
          }
        }
        return retv;
      };
      checkMethodMap = parseOptions(context.options[0]);
      checkSpacingBefore = function(token, pattern) {
        return checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
      };
      checkSpacingAfter = function(token, pattern) {
        return checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
      };
      checkSpacingAround = function(token) {
        checkSpacingBefore(token);
        return checkSpacingAfter(token);
      };
      checkSpacingAroundFirstToken = function(node) {
        var firstToken;
        firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === 'Keyword') {
          return checkSpacingAround(firstToken);
        }
      };
      checkSpacingBeforeFirstToken = function(node) {
        var firstToken;
        firstToken = node && sourceCode.getFirstToken(node);
        if ((firstToken != null ? firstToken.type : void 0) === 'Keyword') {
          return checkSpacingBefore(firstToken);
        }
      };
      checkSpacingAroundTokenBefore = function(node) {
        var token;
        if (node) {
          token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
          return checkSpacingAround(token);
        }
      };
      checkSpacingForFunction = function(node) {
        var firstToken;
        firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && ((firstToken.type === 'Keyword' && firstToken.value === 'function') || firstToken.value === 'async')) {
          return checkSpacingBefore(firstToken);
        }
      };
      checkSpacingForClass = function(node) {
        checkSpacingAroundFirstToken(node);
        return checkSpacingAroundTokenBefore(node.superClass);
      };
      checkSpacingForIfStatement = function(node) {
        var token;
        if (node.postfix) {
          checkSpacingAroundTokenBefore(node.test);
        } else {
          checkSpacingAroundFirstToken(node);
        }
        token = sourceCode.getTokenBefore(node.consequent, astUtils.isKeywordToken);
        if ((token != null ? token.value : void 0) !== 'then') {
          token = sourceCode.getFirstToken(node.consequent);
        }
        if ((token != null ? token.value : void 0) === 'then') {
          checkSpacingAround(token);
        }
        if (node.alternate) {
          token = sourceCode.getTokenBefore(node.alternate, astUtils.isKeywordToken);
          if ((token != null ? token.value : void 0) !== 'else') {
            token = sourceCode.getFirstToken(node.alternate);
          }
          if ((token != null ? token.value : void 0) === 'else') {
            return checkSpacingAround(token);
          }
        }
      };
      checkSpacingForTryStatement = function(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundFirstToken(node.handler);
        return checkSpacingAroundTokenBefore(node.finalizer);
      };
      checkSpacingForDoWhileStatement = function(node) {
        checkSpacingAroundFirstToken(node);
        return checkSpacingAroundTokenBefore(node.test);
      };
      checkSpacingForWhileStatement = function(node) {
        var token;
        if (node.postfix) {
          checkSpacingAroundTokenBefore(node.test);
        } else {
          checkSpacingAroundFirstToken(node);
        }
        token = sourceCode.getTokenBefore(node.body, astUtils.isKeywordToken);
        if ((token != null ? token.value : void 0) !== 'then') {
          token = sourceCode.getFirstToken(node.body);
        }
        if ((token != null ? token.value : void 0) === 'then') {
          return checkSpacingAround(token);
        }
      };
      checkSpacingForForInStatement = function(node) {
        checkSpacingAroundFirstToken(node);
        return checkSpacingAroundTokenBefore(node.right);
      };
      checkSpacingForForOfStatement = function(node) {
        if (node.await) {
          checkSpacingBefore(sourceCode.getFirstToken(node, 0));
          checkSpacingAfter(sourceCode.getFirstToken(node, 1));
        } else {
          checkSpacingAroundFirstToken(node);
        }
        return checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
      };
      checkSpacingForFor = function(node) {
        var token;
        if (node.postfix) {
          // TODO: postfix await, when, by
          // if node.await
          //   checkSpacingBefore sourceCode.getFirstToken node, 0
          //   checkSpacingAfter sourceCode.getFirstToken node, 1
          // else
          checkSpacingAround(sourceCode.getTokenAfter(node.body));
        } else if (node.await) {
          checkSpacingBefore(sourceCode.getFirstToken(node, 0));
          checkSpacingAfter(sourceCode.getFirstToken(node, 1));
        } else {
          checkSpacingAroundFirstToken(node);
        }
        checkSpacingAround(sourceCode.getTokenBefore(node.source, astUtils.isNotOpeningParenToken));
        token = sourceCode.getTokenBefore(node.body, astUtils.isKeywordToken);
        if ((token != null ? token.value : void 0) !== 'then') {
          token = sourceCode.getFirstToken(node.body);
        }
        if ((token != null ? token.value : void 0) === 'then') {
          return checkSpacingAround(token);
        }
      };
      checkSpacingForModuleDeclaration = function(node) {
        var firstToken, fromToken;
        firstToken = sourceCode.getFirstToken(node);
        checkSpacingBefore(firstToken, PREV_TOKEN_M);
        checkSpacingAfter(firstToken, NEXT_TOKEN_M);
        if (node.source) {
          fromToken = sourceCode.getTokenBefore(node.source);
          checkSpacingBefore(fromToken, PREV_TOKEN_M);
          return checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        }
      };
      checkSpacingForImportNamespaceSpecifier = function(node) {
        var asToken;
        asToken = sourceCode.getFirstToken(node, 1);
        return checkSpacingBefore(asToken, PREV_TOKEN_M);
      };
      checkSpacingForProperty = function(node) {
        if (node.static) {
          return checkSpacingAroundFirstToken(node);
        }
      };
      // if (
      //   node.kind in ['get', 'set'] or
      //   ((node.method or node.type is 'MethodDefinition') and node.value.async)
      // )
      //   token = sourceCode.getTokenBefore node.key, (tok) ->
      //     switch tok.value
      //       when 'get', 'set', 'async'
      //         return yes
      //       else
      //         return no

      //   unless token
      //     throw new Error(
      //       'Failed to find token get, set, or async beside method name'
      //     )

      //   checkSpacingAround token
      /**
       * Reports `await` keyword of a given node if usage of spacing before
       * this keyword is invalid.
       *
       * @param {ASTNode} node - A node to report.
       * @returns {void}
       */
      checkSpacingForAwaitExpression = function(node) {
        return checkSpacingBefore(sourceCode.getFirstToken(node));
      };
      return {
        // Statements
        DebuggerStatement: checkSpacingAroundFirstToken,
        WithStatement: checkSpacingAroundFirstToken,
        // Statements - Control flow
        BreakStatement: checkSpacingAroundFirstToken,
        ContinueStatement: checkSpacingAroundFirstToken,
        ReturnStatement: checkSpacingAroundFirstToken,
        ThrowStatement: checkSpacingAroundFirstToken,
        TryStatement: checkSpacingForTryStatement,
        // Statements - Choice
        IfStatement: checkSpacingForIfStatement,
        ConditionalExpression: checkSpacingForIfStatement,
        SwitchStatement: checkSpacingAroundFirstToken,
        SwitchCase: checkSpacingAroundFirstToken,
        // Statements - Loops
        DoWhileStatement: checkSpacingForDoWhileStatement,
        ForInStatement: checkSpacingForForInStatement,
        ForOfStatement: checkSpacingForForOfStatement,
        For: checkSpacingForFor,
        ForStatement: checkSpacingAroundFirstToken,
        WhileStatement: checkSpacingForWhileStatement,
        // Statements - Declarations
        ClassDeclaration: checkSpacingForClass,
        ExportNamedDeclaration: checkSpacingForModuleDeclaration,
        ExportDefaultDeclaration: checkSpacingAroundFirstToken,
        ExportAllDeclaration: checkSpacingForModuleDeclaration,
        FunctionDeclaration: checkSpacingForFunction,
        ImportDeclaration: checkSpacingForModuleDeclaration,
        VariableDeclaration: checkSpacingAroundFirstToken,
        // Expressions
        ArrowFunctionExpression: checkSpacingForFunction,
        AwaitExpression: checkSpacingForAwaitExpression,
        ClassExpression: checkSpacingForClass,
        FunctionExpression: checkSpacingForFunction,
        NewExpression: checkSpacingBeforeFirstToken,
        Super: checkSpacingBeforeFirstToken,
        ThisExpression: checkSpacingBeforeFirstToken,
        UnaryExpression: checkSpacingAroundFirstToken,
        YieldExpression: checkSpacingBeforeFirstToken,
        // Others
        ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
        MethodDefinition: checkSpacingForProperty,
        Property: checkSpacingForProperty
      };
    }
  };

}).call(this);
