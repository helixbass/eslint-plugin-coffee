// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview enforce consistent line breaks inside jsx curly
   */
  'use strict';
  var docsUrl, getNormalizedOption;

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  getNormalizedOption = function(context) {
    var rawOption;
    rawOption = context.options[0] || 'consistent';
    if (rawOption === 'consistent') {
      return {
        multiline: 'consistent',
        singleline: 'consistent'
      };
    }
    if (rawOption === 'never') {
      return {
        multiline: 'forbid',
        singleline: 'forbid'
      };
    }
    return {
      multiline: rawOption.multiline || 'consistent',
      singleline: rawOption.singleline || 'consistent'
    };
  };

  module.exports = {
    meta: {
      type: 'layout',
      docs: {
        description: 'enforce consistent line breaks inside jsx curly',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-curly-newline')
      },
      // fixable: 'whitespace'
      schema: [
        {
          oneOf: [
            {
              enum: ['consistent',
            'never']
            },
            {
              type: 'object',
              properties: {
                singleline: {
                  enum: ['consistent',
            'require',
            'forbid']
                },
                multiline: {
                  enum: ['consistent',
            'require',
            'forbid']
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        expectedBefore: "Expected newline before '}'.",
        expectedAfter: "Expected newline after '{'.",
        unexpectedBefore: "Unexpected newline before '{'.",
        unexpectedAfter: "Unexpected newline after '}'."
      }
    },
    create: function(context) {
      /**
       * Determines whether there should be newlines inside curlys
       * @param {ASTNode} expression The expression contained in the curlys
       * @param {boolean} hasLeftNewline `true` if the left curly has a newline in the current code.
       * @returns {boolean} `true` if there should be newlines inside the function curlys
       */
      /**
       * Validates curlys
       * @param {Object} curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
       * @param {ASTNode} expression The expression inside the curly
       * @returns {void}
       */
      var isTokenOnSameLine, option, shouldHaveNewlines, sourceCode, validateCurlys;
      sourceCode = context.getSourceCode();
      option = getNormalizedOption(context);
      // ----------------------------------------------------------------------
      // Helpers
      // ----------------------------------------------------------------------
      /**
       * Determines whether two adjacent tokens are on the same line.
       * @param {Object} left - The left token object.
       * @param {Object} right - The right token object.
       * @returns {boolean} Whether or not the tokens are on the same line.
       */
      isTokenOnSameLine = function(left, right) {
        return left.loc.end.line === right.loc.start.line;
      };
      shouldHaveNewlines = function(expression, hasLeftNewline) {
        var isMultiline;
        isMultiline = expression.loc.start.line !== expression.loc.end.line;
        switch ((isMultiline ? option.multiline : option.singleline)) {
          case 'forbid':
            return false;
          case 'require':
            return true;
          default:
            return hasLeftNewline;
        }
      };
      validateCurlys = function(curlys, expression) {
        var hasLeftNewline, hasRightNewline, leftCurly, needsNewlines, rightCurly, tokenAfterLeftCurly, tokenBeforeRightCurly;
        ({leftCurly} = curlys);
        ({rightCurly} = curlys);
        tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);
        tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);
        hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);
        hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);
        needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);
        if (hasLeftNewline && !needsNewlines) {
          context.report({
            node: leftCurly,
            messageId: 'unexpectedAfter'
          });
        // fix: (fixer) ->
        //   condition =
        //     sourceCode
        //     .getText()
        //     .slice leftCurly.range[1], tokenAfterLeftCurly.range[0]
        //     .trim()
        //   if condition
        //     null
        //   # If there is a comment between the { and the first element, don't do a fix.
        //   else
        //     fixer.removeRange [
        //       leftCurly.range[1]
        //       tokenAfterLeftCurly.range[0]
        //     ]
        } else if (!hasLeftNewline && needsNewlines) {
          context.report({
            node: leftCurly,
            messageId: 'expectedAfter'
          });
        }
        // fix: (fixer) -> fixer.insertTextAfter leftCurly, '\n'
        if (hasRightNewline && !needsNewlines) {
          return context.report({
            node: rightCurly,
            messageId: 'unexpectedBefore'
          });
        // fix: (fixer) ->
        //   condition =
        //     sourceCode
        //     .getText()
        //     .slice tokenBeforeRightCurly.range[1], rightCurly.range[0]
        //     .trim()
        //   if condition
        //     null
        //   # If there is a comment between the last element and the }, don't do a fix.
        //   else
        //     fixer.removeRange [
        //       tokenBeforeRightCurly.range[1]
        //       rightCurly.range[0]
        //     ]
        } else if (!hasRightNewline && needsNewlines) {
          return context.report({
            node: rightCurly,
            messageId: 'expectedBefore'
          });
        }
      };
      return {
        // fix: (fixer) -> fixer.insertTextBefore rightCurly, '\n'

        // ----------------------------------------------------------------------
        // Public
        // ----------------------------------------------------------------------
        JSXExpressionContainer: function(node) {
          var curlyTokens;
          curlyTokens = {
            leftCurly: sourceCode.getFirstToken(node),
            rightCurly: sourceCode.getLastToken(node)
          };
          return validateCurlys(curlyTokens, node.expression);
        }
      };
    }
  };

}).call(this);
