// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to enforce line breaks after each array element
   * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>
   */
  'use strict';
  var astUtils, hasIndentedLastLine;

  astUtils = require('../eslint-ast-utils');

  ({hasIndentedLastLine} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce line breaks after each array element',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/array-element-newline'
      },
      // fixable: 'whitespace'
      schema: [
        {
          oneOf: [
            {
              enum: ['always',
            'never',
            'consistent']
            },
            {
              type: 'object',
              properties: {
                multiline: {
                  type: 'boolean'
                },
                minItems: {
                  type: ['integer',
            'null'],
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedLineBreak: 'There should be no linebreak here.',
        missingLineBreak: 'There should be a linebreak after this element.'
      }
    },
    create: function(context) {
      /**
       * Reports a given node if it violated this rule.
       *
       * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
       * @param {{multiline: boolean, minItems: number}} options - An option object.
       * @returns {void}
       */
      /**
       * Normalizes a given option value.
       *
       * @param {string|Object|undefined} options - An option value to parse.
       * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
       */
      /**
       * Reports that there shouldn't be a line break after the first token
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      var check, getFirstTokenOfNextElement, getLastTokenOfPreviousElement, normalizeOptionValue, normalizeOptions, reportNoLineBreak, reportRequiredLineBreak, sourceCode;
      sourceCode = context.getSourceCode();
      //----------------------------------------------------------------------
      // Helpers
      //----------------------------------------------------------------------
      /**
       * Normalizes a given option value.
       *
       * @param {string|Object|undefined} providedOption - An option value to parse.
       * @returns {{multiline: boolean, minItems: number}} Normalized option object.
       */
      normalizeOptionValue = function(providedOption) {
        var consistent, minItems, multiline, option;
        consistent = false;
        multiline = false;
        option = providedOption || 'always';
        if (!option || option === 'always' || option.minItems === 0) {
          minItems = 0;
        } else if (option === 'never') {
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === 'consistent') {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
        return {consistent, multiline, minItems};
      };
      normalizeOptions = function(options) {
        var value;
        value = normalizeOptionValue(options);
        return {
          ArrayExpression: value,
          ArrayPattern: value
        };
      };
      reportNoLineBreak = function(token) {
        var tokenBefore;
        tokenBefore = sourceCode.getTokenBefore(token, {
          includeComments: true
        });
        return context.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: 'unexpectedLineBreak'
        });
      };
      // fix: (fixer) ->
      //   return null if astUtils.isCommentToken tokenBefore

      //   return fixer.replaceTextRange(
      //     [tokenBefore.range[1], token.range[0]]
      //     ' '
      //   ) unless astUtils.isTokenOnSameLine tokenBefore, token

      //   ###
      //   # This will check if the comma is on the same line as the next element
      //   # Following array:
      //   # [
      //   #     1
      //   #     , 2
      //   #     , 3
      //   # ]
      //   #
      //   # will be fixed to:
      //   # [
      //   #     1, 2, 3
      //   # ]
      //   ###
      //   twoTokensBefore = sourceCode.getTokenBefore tokenBefore,
      //     includeComments: yes

      //   return null if astUtils.isCommentToken twoTokensBefore

      //   fixer.replaceTextRange(
      //     [twoTokensBefore.range[1], tokenBefore.range[0]]
      //     ''
      //   )
      /**
       * Reports that there should be a line break after the first token
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      reportRequiredLineBreak = function(token) {
        var tokenBefore;
        tokenBefore = sourceCode.getTokenBefore(token, {
          includeComments: true
        });
        return context.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: 'missingLineBreak'
        });
      };
      // fix: (fixer) ->
      //   fixer.replaceTextRange [tokenBefore.range[1], token.range[0]], '\n'
      getLastTokenOfPreviousElement = function(element) {
        return sourceCode.getTokenBefore(element, {
          filter: function(token) {
            return token.value !== '(' && !astUtils.isCommaToken(token);
          }
        });
      };
      getFirstTokenOfNextElement = function(element) {
        return sourceCode.getTokenAfter(element, {
          filter: function(token) {
            return token.value !== ')' && !astUtils.isCommaToken(token);
          }
        });
      };
      check = function(node) {
        var elementBreak, elements, linebreaksCount, needsLinebreaks, normalizedOptions, options;
        ({elements} = node);
        normalizedOptions = normalizeOptions(context.options[0]);
        options = normalizedOptions[node.type];
        elementBreak = false;
        /*
         * MULTILINE: true
         * loop through every element and check
         * if at least one element has linebreaks inside
         * this ensures that following is not valid (due to elements are on the same line):
         *
         * [
         *      1,
         *      2,
         *      3
         * ]
         */
        if (options.multiline) {
          elementBreak = elements.filter(function(element) {
            return element !== null;
          }).some(function(element) {
            return element.loc.start.line !== element.loc.end.line;
          });
        }
        linebreaksCount = elements.map(function(element, i) {
          var firstTokenOfCurrentElement, lastTokenOfPreviousElement, previousElement;
          previousElement = elements[i - 1];
          if (i === 0 || element === null || previousElement === null) {
            return false;
          }
          // commaToken = sourceCode.getFirstTokenBetween(
          //   previousElement
          //   element
          //   astUtils.isCommaToken
          // )
          // lastTokenOfPreviousElement = sourceCode.getTokenBefore commaToken
          // firstTokenOfCurrentElement = sourceCode.getTokenAfter commaToken
          lastTokenOfPreviousElement = getLastTokenOfPreviousElement(element);
          firstTokenOfCurrentElement = getFirstTokenOfNextElement(previousElement);
          return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
        }).filter(function(isBreak) {
          return isBreak === true;
        }).length;
        needsLinebreaks = elements.length >= options.minItems || (options.multiline && elementBreak) || (options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length);
        return elements.forEach(function(element, i) {
          var firstTokenOfCurrentElement, lastTokenOfPreviousElement, previousElement;
          previousElement = elements[i - 1];
          if (i === 0 || element === null || previousElement === null) {
            return;
          }
          // commaToken = sourceCode.getFirstTokenBetween(
          //   previousElement
          //   element
          //   astUtils.isCommaToken
          // )
          // lastTokenOfPreviousElement = sourceCode.getTokenBefore commaToken
          // firstTokenOfCurrentElement = sourceCode.getTokenAfter commaToken
          lastTokenOfPreviousElement = getLastTokenOfPreviousElement(element);
          firstTokenOfCurrentElement = getFirstTokenOfNextElement(previousElement);
          if (needsLinebreaks) {
            if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
              return reportRequiredLineBreak(firstTokenOfCurrentElement);
            }
          } else if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
            if (hasIndentedLastLine({
              node: element,
              sourceCode
            })) {
              return;
            }
            return reportNoLineBreak(firstTokenOfCurrentElement);
          }
        });
      };
      return {
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        ArrayPattern: check,
        ArrayExpression: check
      };
    }
  };

}).call(this);
