// Generated by CoffeeScript 2.5.0
(function() {
  'use strict';
  var canCrossNodeWhileReorder, canReorderItems, commentOnSameLineAs, computePathRank, computeRank, convertGroupsToRanks, convertPathGroupsForRanks, defaultGroups, docsUrl, findEndOfLineWithComments, findOutOfOrder, findRootNode, findStartOfLineWithComments, fixNewLineAfterImport, fixOutOfOrder, getAlphabetizeConfig, getTokensOrCommentsAfter, getTokensOrCommentsBefore, importType, importsSorterAsc, importsSorterDesc, isInVariableDeclaratorOrAssignment, isPlainImportModule, isPlainRequireModule, isStaticRequire, makeNewlinesBetweenReport, makeOutOfOrderReport, minimatch, mutateRanksToAlphabetize, registerNode, removeNewLineAfterImport, reportOutOfOrder, reverse, takeTokensAfterWhile, takeTokensBeforeWhile, types;

  minimatch = require('minimatch');

  ({
    default: importType
  } = require('eslint-plugin-import/lib/core/importType'));

  ({
    default: isStaticRequire
  } = require('eslint-plugin-import/lib/core/staticRequire'));

  ({
    default: docsUrl
  } = require('eslint-plugin-import/lib/docsUrl'));

  defaultGroups = ['builtin', 'external', 'parent', 'sibling', 'index'];

  // REPORTING AND FIXING
  reverse = function(array) {
    return array.map(function(v) {
      return {
        name: v.name,
        rank: -v.rank,
        node: v.node
      };
    }).reverse();
  };

  getTokensOrCommentsAfter = function(sourceCode, node, count) {
    var currentNodeOrToken, i, result;
    currentNodeOrToken = node;
    result = [];
    i = 0;
    while (i < count) {
      currentNodeOrToken = sourceCode.getTokenOrCommentAfter(currentNodeOrToken);
      if (currentNodeOrToken == null) {
        break;
      }
      result.push(currentNodeOrToken);
      i++;
    }
    return result;
  };

  getTokensOrCommentsBefore = function(sourceCode, node, count) {
    var currentNodeOrToken, i, result;
    currentNodeOrToken = node;
    result = [];
    i = 0;
    while (i < count) {
      currentNodeOrToken = sourceCode.getTokenOrCommentBefore(currentNodeOrToken);
      if (currentNodeOrToken == null) {
        break;
      }
      result.push(currentNodeOrToken);
      i++;
    }
    return result.reverse();
  };

  takeTokensAfterWhile = function(sourceCode, node, condition) {
    var i, result, tokens;
    tokens = getTokensOrCommentsAfter(sourceCode, node, 100);
    result = [];
    i = 0;
    while (i < tokens.length) {
      if (condition(tokens[i])) {
        result.push(tokens[i]);
      } else {
        break;
      }
      i++;
    }
    return result;
  };

  takeTokensBeforeWhile = function(sourceCode, node, condition) {
    var i, result, tokens;
    tokens = getTokensOrCommentsBefore(sourceCode, node, 100);
    result = [];
    i = tokens.length - 1;
    while (i >= 0) {
      if (condition(tokens[i])) {
        result.push(tokens[i]);
      } else {
        break;
      }
      i--;
    }
    return result.reverse();
  };

  findOutOfOrder = function(imported) {
    var maxSeenRankNode;
    if (imported.length === 0) {
      return [];
    }
    maxSeenRankNode = imported[0];
    return imported.filter(function(importedModule) {
      var res;
      res = importedModule.rank < maxSeenRankNode.rank;
      if (maxSeenRankNode.rank < importedModule.rank) {
        maxSeenRankNode = importedModule;
      }
      return res;
    });
  };

  findRootNode = function(node) {
    var parent;
    parent = node;
    while ((parent.parent != null) && (parent.parent.body == null)) {
      ({parent} = parent);
    }
    return parent;
  };

  findEndOfLineWithComments = function(sourceCode, node) {
    var endOfTokens, i, result, tokensToEndOfLine;
    tokensToEndOfLine = takeTokensAfterWhile(sourceCode, node, commentOnSameLineAs(node));
    endOfTokens = tokensToEndOfLine.length > 0 ? tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1] : node.range[1];
    result = endOfTokens;
    i = endOfTokens;
    while (i < sourceCode.text.length) {
      if (sourceCode.text[i] === '\n') {
        result = i + 1;
        break;
      }
      if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\t' && sourceCode.text[i] !== '\r') {
        break;
      }
      result = i + 1;
      i++;
    }
    return result;
  };

  commentOnSameLineAs = function(node) {
    return function(token) {
      var ref;
      return ((ref = token.type) === 'Block' || ref === 'Line') && token.loc.start.line === token.loc.end.line && token.loc.end.line === node.loc.end.line;
    };
  };

  findStartOfLineWithComments = function(sourceCode, node) {
    var i, result, startOfTokens, tokensToEndOfLine;
    tokensToEndOfLine = takeTokensBeforeWhile(sourceCode, node, commentOnSameLineAs(node));
    startOfTokens = tokensToEndOfLine.length > 0 ? tokensToEndOfLine[0].range[0] : node.range[0];
    result = startOfTokens;
    i = startOfTokens - 1;
    while (i > 0) {
      if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\t') {
        break;
      }
      result = i;
      i--;
    }
    return result;
  };

  isPlainRequireModule = function(node) {
    var id, init, ref, ref1, ref2, ref3;
    if (node.type === 'VariableDeclaration') {
      if (node.declarations.length !== 1) {
        return false;
      }
      ({id, init} = node.declarations[0]);
    } else if (node.type === 'ExpressionStatement' && ((ref = node.expression) != null ? ref.type : void 0) === 'AssignmentExpression') {
      ({
        left: id,
        right: init
      } = node.expression);
    } else {
      return false;
    }
    return ((ref1 = id != null ? id.type : void 0) === 'Identifier' || ref1 === 'ObjectPattern') && (init != null ? init.type : void 0) === 'CallExpression' && ((ref2 = init.callee) != null ? ref2.name : void 0) === 'require' && ((ref3 = init.arguments) != null ? ref3.length : void 0) === 1 && init.arguments[0].type === 'Literal';
  };

  isPlainImportModule = function(node) {
    var ref;
    return node.type === 'ImportDeclaration' && ((ref = node.specifiers) != null ? ref.length : void 0) > 0;
  };

  canCrossNodeWhileReorder = function(node) {
    return isPlainRequireModule(node) || isPlainImportModule(node);
  };

  canReorderItems = function(firstNode, secondNode) {
    var firstIndex, nodeBetween, nodesBetween, parent, secondIndex;
    ({parent} = firstNode);
    [firstIndex, secondIndex] = [parent.body.indexOf(firstNode), parent.body.indexOf(secondNode)].sort();
    nodesBetween = parent.body.slice(firstIndex, secondIndex + 1);
    for (nodeBetween of nodesBetween) {
      if (!canCrossNodeWhileReorder(nodeBetween)) {
        return false;
      }
    }
    return true;
  };

  fixOutOfOrder = function(context, firstNode, secondNode, order) {
    var canFix, firstRoot, firstRootEnd, firstRootStart, message, newCode, secondRoot, secondRootEnd, secondRootStart, sourceCode;
    sourceCode = context.getSourceCode();
    firstRoot = findRootNode(firstNode.node);
    firstRootStart = findStartOfLineWithComments(sourceCode, firstRoot);
    firstRootEnd = findEndOfLineWithComments(sourceCode, firstRoot);
    secondRoot = findRootNode(secondNode.node);
    secondRootStart = findStartOfLineWithComments(sourceCode, secondRoot);
    secondRootEnd = findEndOfLineWithComments(sourceCode, secondRoot);
    canFix = canReorderItems(firstRoot, secondRoot);
    newCode = sourceCode.text.substring(secondRootStart, secondRootEnd);
    if (newCode[newCode.length - 1] !== '\n') {
      newCode += '\n';
    }
    message = `\`${secondNode.name}\` import should occur ${order} import of \`${firstNode.name}\``;
    if (order === 'before') {
      return context.report({
        node: secondNode.node,
        message,
        fix: canFix && function(fixer) {
          return fixer.replaceTextRange([firstRootStart, secondRootEnd], newCode + sourceCode.text.substring(firstRootStart, secondRootStart));
        }
      });
    } else if (order === 'after') {
      return context.report({
        node: secondNode.node,
        message,
        fix: canFix && function(fixer) {
          return fixer.replaceTextRange([secondRootStart, firstRootEnd], sourceCode.text.substring(secondRootEnd, firstRootEnd) + (/\n\s*$/.test(sourceCode.text.substring(secondRootEnd, firstRootEnd)) ? '' : '\n') + newCode);
        }
      });
    }
  };

  reportOutOfOrder = function(context, imported, outOfOrder, order) {
    return outOfOrder.forEach(function(imp) {
      var found;
      found = imported.find(function(importedItem) {
        return importedItem.rank > imp.rank;
      });
      return fixOutOfOrder(context, found, imp, order);
    });
  };

  makeOutOfOrderReport = function(context, imported) {
    var outOfOrder, reversedImported, reversedOrder;
    outOfOrder = findOutOfOrder(imported);
    if (!outOfOrder.length) {
      return;
    }
    // There are things to report. Try to minimize the number of reported errors.
    reversedImported = reverse(imported);
    reversedOrder = findOutOfOrder(reversedImported);
    if (reversedOrder.length < outOfOrder.length) {
      reportOutOfOrder(context, reversedImported, reversedOrder, 'after');
      return;
    }
    return reportOutOfOrder(context, imported, outOfOrder, 'before');
  };

  importsSorterAsc = function(importA, importB) {
    if (importA < importB) {
      return -1;
    }
    if (importA > importB) {
      return 1;
    }
    return 0;
  };

  importsSorterDesc = function(importA, importB) {
    if (importA < importB) {
      return 1;
    }
    if (importA > importB) {
      return -1;
    }
    return 0;
  };

  mutateRanksToAlphabetize = function(imported, order) {
    var alphabetizedRanks, groupRanks, groupedByRanks, newRank, sorterFn;
    groupedByRanks = imported.reduce(function(acc, importedItem) {
      if (!Array.isArray(acc[importedItem.rank])) {
        acc[importedItem.rank] = [];
      }
      acc[importedItem.rank].push(importedItem.name);
      return acc;
    }, {});
    groupRanks = Object.keys(groupedByRanks);
    sorterFn = order === 'asc' ? importsSorterAsc : importsSorterDesc;
    // sort imports locally within their group
    groupRanks.forEach(function(groupRank) {
      return groupedByRanks[groupRank].sort(sorterFn);
    });
    // assign globally unique rank to each import
    newRank = 0;
    alphabetizedRanks = groupRanks.sort().reduce(function(acc, groupRank) {
      groupedByRanks[groupRank].forEach(function(importedItemName) {
        acc[importedItemName] = newRank;
        return newRank += 1;
      });
      return acc;
    }, {});
    // mutate the original group-rank with alphabetized-rank
    return imported.forEach(function(importedItem) {
      return importedItem.rank = alphabetizedRanks[importedItem.name];
    });
  };

  // DETECTING
  computePathRank = function(ranks, pathGroups, path, maxPosition) {
    var group, i, l, pattern, patternOptions, position;
    i = 0;
    l = pathGroups.length;
    while (i < l) {
      ({pattern, patternOptions, group, position = 1} = pathGroups[i]);
      if (minimatch(path, pattern, patternOptions || {
        nocomment: true
      })) {
        return ranks[group] + position / maxPosition;
      }
      i++;
    }
  };

  computeRank = function(context, ranks, name, type) {
    var impType, rank;
    impType = importType(name, context);
    if (impType !== 'builtin' && impType !== 'external') {
      rank = computePathRank(ranks.groups, ranks.pathGroups, name, ranks.maxPosition);
    }
    if (!rank) {
      rank = ranks.groups[impType];
    }
    if (type !== 'import') {
      rank += 100;
    }
    return rank;
  };

  registerNode = function(context, node, name, type, ranks, imported) {
    var rank;
    rank = computeRank(context, ranks, name, type);
    if (rank !== -1) {
      return imported.push({name, rank, node});
    }
  };

  isInVariableDeclaratorOrAssignment = function(node) {
    var ref;
    if (!node) {
      return false;
    }
    if (node.type === 'VariableDeclarator') {
      return true;
    }
    // return yes if (
    //   node.parent?.type is 'AssignmentExpression' and node is node.parent.right
    // )
    if (((ref = node.parent) != null ? ref.type : void 0) === 'AssignmentExpression' && node === node.parent.right) {
      return true;
    }
    if (isInVariableDeclaratorOrAssignment(node.parent)) {
      return true;
    }
    return false;
  };

  types = ['builtin', 'external', 'internal', 'unknown', 'parent', 'sibling', 'index'];

  // Creates an object with type-rank pairs.
  // Example: { index: 0, sibling: 1, parent: 1, external: 1, builtin: 2, internal: 2 }
  // Will throw an error if it contains a type that does not exist, or has a duplicate
  convertGroupsToRanks = function(groups) {
    var omittedTypes, rankObject;
    rankObject = groups.reduce(function(res, group, index) {
      if (typeof group === 'string') {
        group = [group];
      }
      group.forEach(function(groupItem) {
        if (types.indexOf(groupItem) === -1) {
          throw new Error(`Incorrect configuration of the rule: Unknown type \`${JSON.stringify(groupItem)}\``);
        }
        if (res[groupItem] !== void 0) {
          throw new Error(`Incorrect configuration of the rule: \`${groupItem}\` is duplicated`);
        }
        return res[groupItem] = index;
      });
      return res;
    }, {});
    omittedTypes = types.filter(function(type) {
      return rankObject[type] === void 0;
    });
    return omittedTypes.reduce(function(res, type) {
      res[type] = groups.length;
      return res;
    }, rankObject);
  };

  convertPathGroupsForRanks = function(pathGroups) {
    var after, before, maxPosition, transformed;
    after = {};
    before = {};
    transformed = pathGroups.map(function(pathGroup, index) {
      var group, position, positionString;
      ({
        group,
        position: positionString
      } = pathGroup);
      position = 0;
      if (positionString === 'after') {
        if (!after[group]) {
          after[group] = 1;
        }
        position = after[group]++;
      } else if (positionString === 'before') {
        if (!before[group]) {
          before[group] = [];
        }
        before[group].push(index);
      }
      return Object.assign({}, pathGroup, {position});
    });
    maxPosition = 1;
    Object.keys(before).forEach(function(group) {
      var groupLength;
      groupLength = before[group].length;
      before[group].forEach(function(groupIndex, index) {
        return transformed[groupIndex].position = -1 * (groupLength - index);
      });
      return maxPosition = Math.max(maxPosition, groupLength);
    });
    Object.keys(after).forEach(function(key) {
      var groupNextPosition;
      groupNextPosition = after[key];
      return maxPosition = Math.max(maxPosition, groupNextPosition - 1);
    });
    return {
      pathGroups: transformed,
      maxPosition: maxPosition > 10 ? Math.pow(10, Math.ceil(Math.log10(maxPosition))) : 10
    };
  };

  fixNewLineAfterImport = function(context, previousImport) {
    var endOfLine, prevRoot, tokensToEndOfLine;
    prevRoot = findRootNode(previousImport.node);
    tokensToEndOfLine = takeTokensAfterWhile(context.getSourceCode(), prevRoot, commentOnSameLineAs(prevRoot));
    endOfLine = prevRoot.range[1];
    if (tokensToEndOfLine.length > 0) {
      endOfLine = tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1];
    }
    return function(fixer) {
      return fixer.insertTextAfterRange([prevRoot.range[0], endOfLine], '\n');
    };
  };

  removeNewLineAfterImport = function(context, currentImport, previousImport) {
    var currRoot, prevRoot, rangeToRemove, sourceCode;
    sourceCode = context.getSourceCode();
    prevRoot = findRootNode(previousImport.node);
    currRoot = findRootNode(currentImport.node);
    rangeToRemove = [findEndOfLineWithComments(sourceCode, prevRoot), findStartOfLineWithComments(sourceCode, currRoot)];
    if (/^\s*$/.test(sourceCode.text.substring(rangeToRemove[0], rangeToRemove[1]))) {
      return function(fixer) {
        return fixer.removeRange(rangeToRemove);
      };
    }
    return void 0;
  };

  makeNewlinesBetweenReport = function(context, imported, newlinesBetweenImports) {
    var getNumberOfEmptyLinesBetween, previousImport;
    getNumberOfEmptyLinesBetween = function(currentImport, previousImport) {
      var linesBetweenImports;
      linesBetweenImports = context.getSourceCode().lines.slice(previousImport.node.loc.end.line, currentImport.node.loc.start.line - 1);
      return linesBetweenImports.filter(function(line) {
        return !line.trim().length;
      }).length;
    };
    previousImport = imported[0];
    return imported.slice(1).forEach(function(currentImport) {
      var emptyLinesBetween;
      emptyLinesBetween = getNumberOfEmptyLinesBetween(currentImport, previousImport);
      if (newlinesBetweenImports === 'always' || newlinesBetweenImports === 'always-and-inside-groups') {
        if (currentImport.rank !== previousImport.rank && emptyLinesBetween === 0) {
          context.report({
            node: previousImport.node,
            message: 'There should be at least one empty line between import groups',
            fix: fixNewLineAfterImport(context, previousImport)
          });
        } else if (currentImport.rank === previousImport.rank && emptyLinesBetween > 0 && newlinesBetweenImports !== 'always-and-inside-groups') {
          context.report({
            node: previousImport.node,
            message: 'There should be no empty line within import group',
            fix: removeNewLineAfterImport(context, currentImport, previousImport)
          });
        }
      } else if (emptyLinesBetween > 0) {
        context.report({
          node: previousImport.node,
          message: 'There should be no empty line between import groups',
          fix: removeNewLineAfterImport(context, currentImport, previousImport)
        });
      }
      return previousImport = currentImport;
    });
  };

  getAlphabetizeConfig = function(options) {
    var alphabetize, order;
    alphabetize = options.alphabetize || {};
    order = alphabetize.order || 'ignore';
    return {order};
  };

  module.exports = {
    meta: {
      type: 'suggestion',
      docs: {
        url: docsUrl('order')
      },
      fixable: 'code',
      schema: [
        {
          type: 'object',
          properties: {
            groups: {
              type: 'array'
            },
            pathGroups: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  pattern: {
                    type: 'string'
                  },
                  patternOptions: {
                    type: 'object'
                  },
                  group: {
                    type: 'string',
                    enum: types
                  },
                  position: {
                    type: 'string',
                    enum: ['after',
        'before']
                  }
                },
                required: ['pattern',
        'group']
              }
            },
            'newlines-between': {
              enum: ['ignore',
        'always',
        'always-and-inside-groups',
        'never']
            },
            alphabetize: {
              type: 'object',
              properties: {
                order: {
                  enum: ['ignore',
        'asc',
        'desc'],
                  default: 'ignore'
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var alphabetize, decrementLevel, error, imported, incrementLevel, level, maxPosition, newlinesBetweenImports, options, pathGroups, ranks;
      options = context.options[0] || {};
      newlinesBetweenImports = options['newlines-between'] || 'ignore';
      alphabetize = getAlphabetizeConfig(options);
      try {
        ({pathGroups, maxPosition} = convertPathGroupsForRanks(options.pathGroups || []));
        ranks = {
          groups: convertGroupsToRanks(options.groups || defaultGroups),
          pathGroups,
          maxPosition
        };
      } catch (error1) {
        error = error1;
        return {
          // Malformed configuration
          Program: function(node) {
            return context.report(node, error.message);
          }
        };
      }
      imported = [];
      level = 0;
      incrementLevel = function() {
        return level++;
      };
      decrementLevel = function() {
        return level--;
      };
      return {
        ImportDeclaration: function(node) {
          var name;
          if (node.specifiers.length) {
            // Ignoring unassigned imports
            name = node.source.value;
            return registerNode(context, node, name, 'import', ranks, imported);
          }
        },
        CallExpression: function(node) {
          var name;
          if (!(level === 0 && isStaticRequire(node) && isInVariableDeclaratorOrAssignment(node))) {
            return;
          }
          name = node.arguments[0].value;
          return registerNode(context, node, name, 'require', ranks, imported);
        },
        'Program:exit': function() {
          if (newlinesBetweenImports !== 'ignore') {
            makeNewlinesBetweenReport(context, imported, newlinesBetweenImports);
          }
          if (alphabetize.order !== 'ignore') {
            mutateRanksToAlphabetize(imported, alphabetize.order);
          }
          makeOutOfOrderReport(context, imported);
          return imported = [];
        },
        FunctionDeclaration: incrementLevel,
        FunctionExpression: incrementLevel,
        ArrowFunctionExpression: incrementLevel,
        BlockStatement: incrementLevel,
        ObjectExpression: incrementLevel,
        'FunctionDeclaration:exit': decrementLevel,
        'FunctionExpression:exit': decrementLevel,
        'ArrowFunctionExpression:exit': decrementLevel,
        'BlockStatement:exit': decrementLevel,
        'ObjectExpression:exit': decrementLevel
      };
    }
  };

}).call(this);
