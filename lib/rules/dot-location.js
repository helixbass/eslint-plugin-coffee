// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Validates newlines before and after dots
   * @author Greg Cochard
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      type: 'layout',
      docs: {
        description: 'enforce consistent newlines before and after dots',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/dot-location'
      },
      schema: [
        {
          enum: ['object',
        'property']
        }
      ],
      fixable: 'code',
      messages: {
        expectedDotAfterObject: 'Expected dot to be on same line as object.',
        expectedDotBeforeProperty: 'Expected dot to be on same line as property.'
      }
    },
    create: function(context) {
      /**
       * Reports if the dot between object and property is on the correct loccation.
       * @param {ASTNode} node The `MemberExpression` node.
       * @returns {void}
       */
      /**
       * Checks the spacing of the dot within a member expression.
       * @param {ASTNode} node The node to check.
       * @returns {void}
       */
      var checkDotLocation, checkNode, config, onObject, sourceCode;
      config = context.options[0];
      // default to onObject if no preference is passed
      onObject = config === 'object' || !config;
      sourceCode = context.getSourceCode();
      checkDotLocation = function(node) {
        var dot, neededTextAfterToken, property, textAfterDot, textBeforeDot, tokenBeforeDot;
        ({property} = node);
        dot = sourceCode.getTokenBefore(property);
        // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.
        tokenBeforeDot = sourceCode.getTokenBefore(dot);
        textBeforeDot = sourceCode.getText().slice(tokenBeforeDot.range[1], dot.range[0]);
        textAfterDot = sourceCode.getText().slice(dot.range[1], property.range[0]);
        if (onObject) {
          if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dot)) {
            neededTextAfterToken = astUtils.isDecimalIntegerNumericToken(tokenBeforeDot) ? ' ' : '';
            return context.report({
              node,
              loc: dot.loc,
              messageId: 'expectedDotAfterObject',
              fix: function(fixer) {
                return fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${neededTextAfterToken}.${textBeforeDot}${textAfterDot}`);
              }
            });
          }
        } else if (!astUtils.isTokenOnSameLine(dot, property)) {
          return context.report({
            node,
            loc: dot.loc,
            messageId: 'expectedDotBeforeProperty',
            fix: function(fixer) {
              return fixer.replaceTextRange([tokenBeforeDot.range[1], property.range[0]], `${textBeforeDot}${textAfterDot}.`);
            }
          });
        }
      };
      checkNode = function(node) {
        if (node.computed) {
          return;
        }
        if (node.shorthand || (node.object.type === 'MemberExpression' && node.object.shorthand) || (node.object.type === 'ThisExpression' && node.object.shorthand)) {
          return;
        }
        return checkDotLocation(node);
      };
      return {
        MemberExpression: checkNode
      };
    }
  };

}).call(this);
