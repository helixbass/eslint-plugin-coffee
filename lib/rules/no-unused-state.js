// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview  Attempts to discover all state fields in a React component and
   * warn if any of them are never read.
   *
   * State field definitions are collected from `this.state = {}` assignments in
   * the constructor, objects passed to `this.setState()`, and `state = {}` class
   * property assignments.
   */
  'use strict';
  var Components, docsUrl, getInitialClassInfo, getName, isThisExpression, uncast;

  Components = require('../util/react/Components');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // Descend through all wrapping TypeCastExpressions and return the expression
  // that was cast.
  uncast = function(node) {
    while (node.type === 'TypeCastExpression') {
      node = node.expression;
    }
    return node;
  };

  // Return the name of an identifier or the string value of a literal. Useful
  // anywhere that a literal may be used as a key (e.g., member expressions,
  // method definitions, ObjectExpression property keys).
  getName = function(node) {
    var type;
    node = uncast(node);
    ({type} = node);
    if (type === 'Identifier') {
      return node.name;
    }
    if (type === 'Literal') {
      return String(node.value);
    }
    if (type === 'TemplateLiteral' && node.expressions.length === 0) {
      return node.quasis[0].value.raw;
    }
    return null;
  };

  isThisExpression = function(node) {
    return uncast(node).type === 'ThisExpression';
  };

  getInitialClassInfo = function() {
    return {
      // Set of nodes where state fields were defined.
      stateFields: new Set(),
      // Set of names of state fields that we've seen used.
      usedStateFields: new Set(),
      // Names of local variables that may be pointing to this.state. To
      // track this properly, we would need to keep track of all locals,
      // shadowing, assignments, etc. To keep things simple, we only
      // maintain one set of aliases per method and accept that it will
      // produce some false negatives.
      aliases: null
    };
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Prevent definition of unused state fields',
        category: 'Best Practices',
        recommended: false,
        url: docsUrl('no-unused-state')
      },
      schema: []
    },
    create: Components.detect(function(context, components, utils) {
      var addStateFields, addUsedStateField, classInfo, handleAssignment, handleStateDestructuring, isStateReference, reportUnusedFields;
      // Non-null when we are inside a React component ClassDeclaration and we have
      // not yet encountered any use of this.state which we have chosen not to
      // analyze. If we encounter any such usage (like this.state being spread as
      // JSX attributes), then this is again set to null.
      classInfo = null;
      // Returns true if the given node is possibly a reference to `this.state`, `prevState` or `nextState`.
      isStateReference = function(node) {
        var isAliasedStateReference, isDirectStateReference, isNextStateReference, isPrevStateReference;
        node = uncast(node);
        isDirectStateReference = node.type === 'MemberExpression' && isThisExpression(node.object) && node.property.name === 'state';
        isAliasedStateReference = node.type === 'Identifier' && classInfo.aliases && classInfo.aliases.has(node.name);
        isPrevStateReference = node.type === 'Identifier' && node.name === 'prevState';
        isNextStateReference = node.type === 'Identifier' && node.name === 'nextState';
        return isDirectStateReference || isAliasedStateReference || isPrevStateReference || isNextStateReference;
      };
      // Takes an ObjectExpression node and adds all named Property nodes to the
      // current set of state fields.
      addStateFields = function(node) {
        var key, prop, ref, results;
        ref = node.properties;
        results = [];
        for (prop of ref) {
          ({key} = prop);
          if (prop.type === 'Property' && (key.type === 'Literal' || (key.type === 'TemplateLiteral' && key.expressions.length === 0) || (prop.computed === false && key.type === 'Identifier')) && getName(prop.key) !== null) {
            results.push(classInfo.stateFields.add(prop));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      // Adds the name of the given node as a used state field if the node is an
      // Identifier or a Literal. Other node types are ignored.
      addUsedStateField = function(node) {
        var name;
        name = getName(node);
        if (name) {
          return classInfo.usedStateFields.add(name);
        }
      };
      // Records used state fields and new aliases for an ObjectPattern which
      // destructures `this.state`.
      handleStateDestructuring = function(node) {
        var prop, ref, ref1, results;
        ref = node.properties;
        results = [];
        for (prop of ref) {
          if (prop.type === 'Property') {
            results.push(addUsedStateField(prop.key));
          } else if (((ref1 = prop.type) === 'ExperimentalRestProperty' || ref1 === 'RestElement') && classInfo.aliases) {
            results.push(classInfo.aliases.add(getName(prop.argument)));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      // Used to record used state fields and new aliases for both
      // AssignmentExpressions and VariableDeclarators.
      handleAssignment = function(left, right) {
        var name, prop, ref, results;
        switch (left.type) {
          case 'Identifier':
            if (isStateReference(right) && classInfo.aliases) {
              return classInfo.aliases.add(left.name);
            }
            break;
          case 'ObjectPattern':
            if (isStateReference(right)) {
              return handleStateDestructuring(left);
            } else if (isThisExpression(right) && classInfo.aliases) {
              ref = left.properties;
              results = [];
              for (prop of ref) {
                if (prop.type === 'Property' && getName(prop.key) === 'state') {
                  name = getName(prop.value);
                  if (name) {
                    results.push(classInfo.aliases.add(name));
                  } else if (prop.value.type === 'ObjectPattern') {
                    results.push(handleStateDestructuring(prop.value));
                  } else {
                    results.push(void 0);
                  }
                } else {
                  results.push(void 0);
                }
              }
              return results;
            }
        }
      };
      // pass
      reportUnusedFields = function() {
        var name, node, ref, results;
        ref = classInfo.stateFields;
        // Report all unused state fields.
        results = [];
        for (node of ref) {
          name = getName(node.key);
          if (!classInfo.usedStateFields.has(name)) {
            results.push(context.report(node, `Unused state field: '${name}'`));
          } else {
            results.push(void 0);
          }
        }
        return results;
      };
      return {
        ClassDeclaration: function(node) {
          if (utils.isES6Component(node)) {
            return classInfo = getInitialClassInfo();
          }
        },
        ObjectExpression: function(node) {
          if (utils.isES5Component(node)) {
            return classInfo = getInitialClassInfo();
          }
        },
        'ObjectExpression:exit': function(node) {
          if (!classInfo) {
            return;
          }
          if (utils.isES5Component(node)) {
            reportUnusedFields();
            return classInfo = null;
          }
        },
        'ClassDeclaration:exit': function() {
          if (!classInfo) {
            return;
          }
          reportUnusedFields();
          return classInfo = null;
        },
        CallExpression: function(node) {
          if (!classInfo) {
            return;
          }
          // If we're looking at a `this.setState({})` invocation, record all the
          // properties as state fields.
          if (node.callee.type === 'MemberExpression' && isThisExpression(node.callee.object) && getName(node.callee.property) === 'setState' && node.arguments.length > 0 && node.arguments[0].type === 'ObjectExpression') {
            return addStateFields(node.arguments[0]);
          }
        },
        ClassProperty: function(node) {
          if (!classInfo) {
            return;
          }
          // If we see state being assigned as a class property using an object
          // expression, record all the fields of that object as state fields.
          if (getName(node.key) === 'state' && !node.static && node.value && node.value.type === 'ObjectExpression') {
            addStateFields(node.value);
          }
          if (!node.static && node.value && node.value.type === 'ArrowFunctionExpression') {
            // Create a new set for this.state aliases local to this method.
            return classInfo.aliases = new Set();
          }
        },
        'ClassProperty:exit': function(node) {
          if (classInfo && !node.static && node.value && node.value.type === 'ArrowFunctionExpression') {
            // Forget our set of local aliases.
            return classInfo.aliases = null;
          }
        },
        MethodDefinition: function() {
          if (!classInfo) {
            return;
          }
          // Create a new set for this.state aliases local to this method.
          return classInfo.aliases = new Set();
        },
        'MethodDefinition:exit': function() {
          if (!classInfo) {
            return;
          }
          // Forget our set of local aliases.
          return classInfo.aliases = null;
        },
        FunctionExpression: function(node) {
          var body, lastBodyNode, parent, ref;
          if (!classInfo) {
            return;
          }
          ({parent} = node);
          if (!utils.isES5Component(parent.parent)) {
            return;
          }
          if (parent.key.name === 'getInitialState') {
            ({body} = node.body);
            lastBodyNode = body[body.length - 1];
            if (lastBodyNode.type === 'ReturnStatement' && lastBodyNode.argument.type === 'ObjectExpression') {
              return addStateFields(lastBodyNode.argument);
            } else if (((ref = lastBodyNode.expression) != null ? ref.type : void 0) === 'ObjectExpression') {
              return addStateFields(lastBodyNode.expression);
            }
          } else {
            // Create a new set for this.state aliases local to this method.
            return classInfo.aliases = new Set();
          }
        },
        AssignmentExpression: function(node) {
          var fn;
          if (!classInfo) {
            return;
          }
          // Check for assignments like `this.state = {}`
          if (node.left.type === 'MemberExpression' && isThisExpression(node.left.object) && getName(node.left.property) === 'state' && node.right.type === 'ObjectExpression') {
            // Find the nearest function expression containing this assignment.
            fn = node;
            while (fn.type !== 'FunctionExpression' && fn.parent) {
              fn = fn.parent;
            }
            // If the nearest containing function is the constructor, then we want
            // to record all the assigned properties as state fields.
            if (fn.parent && fn.parent.type === 'MethodDefinition' && fn.parent.kind === 'constructor') {
              return addStateFields(node.right);
            }
          } else {
            // Check for assignments like `alias = this.state` and record the alias.
            return handleAssignment(node.left, node.right);
          }
        },
        VariableDeclarator: function(node) {
          if (!classInfo || !node.init) {
            return;
          }
          return handleAssignment(node.id, node.init);
        },
        MemberExpression: function(node) {
          if (!classInfo) {
            return;
          }
          if (isStateReference(node.object)) {
            // If we see this.state[foo] access, give up.
            if (node.computed && node.property.type !== 'Literal') {
              classInfo = null;
              return;
            }
            // Otherwise, record that we saw this property being accessed.
            return addUsedStateField(node.property);
          // If we see a `this.state` access in a CallExpression, give up.
          } else if (isStateReference(node) && node.parent.type === 'CallExpression') {
            return classInfo/*:*/ = null;
          }
        },
        JSXSpreadAttribute: function(node) {
          if (classInfo && isStateReference(node.argument)) {
            return classInfo = null;
          }
        },
        'ExperimentalSpreadProperty, SpreadElement': function(node) {
          if (classInfo && isStateReference(node.argument)) {
            return classInfo = null;
          }
        }
      };
    })
  };

}).call(this);
