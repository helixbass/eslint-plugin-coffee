// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to check for "block scoped" variables by binding context
   * @author Matt DuVall <http://www.mattduvall.com>
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce the use of variables within the scope they are defined',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/block-scoped-var'
      },
      schema: [],
      messages: {
        outOfScope: "'{{name}}' used outside of binding context."
      }
    },
    create: function(context) {
      /**
       * Finds and reports references which are outside of valid scopes.
       * @param {ASTNode} node - A node to get variables.
       * @returns {void}
       */
      /**
       * Makes a block scope.
       * @param {ASTNode} node - A node of a scope.
       * @returns {void}
       */
      /**
       * Pops the last block scope.
       * @returns {void}
       */
      /**
       * Reports a given reference.
       * @param {eslint-scope.Reference} reference - A reference to report.
       * @returns {void}
       */
      var checkForVariables, enterScope, exitScope, report, stack;
      stack = [];
      enterScope = function(node) {
        return stack.push(node.range);
      };
      exitScope = function() {
        return stack.pop();
      };
      report = function(reference) {
        var identifier;
        ({identifier} = reference);
        return context.report({
          node: identifier,
          messageId: 'outOfScope',
          data: {
            name: identifier.name
          }
        });
      };
      checkForVariables = function(node) {
        /**
         * Check if a reference is out of scope
         * @param {ASTNode} reference node to examine
         * @returns {boolean} True is its outside the scope
         * @private
         */
        var i, isOutsideOfScope, len, results, scopeRange, variable, variables;
        if (!node.declaration) {
          return;
        }
        // Defines a predicate to check whether or not a given reference is outside of valid scope.
        scopeRange = stack[stack.length - 1];
        isOutsideOfScope = function(reference) {
          var idRange;
          idRange = reference.identifier.range;
          return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
        };
        // Gets declared variables, and checks its references.
        variables = context.getDeclaredVariables(node);
// Reports.
        results = [];
        for (i = 0, len = variables.length; i < len; i++) {
          variable = variables[i];
          results.push(variable.references.filter(isOutsideOfScope).forEach(report));
        }
        return results;
      };
      return {
        Program: function(node) {
          return stack = [node.range];
        },
        // Manages scopes.
        BlockStatement: enterScope,
        'BlockStatement:exit': exitScope,
        For: enterScope,
        'For:exit': exitScope,
        ForStatement: enterScope,
        'ForStatement:exit': exitScope,
        ForInStatement: enterScope,
        'ForInStatement:exit': exitScope,
        ForOfStatement: enterScope,
        'ForOfStatement:exit': exitScope,
        SwitchStatement: enterScope,
        'SwitchStatement:exit': exitScope,
        CatchClause: enterScope,
        'CatchClause:exit': exitScope,
        // Finds and reports references which are outside of valid scope.
        Identifier: checkForVariables
      };
    }
  };

}).call(this);
