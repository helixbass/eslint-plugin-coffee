// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag reassigning variables.
   * @author Ilya Volodin
   */
  'use strict';
  var astUtils, isNullOrUndefined;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  ({isNullOrUndefined} = astUtils);

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow reassignment of variables',
        category: 'Variables',
        recommended: false
      },
      // url: 'https://eslint.org/docs/rules/no-shadow'
      schema: [
        {
          type: 'object',
          properties: {
            allowNullInitializers: {
              type: 'boolean'
            },
            allowSameScope: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var allowNullInitializers, allowSameScope, allowingCommentRegex, assignmentHasAllowingComment, checkIdentifier, getDeclaration, hasPrecedingNonInitialAssignment, identifierHasAllowingComment, isBeingAssignedTo, isNullInitializer, ref, ref1, ref2, ref3, sourceCode;
      allowNullInitializers = (ref = (ref1 = context.options[0]) != null ? ref1.allowNullInitializers : void 0) != null ? ref : true;
      allowSameScope = (ref2 = (ref3 = context.options[0]) != null ? ref3.allowSameScope : void 0) != null ? ref2 : true;
      sourceCode = context.getSourceCode();
      getDeclaration = function(node) {
        var found, name, scope, upper;
        ({name} = node);
        scope = context.getScope();
        upper = scope;
        if (node.parent.type === 'ClassDeclaration') {
          ({upper} = upper);
        }
        while (upper) {
          found = upper.set.get(name);
          if (found) {
            return {
              identifier: found.identifiers[0],
              scope: upper,
              variable: found
            };
          }
          ({upper} = upper);
        }
      };
      isBeingAssignedTo = function(node) {
        var currentNode, prevNode;
        prevNode = node;
        currentNode = node.parent;
        while (currentNode) {
          switch (currentNode.type) {
            case 'AssignmentExpression':
              if (currentNode.operator !== '=') {
                return false;
              }
              if (prevNode === currentNode.left) {
                return currentNode;
              }
              return false;
            case 'AssignmentPattern':
              if (prevNode !== currentNode.left) {
                return false;
              }
              break;
            case 'ArrayPattern':
            case 'ObjectPattern': // continue
              break;
            case 'Property':
              if (prevNode !== currentNode.value) {
                return false;
              }
              break;
            case 'ClassDeclaration':
              return prevNode === currentNode.id;
            case 'For':
              return prevNode === currentNode.name || prevNode === currentNode.index;
            default:
              return false;
          }
          prevNode = currentNode;
          currentNode = currentNode.parent;
        }
      };
      hasPrecedingNonInitialAssignment = function(node, variable) {
        var def, ref4;
        def = (ref4 = variable.defs) != null ? ref4[0] : void 0;
        if (def == null) {
          return;
        }
        return variable.references.some(function(reference) {
          return reference.writeExpr && reference.identifier !== node && reference.identifier !== def.node && reference.identifier.range[0] < node.range[0];
        });
      };
      isNullInitializer = function(node) {
        if ((node != null ? node.type : void 0) !== 'Identifier') {
          return false;
        }
        if (node.parent.type !== 'AssignmentExpression') {
          // TODO: more complex null initializers via destructuring assignment?
          // return no unless assignmentExpression = isBeingAssignedTo node
          return false;
        }
        return isNullOrUndefined(node.parent.right);
      };
      allowingCommentRegex = /^\s*:=?\s*$/;
      identifierHasAllowingComment = function(node) {
        if ((node != null ? node.type : void 0) !== 'Identifier') {
          return;
        }
        if (sourceCode.getCommentsBefore(node).some(function(comment) {
          return allowingCommentRegex.test(comment.value);
        })) {
          return true;
        }
        if (sourceCode.getCommentsAfter(node).some(function(comment) {
          return allowingCommentRegex.test(comment.value);
        })) {
          return true;
        }
        return false;
      };
      assignmentHasAllowingComment = function(node) {
        var equalsSign;
        if ((node != null ? node.type : void 0) !== 'AssignmentExpression') {
          return;
        }
        equalsSign = sourceCode.getTokenAfter(node.left);
        if ((equalsSign != null ? equalsSign.value : void 0) !== '=') {
          return;
        }
        return sourceCode.getCommentsBefore(equalsSign).some(function(comment) {
          return allowingCommentRegex.test(comment.value);
        });
      };
      checkIdentifier = function(node) {
        var assignmentExpression, declaration, identifier, scope, variable;
        if (node.declaration) {
          return;
        }
        if (identifierHasAllowingComment(node)) {
          return;
        }
        if (!(assignmentExpression = isBeingAssignedTo(node))) {
          return;
        }
        if (assignmentHasAllowingComment(assignmentExpression)) {
          return;
        }
        declaration = getDeclaration(node);
        if (declaration == null) {
          return;
        }
        ({scope, identifier, variable} = declaration);
        if (scope.variableScope === context.getScope().variableScope) {
          if (allowSameScope) {
            return;
          }
        }
        if (isNullInitializer(identifier) && !hasPrecedingNonInitialAssignment(node, variable)) {
          if (allowNullInitializers) {
            return;
          }
        }
        return context.report({
          node,
          message: `Overwriting variable '${node.name}' disallowed.`
        });
      };
      return {
        Identifier: checkIdentifier
      };
    }
  };

}).call(this);
