// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to check empty newline between class members
   * @author 薛定谔的猫<hh_2013@foxmail.com>
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require or disallow an empty line between class members',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/lines-between-class-members'
      },
      // fixable: 'whitespace'
      schema: [
        {
          enum: ['always',
        'never']
        },
        {
          type: 'object',
          properties: {
            exceptAfterSingleLine: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if there is padding between two tokens
       * @param {Token} first The first token
       * @param {Token} second The second token
       * @returns {boolean} True if there is at least a line between the tokens
       */
      var ALWAYS_MESSAGE, NEVER_MESSAGE, isPaddingBetweenTokens, options, sourceCode;
      options = [];
      options[0] = context.options[0] || 'always';
      options[1] = context.options[1] || {
        exceptAfterSingleLine: false
      };
      ALWAYS_MESSAGE = 'Expected blank line between class members.';
      NEVER_MESSAGE = 'Unexpected blank line between class members.';
      sourceCode = context.getSourceCode();
      isPaddingBetweenTokens = function(first, second) {
        var commentLinesOfThisComment, comments, i, len, linesBetweenFstAndSnd, prevCommentLineNum, sumOfCommentLines;
        comments = sourceCode.getCommentsBefore(second);
        len = comments.length;
        // If there is no comments
        if (len === 0) {
          linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;
          return linesBetweenFstAndSnd >= 1;
        }
        // If there are comments
        sumOfCommentLines = 0; // the numbers of lines of comments
        prevCommentLineNum = -1; // line number of the end of the previous comment
        i = 0;
        while (i < len) {
          commentLinesOfThisComment = comments[i].loc.end.line - comments[i].loc.start.line + 1;
          sumOfCommentLines += commentLinesOfThisComment;
          /*
           * If this comment and the previous comment are in the same line,
           * the count of comment lines is duplicated. So decrement sumOfCommentLines.
           */
          if (prevCommentLineNum === comments[i].loc.start.line) {
            sumOfCommentLines -= 1;
          }
          prevCommentLineNum = comments[i].loc.end.line;
          i++;
        }
        /*
         * If the first block and the first comment are in the same line,
         * the count of comment lines is duplicated. So decrement sumOfCommentLines.
         */
        if (first.loc.end.line === comments[0].loc.start.line) {
          sumOfCommentLines -= 1;
        }
        /*
         * If the last comment and the second block are in the same line,
         * the count of comment lines is duplicated. So decrement sumOfCommentLines.
         */
        if (comments[len - 1].loc.end.line === second.loc.start.line) {
          sumOfCommentLines -= 1;
        }
        linesBetweenFstAndSnd = second.loc.start.line - first.loc.end.line - 1;
        return linesBetweenFstAndSnd - sumOfCommentLines >= 1;
      };
      return {
        ClassBody: function(node) {
          var body, curFirst, curLast, i, isMulti, isPadded, j, nextFirst, ref, results, skip;
          ({body} = node);
          if (!body.length) {
            return;
          }
          results = [];
          for (i = j = 0, ref = body.length - 1; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
            curFirst = sourceCode.getFirstToken(body[i]);
            curLast = sourceCode.getLastToken(body[i]);
            nextFirst = sourceCode.getFirstToken(body[i + 1]);
            isPadded = isPaddingBetweenTokens(curLast, nextFirst);
            isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
            skip = !isMulti && options[1].exceptAfterSingleLine;
            if ((options[0] === 'always' && !skip && !isPadded) || (options[0] === 'never' && isPadded)) {
              results.push(context.report({
                node: body[i + 1],
                message: isPadded ? NEVER_MESSAGE : ALWAYS_MESSAGE
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    }
  };

  // fix: (fixer) ->
//   if isPadded
//     fixer.replaceTextRange(
//       [curLast.range[1], nextFirst.range[0]]
//       '\n'
//     )
//   else
//     fixer.insertTextAfter curLast, '\n'

}).call(this);
