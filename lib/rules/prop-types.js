// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent missing props validation in a React component definition
   * @author Yannick Croissant
   */
  'use strict';
  var Components, DIRECT_PROPS_REGEX, PROPS_REGEX, docsUrl,
    hasProp = {}.hasOwnProperty;

  // As for exceptions for props.children or props.className (and alike) look at
  // https://github.com/yannickcr/eslint-plugin-react/issues/7
  Components = require('../util/react/Components');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Constants
  // ------------------------------------------------------------------------------
  PROPS_REGEX = /^(props|nextProps)$/;

  DIRECT_PROPS_REGEX = /^(props|nextProps)\s*(\.|\[)/;

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Prevent missing props validation in a React component definition',
        category: 'Best Practices',
        recommended: true,
        url: docsUrl('prop-types')
      },
      schema: [
        {
          type: 'object',
          properties: {
            ignore: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            customValidators: {
              type: 'array',
              items: {
                type: 'string'
              }
            },
            skipUndeclared: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Internal: Checks if the prop is declared
       * @param {Object} declaredPropTypes Description of propTypes declared in the current component
       * @param {String[]} keyList Dot separated name of the prop to check.
       * @returns {Boolean} True if the prop is declared, false if not.
       */
      /**
       * Retrieve the name of a key node
       * @param {ASTNode} node The AST node with the key.
       * @return {string} the name of the key
       */
      /**
       * Retrieve the name of a property node
       * @param {ASTNode} node The AST node with the property.
       * @return {string} the name of the property or undefined if not found
       */
      /**
       * Checks if the prop has spread operator.
       * @param {ASTNode} node The AST node being marked.
       * @returns {Boolean} True if the prop has spread operator, false if not.
       */
      /**
       * Check if we are in a class constructor
       * @return {boolean} true if we are in a class constructor, false if not
       */
      /**
       * Check if we are in a class constructor
       * @return {boolean} true if we are in a class constructor, false if not
       */
      /**
       * Check if we are in a class constructor
       * @return {boolean} true if we are in a class constructor, false if not
       */
      /**
       * Checks if a prop is being assigned a value props.bar = 'bar'
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean}
       */
      /**
       * Checks if the prop is declared
       * @param {ASTNode} node The AST node being checked.
       * @param {String[]} names List of names of the prop to check.
       * @returns {Boolean} True if the prop is declared, false if not.
       */
      /**
       * Checks if the prop is ignored
       * @param {String} name Name of the prop to check.
       * @returns {Boolean} True if the prop is ignored, false if not.
       */
      /**
       * Checks if we are using a prop
       * @param {ASTNode} node The AST node being checked.
       * @returns {Boolean} True if we are using a prop, false if not.
       */
      /**
       * @param {ASTNode} node We expect either an ArrowFunctionExpression,
       *   FunctionDeclaration, or FunctionExpression
       */
      /**
       * Mark a prop type as used
       * @param {ASTNode} node The AST node being marked.
       */
      /**
       * Checks if the component must be validated
       * @param {Object} component The component to process
       * @returns {Boolean} True if the component must be validated, false if not.
       */
      /**
       * Reports undeclared proptypes for a given component
       * @param {Object} component The component to process
       */
      /**
       * Removes quotes from around an identifier.
       * @param {string} the identifier to strip
       */
      var MISSING_MESSAGE, _isDeclaredInComponent, configuration, getKeyValue, getPropertyName, hasSpreadOperator, ignored, inComponentWillReceiveProps, inConstructor, inShouldComponentUpdate, isAssignmentToProp, isDeclaredInComponent, isIgnored, isPropTypesUsage, markDestructuredFunctionArgumentsAsUsed, markPropTypesAsUsed, mustBeValidated, reportUndeclaredPropTypes, skipUndeclared, sourceCode, stripQuotes;
      sourceCode = context.getSourceCode();
      configuration = context.options[0] || {};
      ignored = configuration.ignore || [];
      skipUndeclared = configuration.skipUndeclared || false;
      MISSING_MESSAGE = "'{{name}}' is missing in props validation";
      inConstructor = function() {
        var ref, scope;
        scope = context.getScope();
        while (scope) {
          if (((ref = scope.block) != null ? ref.parent : void 0) && scope.block.parent.kind === 'constructor') {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      inComponentWillReceiveProps = function() {
        var ref, scope;
        scope = context.getScope();
        while (scope) {
          if (((ref = scope.block) != null ? ref.parent : void 0) && scope.block.parent.key && scope.block.parent.key.name === 'componentWillReceiveProps') {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      inShouldComponentUpdate = function() {
        var ref, scope;
        scope = context.getScope();
        while (scope) {
          if (((ref = scope.block) != null ? ref.parent : void 0) && scope.block.parent.key && scope.block.parent.key.name === 'shouldComponentUpdate') {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      };
      isAssignmentToProp = function(node) {
        return node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node;
      };
      isPropTypesUsage = function(node) {
        var isClassUsage, isNextPropsUsage, isStatelessFunctionUsage;
        isClassUsage = (utils.getParentES6Component() || utils.getParentES5Component()) && node.object.type === 'ThisExpression' && node.property.name === 'props';
        isStatelessFunctionUsage = node.object.name === 'props' && !isAssignmentToProp(node);
        isNextPropsUsage = node.object.name === 'nextProps' && (inComponentWillReceiveProps() || inShouldComponentUpdate());
        return isClassUsage || isStatelessFunctionUsage || isNextPropsUsage;
      };
      isIgnored = function(name) {
        return ignored.indexOf(name) !== -1;
      };
      mustBeValidated = function(component) {
        var isSkippedByConfig;
        isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';
        return Boolean((component != null ? component.usedPropTypes : void 0) && !component.ignorePropsValidation && !isSkippedByConfig);
      };
      _isDeclaredInComponent = function(declaredPropTypes, keyList) {
        var i, isValid, j, k, key, l, len, propType, ref, unionPropType, unionType, unionTypes;
        i = 0;
        j = keyList.length; // If not, check if this type accepts any key
        for (i = k = 0, ref = j; (0 <= ref ? k < ref : k > ref); i = 0 <= ref ? ++k : --k) {
          key = keyList[i];
          propType = declaredPropTypes && (declaredPropTypes[key] || declaredPropTypes.__ANY_KEY__);
          if (!propType) {
            return key === '__COMPUTED_PROP__';
          }
          if (typeof propType === 'object' && !propType.type) {
            return true;
          }
          if (propType.children === true || propType.containsSpread) {
            return true;
          }
          if (propType.acceptedProperties) {
            return key in propType.acceptedProperties;
          }
          if (propType.type === 'union') {
            if (i + 1 >= j) {
              return true;
            }
            unionTypes = propType.children;
            unionPropType = {};
            for (l = 0, len = unionTypes.length; l < len; l++) {
              unionType = unionTypes[l];
              unionPropType[key] = unionType;
              isValid = _isDeclaredInComponent(unionPropType, keyList.slice(i));
              if (isValid) {
                return true;
              }
            }
            return false;
          }
          declaredPropTypes = propType.children;
        }
        // Check if this key is declared
        // If it's a computed property, we can't make any further analysis, but is valid
        // Consider every children as declared
        // If we fall in this case, we know there is at least one complex type in the union
        // this is the last key, accept everything
        // non trivial, check all of them
        // every possible union were invalid
        return true;
      };
      isDeclaredInComponent = function(node, names) {
        var component, isDeclared;
        while (node) {
          component = components.get(node);
          isDeclared = component && component.confidence === 2 && _isDeclaredInComponent(component.declaredPropTypes || {}, names);
          if (isDeclared) {
            return true;
          }
          node = node.parent;
        }
        return false;
      };
      hasSpreadOperator = function(node) {
        var tokens;
        tokens = sourceCode.getTokens(node);
        return tokens.length && tokens[0].value === '...';
      };
      stripQuotes = function(string) {
        return string.replace(/^'|'$/g, '');
      };
      getKeyValue = function(node) {
        var key, ref, tokens;
        if (node.type === 'ObjectTypeProperty') {
          tokens = context.getFirstTokens(node, 2);
          return ((ref = tokens[0].value) === '+' || ref === '-' ? tokens[1].value : stripQuotes(tokens[0].value));
        }
        key = node.key || node.argument;
        if (key.type === 'Identifier') {
          return key.name;
        } else {
          return key.value;
        }
      };
      getPropertyName = function(node) {
        var isDirectProp, isInClassComponent, isNotInComponentWillReceiveProps, isNotInConstructor, isNotInShouldComponentUpdate, property;
        isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
        isInClassComponent = utils.getParentES6Component() || utils.getParentES5Component();
        isNotInConstructor = !inConstructor();
        isNotInComponentWillReceiveProps = !inComponentWillReceiveProps();
        isNotInShouldComponentUpdate = !inShouldComponentUpdate();
        if (isDirectProp && isInClassComponent && isNotInConstructor && isNotInComponentWillReceiveProps && isNotInShouldComponentUpdate) {
          return void 0;
        }
        if (!isDirectProp) {
          node = node.parent;
        }
        ({property} = node);
        if (property) {
          switch (property.type) {
            case 'Identifier':
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
              return property.name;
            case 'MemberExpression':
              return void 0;
            case 'Literal':
              if (typeof property.value === 'string') {
                // Accept computed properties that are literal strings
                return property.value;
              }
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
              break;
            default:
              if (node.computed) {
                return '__COMPUTED_PROP__';
              }
          }
        }
        return void 0;
      };
      markPropTypesAsUsed = function(node, parentNames) {
        var allNames, component, currentNode, destructuring, directDestructuring, isDirectProp, k, l, left, len, len1, name, propName, properties, property, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, right, thisDestructuring, type, usedPropTypes;
        parentNames || (parentNames = []);
        switch (node.type) {
          case 'MemberExpression':
            name = getPropertyName(node);
            if (name) {
              allNames = parentNames.concat(name);
              if (node.parent.type === 'MemberExpression') {
                markPropTypesAsUsed(node.parent, allNames);
              }
              // Do not mark computed props as used.
              type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
            } else {
              left = (ref = node.parent.id) != null ? ref : node.parent.left;
              if ((left != null ? (ref1 = left.properties) != null ? ref1.length : void 0 : void 0) && getKeyValue(left.properties[0])) {
                type = 'destructuring';
                ({properties} = left);
              }
            }
            break;
          case 'ArrowFunctionExpression':
          case 'FunctionDeclaration':
          case 'FunctionExpression':
            type = 'destructuring';
            ({properties} = node.params[0]);
            break;
          case 'MethodDefinition':
            destructuring = ((ref2 = node.value) != null ? (ref3 = ref2.params[0]) != null ? ref3.type : void 0 : void 0) === 'ObjectPattern';
            if (destructuring) {
              type = 'destructuring';
              ({properties} = node.value.params[0]);
            } else {
              return;
            }
            break;
          case 'VariableDeclarator':
          case 'AssignmentExpression':
            left = (ref4 = node.id) != null ? ref4 : node.left;
            right = (ref5 = node.init) != null ? ref5 : node.right;
            ref6 = left.properties;
            // let {props: {firstname}} = this
            // let {firstname} = props
            for (k = 0, len = ref6.length; k < len; k++) {
              property = ref6[k];
              thisDestructuring = !hasSpreadOperator(property) && (PROPS_REGEX.test(property.key.name) || PROPS_REGEX.test(property.key.value)) && property.value.type === 'ObjectPattern';
              directDestructuring = PROPS_REGEX.test(right.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());
              if (thisDestructuring) {
                ({properties} = property.value);
              } else if (directDestructuring) {
                ({properties} = left);
              } else {
                continue;
              }
              type = 'destructuring';
            }
            break;
          default:
            throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);
        }
        component = components.get(utils.getParentComponent());
        usedPropTypes = ((ref7 = component != null ? component.usedPropTypes : void 0) != null ? ref7 : []).slice();
        switch (type) {
          case 'direct':
            if (Object.prototype[name]) {
              // Ignore Object methods
              break;
            }
            isDirectProp = DIRECT_PROPS_REGEX.test(sourceCode.getText(node));
            usedPropTypes.push({
              name,
              allNames,
              node: (!isDirectProp && !inConstructor() && !inComponentWillReceiveProps()) ? node.parent.property : node.property
            });
            break;
          case 'destructuring':
            for (l = 0, len1 = properties.length; l < len1; l++) {
              property = properties[l];
              if (hasSpreadOperator(property) || property.computed) {
                continue;
              }
              propName = getKeyValue(property);
              currentNode = node;
              allNames = [];
              while (currentNode.property && !PROPS_REGEX.test(currentNode.property.name)) {
                allNames.unshift(currentNode.property.name);
                currentNode = currentNode.object;
              }
              allNames.push(propName);
              if (propName) {
                usedPropTypes.push({
                  name: propName,
                  allNames,
                  node: property
                });
              }
            }
        }
        return components.set(node, {usedPropTypes});
      };
      reportUndeclaredPropTypes = function(component) {
        var allNames, k, len, ref, results, usedPropType;
        ref = component.usedPropTypes;
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          usedPropType = ref[k];
          ({allNames} = usedPropType);
          if (isIgnored(allNames[0]) || isDeclaredInComponent(component.node, allNames)) {
            continue;
          }
          results.push(context.report(usedPropType.node, MISSING_MESSAGE, {
            name: allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
          }));
        }
        return results;
      };
      markDestructuredFunctionArgumentsAsUsed = function(node) {
        var destructuring, ref;
        destructuring = ((ref = node.params) != null ? ref[0] : void 0) && node.params[0].type === 'ObjectPattern';
        if (destructuring && components.get(node)) {
          return markPropTypesAsUsed(node);
        }
      };
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        VariableDeclarator: function(node) {
          var destructuring, directDestructuring, thisDestructuring;
          destructuring = node.init && node.id && node.id.type === 'ObjectPattern';
          // let {props: {firstname}} = this
          thisDestructuring = destructuring && node.init.type === 'ThisExpression';
          // let {firstname} = props
          directDestructuring = destructuring && PROPS_REGEX.test(node.init.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());
          if (!thisDestructuring && !directDestructuring) {
            return;
          }
          return markPropTypesAsUsed(node);
        },
        AssignmentExpression: function(node) {
          var destructuring, directDestructuring, thisDestructuring;
          destructuring = node.left.type === 'ObjectPattern';
          // let {props: {firstname}} = this
          thisDestructuring = destructuring && node.right.type === 'ThisExpression';
          // let {firstname} = props
          directDestructuring = destructuring && PROPS_REGEX.test(node.right.name) && (utils.getParentStatelessComponent() || inConstructor() || inComponentWillReceiveProps());
          if (!(thisDestructuring || directDestructuring)) {
            return;
          }
          return markPropTypesAsUsed(node);
        },
        FunctionDeclaration: markDestructuredFunctionArgumentsAsUsed,
        ArrowFunctionExpression: markDestructuredFunctionArgumentsAsUsed,
        FunctionExpression: function(node) {
          if (node.parent.type === 'MethodDefinition') {
            return;
          }
          return markDestructuredFunctionArgumentsAsUsed(node);
        },
        MemberExpression: function(node) {
          if (isPropTypesUsage(node)) {
            return markPropTypesAsUsed(node);
          }
        },
        MethodDefinition: function(node) {
          var destructuring, ref, ref1;
          destructuring = ((ref = node.value) != null ? (ref1 = ref.params[0]) != null ? ref1.type : void 0 : void 0) === 'ObjectPattern';
          if (node.key.name === 'componentWillReceiveProps' && destructuring) {
            markPropTypesAsUsed(node);
          }
          if (node.key.name === 'shouldComponentUpdate' && destructuring) {
            return markPropTypesAsUsed(node);
          }
        },
        'Program:exit': function() {
          var _, component, list, results;
          list = components.list();
          results = [];
          for (_ in list) {
            if (!hasProp.call(list, _)) continue;
            component = list[_];
            if (!mustBeValidated(component)) {
              continue;
            }
            results.push(reportUndeclaredPropTypes(component));
          }
          return results;
        }
      };
    })
  };

}).call(this);
