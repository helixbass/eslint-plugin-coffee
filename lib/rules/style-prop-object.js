// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce style prop value is an object
   * @author David Petersen
   */
  'use strict';
  var docsUrl, variableUtil;

  variableUtil = require('../util/react/variable');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce style prop value is an object',
        category: '',
        recommended: false,
        url: docsUrl('style-prop-object')
      },
      schema: []
    },
    create: function(context) {
      /**
       * @param {object} node A Identifier node
       */
      /**
       * @param {object} node An Identifier node
       */
      var checkIdentifiers, isNonNullaryLiteral;
      isNonNullaryLiteral = function(expression) {
        return expression.type === 'Literal' && expression.value !== null;
      };
      checkIdentifiers = function(node) {
        var ref, ref1, variable;
        variable = variableUtil.variablesInScope(context).find(function(item) {
          return item.name === node.name;
        });
        if (variable != null ? (ref = variable.defs[0]) != null ? ref.node.init : void 0 : void 0) {
          if (isNonNullaryLiteral(variable.defs[0].node.init)) {
            context.report(node, 'Style prop value must be an object');
          }
        }
        if (variable != null ? (ref1 = variable.defs[0]) != null ? ref1.node.parent.right : void 0 : void 0) {
          if (isNonNullaryLiteral(variable.defs[0].node.parent.right)) {
            return context.report(node, 'Style prop value must be an object');
          }
        }
      };
      return {
        CallExpression: function(node) {
          var ref, style;
          if (((ref = node.callee) != null ? ref.type : void 0) === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
            if (node.arguments[1].type === 'ObjectExpression') {
              style = node.arguments[1].properties.find(function(property) {
                return property.key && property.key.name === 'style' && !property.computed;
              });
              if (style) {
                if (style.value.type === 'Identifier') {
                  return checkIdentifiers(style.value);
                } else if (isNonNullaryLiteral(style.value)) {
                  return context.report(style.value, 'Style prop value must be an object');
                }
              }
            }
          }
        },
        JSXAttribute: function(node) {
          if (!node.value || node.name.name !== 'style') {
            return;
          }
          if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {
            return context.report(node, 'Style prop value must be an object');
          } else if (node.value.expression.type === 'Identifier') {
            return checkIdentifiers(node.value.expression);
          }
        }
      };
    }
  };

}).call(this);
