// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)
   * @author Vincent Lemeunier
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow magic numbers',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-magic-numbers'
      },
      schema: [
        {
          type: 'object',
          properties: {
            detectObjects: {
              type: 'boolean'
            },
            ignore: {
              type: 'array',
              items: {
                type: 'number'
              },
              uniqueItems: true
            },
            ignoreArrayIndexes: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        useConst: "Number constants declarations must use 'const'.",
        noMagic: 'No magic number: {{raw}}.'
      }
    },
    create: function(context) {
      /**
       * Returns whether the node is number literal
       * @param {Node} node - the node literal being evaluated
       * @returns {boolean} true if the node is a number literal
       */
      /**
       * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.
       * @param {ASTNode} parent - the non-"UnaryExpression" parent.
       * @returns {boolean} true if the number should be ignored
       */
      /**
       * Returns whether the number should be ignored when used to define a JSX prop
       * @param {ASTNode} parent - the non-"UnaryExpression" parent
       * @returns {boolean} true if the number should be ignored
       */
      /**
       * Returns whether the number should be ignored
       * @param {number} num - the number
       * @returns {boolean} true if the number should be ignored
       */
      /**
       * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()
       * @param {ASTNode} parent - the non-"UnaryExpression" parent
       * @param {ASTNode} node - the node literal being evaluated
       * @returns {boolean} true if the number should be ignored
       */
      var config, detectObjects, ignore, ignoreArrayIndexes, isNumber, shouldIgnoreArrayIndexes, shouldIgnoreJSXNumbers, shouldIgnoreNumber, shouldIgnoreParseInt;
      config = context.options[0] || {};
      detectObjects = !!config.detectObjects;
      ignore = config.ignore || [];
      ignoreArrayIndexes = !!config.ignoreArrayIndexes;
      isNumber = function(node) {
        return typeof node.value === 'number';
      };
      shouldIgnoreNumber = function(num) {
        return ignore.indexOf(num) !== -1;
      };
      shouldIgnoreParseInt = function(parent, node) {
        return parent.type === 'CallExpression' && node === parent.arguments[1] && (parent.callee.name === 'parseInt' || (parent.callee.type === 'MemberExpression' && parent.callee.object.name === 'Number' && parent.callee.property.name === 'parseInt'));
      };
      shouldIgnoreJSXNumbers = function(parent) {
        return parent.type.indexOf('JSX') === 0;
      };
      shouldIgnoreArrayIndexes = function(parent) {
        return parent.type === 'MemberExpression' && ignoreArrayIndexes;
      };
      return {
        Literal: function(node) {
          var fullNumberNode, isAssignment, okTypes, parent, raw, value;
          okTypes = detectObjects ? [] : ['ObjectExpression', 'Property', 'AssignmentExpression'];
          if (!isNumber(node)) {
            return;
          }
          // For negative magic numbers: update the value and parent node
          if (node.parent.type === 'UnaryExpression' && node.parent.operator === '-') {
            fullNumberNode = node.parent;
            ({parent} = fullNumberNode);
            value = -node.value;
            raw = `-${node.raw}`;
          } else {
            fullNumberNode = node;
            ({parent, value, raw} = node);
          }
          if (shouldIgnoreNumber(value) || shouldIgnoreParseInt(parent, fullNumberNode) || shouldIgnoreArrayIndexes(parent) || shouldIgnoreJSXNumbers(parent)) {
            return;
          }
          isAssignment = parent.type === 'AssignmentExpression' && parent.left.type === 'Identifier';
          if (isAssignment && parent.left.declaration) {
            return;
          }
          if (okTypes.indexOf(parent.type) === -1 || isAssignment) {
            return context.report({
              node: fullNumberNode,
              messageId: 'noMagic',
              data: {raw}
            });
          }
        }
      };
    }
  };

}).call(this);
