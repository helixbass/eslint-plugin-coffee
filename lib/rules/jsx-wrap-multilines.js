// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent missing parentheses around multilines JSX
   * @author Yannick Croissant
   */
  'use strict';
  var DEFAULTS, MISSING_PARENS, PARENS_NEW_LINES, docsUrl, has, jsxUtil;

  has = require('has');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  jsxUtil = require('../util/react/jsx');

  // ------------------------------------------------------------------------------
  // Constants
  // ------------------------------------------------------------------------------
  DEFAULTS = {
    assignment: 'parens',
    return: 'parens',
    arrow: 'parens',
    logical: 'ignore',
    prop: 'ignore'
  };

  MISSING_PARENS = 'Missing parentheses around multilines JSX';

  PARENS_NEW_LINES = 'Parentheses around JSX should be on separate lines';

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Prevent missing parentheses around multilines JSX',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-wrap-multilines')
      },
      // fixable: 'code'
      schema: [
        {
          type: 'object',
          // true/false are for backwards compatibility
          properties: {
            assignment: {
              enum: [true,
        false,
        'ignore',
        'parens',
        'parens-new-line']
            },
            return: {
              enum: [true,
        false,
        'ignore',
        'parens',
        'parens-new-line']
            },
            arrow: {
              enum: [true,
        false,
        'ignore',
        'parens',
        'parens-new-line']
            },
            logical: {
              enum: [true,
        false,
        'ignore',
        'parens',
        'parens-new-line']
            },
            prop: {
              enum: [true,
        false,
        'ignore',
        'parens',
        'parens-new-line']
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var check, checkFunction, getOption, isEnabled, isMultilines, isParenthesised, needsNewLines, report, sourceCode, trimTokenBeforeNewline;
      sourceCode = context.getSourceCode();
      getOption = function(type) {
        var userOptions;
        userOptions = context.options[0] || {};
        if (has(userOptions, type)) {
          return userOptions[type];
        }
        return DEFAULTS[type];
      };
      isEnabled = function(type) {
        var option;
        option = getOption(type);
        return option && option !== 'ignore';
      };
      isParenthesised = function(node) {
        var nextToken, previousToken;
        previousToken = sourceCode.getTokenBefore(node);
        nextToken = sourceCode.getTokenAfter(node);
        return previousToken && nextToken && previousToken.value === '(' && previousToken.range[1] <= node.range[0] && nextToken.value === ')' && nextToken.range[0] >= node.range[1];
      };
      needsNewLines = function(node) {
        var nextToken, previousToken;
        previousToken = sourceCode.getTokenBefore(node);
        nextToken = sourceCode.getTokenAfter(node);
        return isParenthesised(node) && previousToken.loc.end.line === node.loc.start.line && node.loc.end.line === nextToken.loc.end.line;
      };
      isMultilines = function(node) {
        return node.loc.start.line !== node.loc.end.line;
      };
      report = function(node, message) {        //fix
        return context.report({node, message});
      };
      // fix
      trimTokenBeforeNewline = function(node, tokenBefore) {
        var isBracket, ref;
        // if the token before the jsx is a bracket or curly brace
        // we don't want a space between the opening parentheses and the multiline jsx
        isBracket = (ref = tokenBefore.value) === '{' || ref === '[';
        return `${tokenBefore.value.trim()}${isBracket ? '' : ' '}`;
      };
      check = function(node, type) {
        var option, tokenAfter, tokenBefore;
        if (!node || !jsxUtil.isJSX(node)) {
          return;
        }
        option = getOption(type);
        if ((option === true || option === 'parens') && !isParenthesised(node) && isMultilines(node)) {
          report(node, MISSING_PARENS, function(fixer) {
            return fixer.replaceText(node, `(${sourceCode.getText(node)})`);
          });
        }
        if (option === 'parens-new-line' && isMultilines(node)) {
          if (!isParenthesised(node)) {
            tokenBefore = sourceCode.getTokenBefore(node, {
              includeComments: true
            });
            tokenAfter = sourceCode.getTokenAfter(node, {
              includeComments: true
            });
            if (tokenBefore.loc.end.line < node.loc.start.line) {
              // Strip newline after operator if parens newline is specified
              return report(node, MISSING_PARENS, function(fixer) {
                return fixer.replaceTextRange([tokenBefore.range[0], tokenAfter.range[0]], `${trimTokenBeforeNewline(node, tokenBefore)}(\n${sourceCode.getText(node)}\n)`);
              });
            } else {
              return report(node, MISSING_PARENS, function(fixer) {
                return fixer.replaceText(node, `(\n${sourceCode.getText(node)}\n)`);
              });
            }
          } else if (needsNewLines(node)) {
            return report(node, PARENS_NEW_LINES, function(fixer) {
              return fixer.replaceText(node, `\n${sourceCode.getText(node)}\n`);
            });
          }
        }
      };
      checkFunction = function(node) {
        var arrowBody, type;
        arrowBody = node.body;
        type = 'arrow';
        if (isEnabled(type)) {
          if (arrowBody.type !== 'BlockStatement') {
            return check(arrowBody, type);
          } else if (arrowBody.body.length === 1 && arrowBody.body[0].type === 'ExpressionStatement') {
            return check(arrowBody.body[0].expression, type);
          }
        }
      };
      return {
        // --------------------------------------------------------------------------
        // Public
        // --------------------------------------------------------------------------
        AssignmentExpression: function(node) {
          var type;
          type = 'assignment';
          if (!isEnabled(type)) {
            return;
          }
          return check(node.right, type);
        },
        ReturnStatement: function(node) {
          var type;
          type = 'return';
          if (isEnabled(type)) {
            return check(node.argument, type);
          }
        },
        'ArrowFunctionExpression:exit': checkFunction,
        'FunctionExpression:exit': checkFunction,
        LogicalExpression: function(node) {
          var type;
          type = 'logical';
          if (isEnabled(type)) {
            return check(node.right, type);
          }
        },
        JSXAttribute: function(node) {
          var ref, type;
          type = 'prop';
          if (isEnabled(type) && ((ref = node.value) != null ? ref.type : void 0) === 'JSXExpressionContainer') {
            return check(node.value.expression, type);
          }
        }
      };
    }
  };

}).call(this);
