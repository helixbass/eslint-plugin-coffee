// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to flag non-matching identifiers
   * @author Matthieu Larcher
   */
  'use strict';
  var isDeclarationAssignment;

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require identifiers to match a specified regular expression',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/id-match'
      },
      schema: [
        {
          type: 'string'
        },
        {
          type: 'object',
          properties: {
            properties: {
              type: 'boolean'
            }
          }
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if a string matches the provided pattern
       * @param {string} name The string to check.
       * @returns {boolean} if the string is a match
       * @private
       */
      /**
       * Reports an AST node as a rule violation.
       * @param {ASTNode} node The node to report.
       * @returns {void}
       * @private
       */
      /**
       * Verifies if we should report an error or not based on the effective
       * parent node and the identifier name.
       * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
       * @param {string} name The identifier name of the identifier node
       * @returns {boolean} whether an error should be reported or not
       */
      var isInvalid, onlyDeclarations, options, pattern, properties, regexp, report, shouldReport;
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      pattern = context.options[0] || '^.+$';
      regexp = new RegExp(pattern);
      options = context.options[1] || {};
      properties = !!options.properties;
      onlyDeclarations = !!options.onlyDeclarations;
      isInvalid = function(name) {
        return !regexp.test(name);
      };
      shouldReport = function(effectiveParent, name) {
        return effectiveParent.type !== 'CallExpression' && effectiveParent.type !== 'NewExpression' && isInvalid(name);
      };
      report = function(node) {
        return context.report({
          node,
          message: "Identifier '{{name}}' does not match the pattern '{{pattern}}'.",
          data: {
            name: node.name,
            pattern
          }
        });
      };
      return {
        Identifier: function(node) {
          var effectiveParent, isDeclaration, name, parent, ref;
          ({name, parent} = node);
          effectiveParent = parent.type === 'MemberExpression' ? parent.parent : parent;
          switch (parent.type) {
            case 'MemberExpression':
              if (!properties) {
                return;
              }
              // Always check object names
              if (parent.object.type === 'Identifier' && parent.object.name === name) {
                if (isInvalid(name)) {
                  return report(node);
                }
              // Report AssignmentExpressions only if they are the left side of the assignment
              } else if (effectiveParent.type === 'AssignmentExpression' && (effectiveParent.right.type !== 'MemberExpression' || (effectiveParent.left.type === 'MemberExpression' && effectiveParent.left.property.name === name))) {
                if (isInvalid(name)) {
                  return report(node);
                }
              }
              break;
            case 'Property':
              if (!(properties && parent.key.name === name)) {
                return;
              }
              if (shouldReport(effectiveParent, name)) {
                return report(node);
              }
              break;
            case 'ClassDeclaration':
              if (parent.id !== node) {
                return;
              }
              if (shouldReport(effectiveParent, name)) {
                return report(node);
              }
              break;
            default:
              isDeclaration = ((ref = effectiveParent.type) === 'FunctionDeclaration' || ref === 'VariableDeclarator') || isDeclarationAssignment(effectiveParent);
              if (onlyDeclarations && !isDeclaration) {
                return;
              }
              if (shouldReport(effectiveParent, name)) {
                return report(node);
              }
          }
        }
      };
    }
  };

}).call(this);
