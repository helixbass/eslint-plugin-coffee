// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to disallow assignments where both sides are exactly the same
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Traverses 2 Pattern nodes in parallel, then reports self-assignments.
   *
   * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or
   *      a Property.
   * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or
   *      a Property.
   * @param {boolean} props - The flag to check member expressions as well.
   * @param {Function} report - A callback function to report.
   * @returns {void}
   */
  /**
   * Checks whether 2 given member expression nodes are the reference to the same
   * property or not.
   *
   * @param {ASTNode} left - A member expression node to check.
   * @param {ASTNode} right - Another member expression node to check.
   * @returns {boolean} `true` if the member expressions are the reference to the
   *  same property or not.
   */
  /**
   * Checks whether the property of 2 given member expression nodes are the same
   * property or not.
   *
   * @param {ASTNode} left - A member expression node to check.
   * @param {ASTNode} right - Another member expression node to check.
   * @returns {boolean} `true` if the member expressions have the same property.
   */
  var SPACES, astUtils, eachSelfAssignment, isSameMember, isSameProperty;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  SPACES = /\s+/g;

  isSameProperty = function(left, right) {
    var lname, rname;
    if (left.property.type === 'Identifier' && left.property.type === right.property.type && left.property.name === right.property.name && left.computed === right.computed) {
      return true;
    }
    lname = astUtils.getStaticPropertyName(left);
    rname = astUtils.getStaticPropertyName(right);
    return lname !== null && lname === rname;
  };

  isSameMember = function(left, right) {
    var lobj, robj;
    if (!isSameProperty(left, right)) {
      return false;
    }
    lobj = left.object;
    robj = right.object;
    if (lobj.type !== robj.type) {
      return false;
    }
    if (lobj.type === 'MemberExpression') {
      return isSameMember(lobj, robj);
    }
    return lobj.type === 'Identifier' && lobj.name === robj.name;
  };

  eachSelfAssignment = function(left, right, props, report) {
    /*
     * Gets the index of the last spread property.
     * It's possible to overwrite properties followed by it.
     */
    var end, i, j, propType, results, results1, rightElement, startJ;
    if (!left || !right) {

    // do nothing
    } else if (left.type === 'Identifier' && right.type === 'Identifier' && left.name === right.name) {
      return report(right);
    } else if (left.type === 'ArrayPattern' && right.type === 'ArrayExpression') {
      end = Math.min(left.elements.length, right.elements.length);
      i = 0;
      results = [];
      while (i < end) {
        rightElement = right.elements[i];
        eachSelfAssignment(left.elements[i], rightElement, props, report);
        // After a spread element, those indices are unknown.
        if (rightElement && rightElement.type === 'SpreadElement') {
          break;
        }
        results.push(++i);
      }
      return results;
    } else if (left.type === 'RestElement' && right.type === 'SpreadElement') {
      return eachSelfAssignment(left.argument, right.argument, props, report);
    } else if (left.type === 'ObjectPattern' && right.type === 'ObjectExpression' && right.properties.length >= 1) {
      startJ = 0;
      i = right.properties.length - 1;
      while (i >= 0) {
        propType = right.properties[i].type;
        if (propType === 'SpreadElement' || propType === 'ExperimentalSpreadProperty') {
          startJ = i + 1;
          break;
        }
        --i;
      }
      i = 0;
      results1 = [];
      while (i < left.properties.length) {
        j = startJ;
        while (j < right.properties.length) {
          eachSelfAssignment(left.properties[i], right.properties[j], props, report);
          ++j;
        }
        results1.push(++i);
      }
      return results1;
    } else if (left.type === 'Property' && right.type === 'Property' && !left.computed && !right.computed && right.kind === 'init' && !right.method && left.key.name === right.key.name) {
      return eachSelfAssignment(left.value, right.value, props, report);
    } else if (props && left.type === 'MemberExpression' && right.type === 'MemberExpression' && isSameMember(left, right)) {
      return report(right);
    }
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow assignments where both sides are exactly the same',
        category: 'Best Practices',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-self-assign'
      },
      schema: [
        {
          type: 'object',
          properties: {
            props: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Reports a given node as self assignments.
       *
       * @param {ASTNode} node - A node to report. This is an Identifier node.
       * @returns {void}
       */
      var props, report, sourceCode;
      sourceCode = context.getSourceCode();
      [{props = true} = {}] = context.options;
      report = function(node) {
        return context.report({
          node,
          message: "'{{name}}' is assigned to itself.",
          data: {
            name: sourceCode.getText(node).replace(SPACES, '')
          }
        });
      };
      return {
        AssignmentExpression: function(node) {
          var ref;
          if ((ref = node.left) != null ? ref.declaration : void 0) {
            return;
          }
          if (node.operator === '=') {
            return eachSelfAssignment(node.left, node.right, props, report);
          }
        }
      };
    }
  };

}).call(this);
