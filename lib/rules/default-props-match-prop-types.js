// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileOverview Enforce all defaultProps are defined in propTypes
   * @author Vitor Balocco
   * @author Roy Sutton
   */
  'use strict';
  var Components, annotations, astUtil, docsUrl, propsUtil, variableUtil,
    hasProp = {}.hasOwnProperty;

  Components = require('../util/react/Components');

  variableUtil = require('../util/react/variable');

  annotations = require('eslint-plugin-react/lib/util/annotations');

  astUtil = require('../util/react/ast');

  propsUtil = require('eslint-plugin-react/lib/util/props');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce all defaultProps are defined and not "required" in propTypes.',
        category: 'Best Practices',
        url: docsUrl('default-props-match-prop-types')
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowRequiredDefaults: {
              default: false,
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Adds defaultProps to the component passed in.
       * @param   {ASTNode}         component    The component to add the defaultProps to.
       * @param   {String[]|String} defaultProps defaultProps to add to the component or the string "unresolved"
       *                                         if this component has defaultProps that can't be resolved.
       * @returns {void}
       */
      /**
       * Adds propTypes to the component passed in.
       * @param   {ASTNode}  component The component to add the propTypes to.
       * @param   {Object[]} propTypes propTypes to add to the component.
       * @returns {void}
       */
      /**
       * Extracts a DefaultProp from an ObjectExpression node.
       * @param   {ASTNode} objectExpression ObjectExpression node.
       * @returns {Object|string}            Object representation of a defaultProp, to be consumed by
       *                                     `addDefaultPropsToComponent`, or string "unresolved", if the defaultProps
       *                                     from this ObjectExpression can't be resolved.
       */
      /**
       * Extracts a PropType from an ObjectExpression node.
       * @param   {ASTNode} objectExpression ObjectExpression node.
       * @returns {Object[]}        Array of PropType object representations, to be consumed by `addPropTypesToComponent`.
       */
      /**
       * Extracts a PropType from a TypeAnnotation node.
       * @param   {ASTNode} node TypeAnnotation node.
       * @returns {Object[]}     Array of PropType object representations, to be consumed by `addPropTypesToComponent`.
       */
      /**
       * Handles Props defined in IntersectionTypeAnnotation nodes
       * e.g. type Props = PropsA & PropsB
       * @param   {ASTNode} intersectionTypeAnnotation ObjectExpression node.
       * @returns {Object[]}
       */
      /**
       * Tries to find a props type annotation in a stateless component.
       * @param  {ASTNode} node The AST node to look for a props type annotation.
       * @return {void}
       */
      /**
       * Marks a component's DefaultProps declaration as "unresolved". A component's DefaultProps is
       * marked as "unresolved" if we cannot safely infer the values of its defaultProps declarations
       * without risking false negatives.
       * @param   {Object} component The component to mark.
       * @returns {void}
       */
      /**
       * Reports all defaultProps passed in that don't have an appropriate propTypes counterpart.
       * @param  {Object[]} propTypes    Array of propTypes to check.
       * @param  {Object}   defaultProps Object of defaultProps to check. Keys are the props names.
       * @return {void}
       */
      /**
       * Tries to find the definition of a GenericTypeAnnotation in the current scope.
       * @param  {ASTNode}      node The node GenericTypeAnnotation node to resolve.
       * @return {ASTNode|null}      Return null if definition cannot be found, ASTNode otherwise.
       */
      /**
       * Try to resolve the node passed in to a variable in the current scope. If the node passed in is not
       * an Identifier, then the node is simply returned.
       * @param   {ASTNode} node The node to resolve.
       * @returns {ASTNode|null} Return null if the value could not be resolved, ASTNode otherwise.
       */
      /**
       * Helper for accessing the current scope in the stack.
       * @param {string} key The name of the identifier to access. If omitted, returns the full scope.
       * @param {ASTNode} value If provided sets the new value for the identifier.
       * @returns {Object|ASTNode} Either the whole scope or the ASTNode associated with the given identifier.
       */
      var addDefaultPropsToComponent, addPropTypesToComponent, allowRequiredDefaults, configuration, getDefaultPropsFromObjectExpression, getPropTypesFromObjectExpression, getPropTypesFromTypeAnnotation, getPropertiesFromIntersectionTypeAnnotationNode, handlePropTypeAnnotationClassProperty, handleStatelessComponent, isPropTypeAnnotation, markDefaultPropsAsUnresolved, propFromName, propWrapperFunctions, reportInvalidDefaultProps, resolveGenericTypeAnnotation, resolveNodeValue, resolveUnionTypeAnnotation, stack, typeScope;
      configuration = context.options[0] || {};
      allowRequiredDefaults = configuration.allowRequiredDefaults || false;
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      // Used to track the type annotations in scope.
      // Necessary because babel's scopes do not track type annotations.
      stack = null;
      resolveNodeValue = function(node) {
        if (node.type === 'Identifier') {
          return variableUtil.findVariableByName(context, node.name);
        }
        if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && node.arguments && node.arguments[0]) {
          return resolveNodeValue(node.arguments[0]);
        }
        return node;
      };
      typeScope = function(key, value) {
        if (arguments.length === 0) {
          return stack[stack.length - 1];
        }
        if (arguments.length === 1) {
          return stack[stack.length - 1][key];
        }
        stack[stack.length - 1][key] = value;
        return value;
      };
      resolveGenericTypeAnnotation = function(node) {
        if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
          return null;
        }
        return variableUtil.findVariableByName(context, node.id.name) || typeScope(node.id.name);
      };
      resolveUnionTypeAnnotation = function(node) {
        // Go through all the union and resolve any generic types.
        return node.types.map(function(annotation) {
          if (annotation.type === 'GenericTypeAnnotation') {
            return resolveGenericTypeAnnotation(annotation);
          }
          return annotation;
        });
      };
      getPropTypesFromObjectExpression = function(objectExpression) {
        var props;
        props = objectExpression.properties.filter(function(property) {
          return property.type !== 'ExperimentalSpreadProperty' && property.type !== 'SpreadElement';
        });
        return props.map(function(property) {
          return {
            name: property.key.name,
            isRequired: propsUtil.isRequiredPropType(property.value),
            node: property
          };
        });
      };
      getPropertiesFromIntersectionTypeAnnotationNode = function(annotation) {
        return annotation.types.reduce(function(properties, type) {
          annotation = resolveGenericTypeAnnotation(type);
          if (annotation != null ? annotation.id : void 0) {
            annotation/*:*/ = variableUtil.findVariableByName(context, annotation.id.name);
          }
          if (!annotation || !annotation.properties) {
            return properties;
          }
          return properties.concat(annotation.properties);
        }, []);
      };
      getPropTypesFromTypeAnnotation = function(node) {
        var annotation, properties, props, union;
        properties = [];
        switch (node.typeAnnotation.type) {
          case 'GenericTypeAnnotation':
            annotation = resolveGenericTypeAnnotation(node.typeAnnotation);
            if (annotation && annotation.type === 'IntersectionTypeAnnotation') {
              properties = getPropertiesFromIntersectionTypeAnnotationNode(annotation);
            } else {
              if (annotation != null ? annotation.id : void 0) {
                annotation = variableUtil.findVariableByName(context, annotation.id.name);
              }
              properties = annotation ? annotation.properties || [] : [];
            }
            break;
          case 'UnionTypeAnnotation':
            union = resolveUnionTypeAnnotation(node.typeAnnotation);
            properties = union.reduce(function(acc, curr) {
              if (!curr) {
                return acc;
              }
              return acc.concat(curr.properties);
            }, []);
            break;
          case 'ObjectTypeAnnotation':
            ({properties} = node.typeAnnotation);
            break;
          default:
            properties = [];
        }
        props = properties.filter(function(property) {
          return property.type === 'ObjectTypeProperty';
        });
        return props.map(function(property) {
          var name, tokens;
          // the `key` property is not present in ObjectTypeProperty nodes, so we need to get the key name manually.
          tokens = context.getFirstTokens(property, 1);
          name = tokens[0].value;
          return {
            name,
            isRequired: !property.optional,
            node: property
          };
        });
      };
      getDefaultPropsFromObjectExpression = function(objectExpression) {
        var hasSpread;
        hasSpread = objectExpression.properties.find(function(property) {
          var ref;
          return (ref = property.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement';
        });
        if (hasSpread) {
          return 'unresolved';
        }
        return objectExpression.properties.map(function(defaultProp) {
          return {
            name: defaultProp.key.name,
            node: defaultProp
          };
        });
      };
      markDefaultPropsAsUnresolved = function(component) {
        return components.set(component.node, {
          defaultProps: 'unresolved'
        });
      };
      addPropTypesToComponent = function(component, propTypes) {
        var props;
        props = component.propTypes || [];
        return components.set(component.node, {
          propTypes: props.concat(propTypes)
        });
      };
      addDefaultPropsToComponent = function(component, defaultProps) {
        var defaults;
        // Early return if this component's defaultProps is already marked as "unresolved".
        if (component.defaultProps === 'unresolved') {
          return;
        }
        if (defaultProps === 'unresolved') {
          markDefaultPropsAsUnresolved(component);
          return;
        }
        defaults = component.defaultProps || [];
        return components.set(component.node, {
          defaultProps: defaults.concat(defaultProps)
        });
      };
      handleStatelessComponent = function(node) {
        var component;
        if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
          return;
        }
        // find component this props annotation belongs to
        component = components.get(utils.getParentStatelessComponent());
        if (!component) {
          return;
        }
        return addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
      };
      handlePropTypeAnnotationClassProperty = function(node) {
        var component;
        // find component this props annotation belongs to
        component = components.get(utils.getParentES6Component());
        if (!component) {
          return;
        }
        return addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
      };
      isPropTypeAnnotation = function(node) {
        return astUtil.getPropertyName(node) === 'props' && !!node.typeAnnotation;
      };
      propFromName = function(propTypes, name) {
        return propTypes.find(function(prop) {
          return prop.name === name;
        });
      };
      reportInvalidDefaultProps = function(propTypes, defaultProps) {
        // If this defaultProps is "unresolved" or the propTypes is undefined, then we should ignore
        // this component and not report any errors for it, to avoid false-positives with e.g.
        // external defaultProps/propTypes declarations or spread operators.
        if (defaultProps === 'unresolved' || !propTypes) {
          return;
        }
        return defaultProps.forEach(function(defaultProp) {
          var prop;
          prop = propFromName(propTypes, defaultProp.name);
          if (prop && (allowRequiredDefaults || !prop.isRequired)) {
            return;
          }
          if (prop) {
            return context.report(defaultProp.node, 'defaultProp "{{name}}" defined for isRequired propType.', {
              name: defaultProp.name
            });
          } else {
            return context.report(defaultProp.node, 'defaultProp "{{name}}" has no corresponding propTypes declaration.', {
              name: defaultProp.name
            });
          }
        });
      };
      return {
        // --------------------------------------------------------------------------
        // Public API
        // --------------------------------------------------------------------------
        MemberExpression: function(node) {
          var component, expression, isDefaultProp, isPropType;
          isPropType = propsUtil.isPropTypesDeclaration(node);
          isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          // e.g.:
          // MyComponent.propTypes = {
          //   foo: React.PropTypes.string.isRequired,
          //   bar: React.PropTypes.string
          // };

          // or:

          // MyComponent.propTypes = myPropTypes;
          if (node.parent.type === 'AssignmentExpression') {
            expression = resolveNodeValue(node.parent.right);
            if (!expression || expression.type !== 'ObjectExpression') {
              // If a value can't be found, we mark the defaultProps declaration as "unresolved", because
              // we should ignore this component and not report any errors for it, to avoid false-positives
              // with e.g. external defaultProps declarations.
              if (isDefaultProp) {
                markDefaultPropsAsUnresolved(component);
              }
              return;
            }
            if (isPropType) {
              addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
            } else {
              addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
            }
            return;
          }
          // e.g.:
          // MyComponent.propTypes.baz = React.PropTypes.string;
          if (node.parent.type === 'MemberExpression' && node.parent.parent && node.parent.parent.type === 'AssignmentExpression') {
            if (isPropType) {
              return addPropTypesToComponent(component, [
                {
                  name: node.parent.property.name,
                  isRequired: propsUtil.isRequiredPropType(node.parent.parent.right),
                  node: node.parent.parent
                }
              ]);
            } else {
              return addDefaultPropsToComponent(component, [
                {
                  name: node.parent.property.name,
                  node: node.parent.parent
                }
              ]);
            }
          }
        },
        // e.g.:
        // class Hello extends React.Component {
        //   static get propTypes() {
        //     return {
        //       name: React.PropTypes.string
        //     };
        //   }
        //   static get defaultProps() {
        //     return {
        //       name: 'Dean'
        //     };
        //   }
        //   render() {
        //     return <div>Hello {this.props.name}</div>;
        //   }
        // }
        MethodDefinition: function(node) {
          var component, expression, isDefaultProp, isPropType, returnValue;
          if (!node.static || node.kind !== 'get') {
            return;
          }
          isPropType = propsUtil.isPropTypesDeclaration(node);
          isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = components.get(utils.getParentES6Component());
          if (!component) {
            return;
          }
          ({
            expression: returnValue
          } = utils.findReturnStatement(node));
          if (!returnValue) {
            return;
          }
          expression = resolveNodeValue(returnValue);
          if ((expression != null ? expression.type : void 0) !== 'ObjectExpression') {
            return;
          }
          if (isPropType) {
            return addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
          } else {
            return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
          }
        },
        // e.g.:
        // class Greeting extends React.Component {
        //   render() {
        //     return (
        //       <h1>Hello, {this.props.foo} {this.props.bar}</h1>
        //     );
        //   }
        //   static propTypes = {
        //     foo: React.PropTypes.string,
        //     bar: React.PropTypes.string.isRequired
        //   };
        // }
        ClassProperty: function(node) {
          var component, expression, isDefaultProp, isPropType, propName;
          if (isPropTypeAnnotation(node)) {
            handlePropTypeAnnotationClassProperty(node);
            return;
          }
          if (!node.static) {
            return;
          }
          if (!node.value) {
            return;
          }
          propName = astUtil.getPropertyName(node);
          isPropType = propName === 'propTypes';
          isDefaultProp = propName === 'defaultProps' || propName === 'getDefaultProps';
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = components.get(utils.getParentES6Component());
          if (!component) {
            return;
          }
          expression = resolveNodeValue(node.value);
          if (!expression || expression.type !== 'ObjectExpression') {
            return;
          }
          if (isPropType) {
            return addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
          } else {
            return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
          }
        },
        // e.g.:
        // React.createClass({
        //   render: function() {
        //     return <div>{this.props.foo}</div>;
        //   },
        //   propTypes: {
        //     foo: React.PropTypes.string.isRequired,
        //   },
        //   getDefaultProps: function() {
        //     return {
        //       foo: 'default'
        //     };
        //   }
        // });
        ObjectExpression: function(node) {
          var component;
          // find component this propTypes/defaultProps belongs to
          component = utils.isES5Component(node) && components.get(node);
          if (!component) {
            return;
          }
          // Search for the proptypes declaration
          return node.properties.forEach(function(property) {
            var isDefaultProp, isPropType, ref, returnValue;
            if ((ref = property.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
              return;
            }
            isPropType = propsUtil.isPropTypesDeclaration(property);
            isDefaultProp = propsUtil.isDefaultPropsDeclaration(property);
            if (!isPropType && !isDefaultProp) {
              return;
            }
            if (isPropType && property.value.type === 'ObjectExpression') {
              addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
              return;
            }
            if (isDefaultProp && property.value.type === 'FunctionExpression') {
              ({
                expression: returnValue
              } = utils.findReturnStatement(property));
              if ((returnValue != null ? returnValue.type : void 0) !== 'ObjectExpression') {
                return;
              }
              return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnValue));
            }
          });
        },
        TypeAlias: function(node) {
          return typeScope(node.id.name, node.right);
        },
        Program: function() {
          return stack = [{}];
        },
        BlockStatement: function() {
          return stack.push(Object.create(typeScope()));
        },
        'BlockStatement:exit': function() {
          return stack.pop();
        },
        // Check for type annotations in stateless components
        FunctionDeclaration: handleStatelessComponent,
        ArrowFunctionExpression: handleStatelessComponent,
        FunctionExpression: handleStatelessComponent,
        'Program:exit': function() {
          var _, component, list;
          stack = null;
          list = components.list();
          for (_ in list) {
            if (!hasProp.call(list, _)) continue;
            component = list[_];
            // If no defaultProps could be found, we don't report anything.
            if (!component.defaultProps) {
              return;
            }
            reportInvalidDefaultProps(component.propTypes, component.defaultProps || {});
          }
        }
      };
    })
  };

}).call(this);
