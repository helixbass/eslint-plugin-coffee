// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * # @fileoverview enforce a particular style for multiline comments
   * # @author Teddy Katz
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  /*
   * ------------------------------------------------------------------------------
   * Rule Definition
   * ------------------------------------------------------------------------------
   */
  module.exports = {
    meta: {
      docs: {
        description: 'enforce a particular style for multiline comments',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/multiline-comment-style'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['hashed-block',
        'starred-block',
        'separate-lines',
        'bare-block']
        }
      ]
    },
    create: function(context) {
      /**
       * # Each method checks a group of comments to see if it's valid according to the given option.
       * # @param {Token[]} commentGroup A list of comments that appear together. This will either contain a single
       * # block comment or multiple line comments.
       * # @returns {void}
       */
      /**
       * # Converts a comment into bare-block form
       * # @param {Token} firstComment The first comment of the group being converted
       * # @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
       * # @returns {string} A representation of the comment value in bare-block form
       */
      /**
       * # Converts a comment into separate-line form
       * # @param {Token} firstComment The first comment of the group being converted
       * # @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
       * # @returns {string} A representation of the comment value in separate-line form
       */
      /**
       * # Converts a comment into starred-block form
       * # @param {Token} firstComment The first comment of the group being converted
       * # @param {string[]} commentLinesList A list of lines to appear in the new starred-block comment
       * # @returns {string} A representation of the comment value in starred-block form, excluding start and end markers
       */
      /*
       * ----------------------------------------------------------------------
       * Helpers
       * ----------------------------------------------------------------------
       */
      /**
       * # Gets a list of comment lines in a group
       * # @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment
       * # @returns {string[]} A list of comment lines
       */
      /**
       * # Check a comment is JSDoc form
       * # @param {Token[]} commentGroup A group of comments, containing either multiple line comments or a single block comment
       * # @returns {boolean} if commentGroup is JSDoc form, return true
       */
      var ALIGNMENT_ERROR, END_NEWLINE_ERROR, EXPECTED_BLOCK_ERROR, EXPECTED_LINES_ERROR, MISSING_HASH_ERROR, MISSING_STAR_ERROR, START_NEWLINE_ERROR, commentGroupCheckers, convertToBlock, convertToHashedBlock, convertToSeparateLines, convertToStarredBlock, getCommentLines, isJSDoc, option, sourceCode;
      sourceCode = context.getSourceCode();
      option = context.options[0] || 'hashed-block';
      EXPECTED_BLOCK_ERROR = 'Expected a block comment instead of consecutive line comments.';
      START_NEWLINE_ERROR = "Expected a linebreak after '###'.";
      END_NEWLINE_ERROR = "Expected a linebreak before '###'.";
      MISSING_HASH_ERROR = "Expected a '#' at the start of this line.";
      MISSING_STAR_ERROR = "Expected a '*' at the start of this line.";
      ALIGNMENT_ERROR = 'Expected this line to be aligned with the start of the comment.';
      EXPECTED_LINES_ERROR = 'Expected multiple line comments instead of a block comment.';
      getCommentLines = function(commentGroup) {
        if (commentGroup[0].type === 'Line') {
          return commentGroup.map(function(comment) {
            return comment.value;
          });
        }
        return commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER).map(function(line) {
          return line.replace(/^\s*[*#]?/, '');
        });
      };
      convertToStarredBlock = function(firstComment, commentLinesList) {
        var initialOffset, starredLines;
        initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
        starredLines = commentLinesList.map(function(line) {
          return `${initialOffset} *${line}`;
        });
        return `\n${starredLines.join('\n')}\n${initialOffset}`;
      };
      convertToHashedBlock = function(firstComment, commentLinesList) {
        var hashedLines, initialOffset;
        initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
        hashedLines = commentLinesList.map(function(line) {
          return `${initialOffset}#${line}`;
        });
        return `\n${hashedLines.join('\n')}\n${initialOffset}`;
      };
      convertToSeparateLines = function(firstComment, commentLinesList) {
        var initialOffset, separateLines;
        initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
        separateLines = commentLinesList.map(function(line) {
          return `# ${line.trim()}`;
        });
        return separateLines.join(`\n${initialOffset}`);
      };
      convertToBlock = function(firstComment, commentLinesList) {
        var blockLines, initialOffset;
        initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
        blockLines = commentLinesList.map(function(line) {
          return line.trim();
        });
        return `### ${blockLines.join(`\n${initialOffset}    `)} ###`;
      };
      isJSDoc = function(commentGroup) {
        var lines;
        lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);
        return commentGroup[0].type === 'Block' && /^\*\s*$/.test(lines[0]) && lines.slice(1, -1).every(function(line) {
          return /^\s*[ #]/.test(line);
        }) && /^\s*$/.test(lines[lines.length - 1]);
      };
      commentGroupCheckers = {
        'hashed-block': function(commentGroup) {
          var block, commentLines, expectedLinePrefix, lineIndent, lineNumber, lineText, lines, results, start;
          commentLines = getCommentLines(commentGroup);
          if (commentLines.some(function(value) {
            return value.includes('###');
          })) {
            return;
          }
          if (commentGroup.length > 1) {
            return context.report({
              loc: {
                start: commentGroup[0].loc.start,
                end: commentGroup[commentGroup.length - 1].loc.end
              },
              message: EXPECTED_BLOCK_ERROR,
              fix: function(fixer) {
                var hashedBlock, range;
                range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                hashedBlock = `###${convertToHashedBlock(commentGroup[0], commentLines)}###`;
                if (commentLines.some(function(value) {
                  return value.startsWith('#');
                })) {
                  return null;
                } else {
                  return fixer.replaceTextRange(range, hashedBlock);
                }
              }
            });
          } else {
            block = commentGroup[0];
            lines = block.value.split(astUtils.LINEBREAK_MATCHER);
            lineIndent = sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0]);
            expectedLinePrefix = `${lineIndent}#`;
            if (!/^\*?\s*$/.test(lines[0])) {
              start = block.value.startsWith('*') ? block.range[0] + 1 : block.range[0];
              context.report({
                loc: {
                  start: block.loc.start,
                  end: {
                    line: block.loc.start.line,
                    column: block.loc.start.column + 2
                  }
                },
                message: START_NEWLINE_ERROR,
                fix: function(fixer) {
                  return fixer.insertTextAfterRange([start, start + '###'.length], `\n${expectedLinePrefix}`);
                }
              });
            }
            if (!/^\s*$/.test(lines[lines.length - 1])) {
              context.report({
                loc: {
                  start: {
                    line: block.loc.end.line,
                    column: block.loc.end.column - 2
                  },
                  end: block.loc.end
                },
                message: END_NEWLINE_ERROR,
                fix: function(fixer) {
                  return fixer.replaceTextRange([block.range[1] - '###'.length, block.range[1]], `\n${lineIndent}###`);
                }
              });
            }
            lineNumber = block.loc.start.line + 1;
            results = [];
            while (lineNumber <= block.loc.end.line) {
              lineText = sourceCode.lines[lineNumber - 1];
              if (!(lineNumber === block.loc.end.line ? lineText.startsWith(`${lineIndent}#`) : lineText.startsWith(expectedLinePrefix))) {
                context.report({
                  loc: {
                    start: {
                      line: lineNumber,
                      column: 0
                    },
                    end: {
                      line: lineNumber,
                      column: sourceCode.lines[lineNumber - 1].length
                    }
                  },
                  message: lineNumber === block.loc.end.line || /^\s*#/.test(lineText) ? ALIGNMENT_ERROR : MISSING_HASH_ERROR,
                  // eslint-disable-next-line coffee/no-loop-func
                  fix: function(fixer) {
                    var commentStartIndex, linePrefixLength, lineStartIndex, replacementText;
                    lineStartIndex = sourceCode.getIndexFromLoc({
                      line: lineNumber,
                      column: 0
                    });
                    linePrefixLength = lineText.match(/^\s*(?:#(?!##))? ?/)[0].length;
                    commentStartIndex = lineStartIndex + linePrefixLength;
                    replacementText = lineNumber === block.loc.end.line ? lineIndent : lineText.length === linePrefixLength ? expectedLinePrefix : `${expectedLinePrefix} `;
                    return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
                  }
                });
              }
              results.push(lineNumber++);
            }
            return results;
          }
        },
        'starred-block': function(commentGroup) {
          var block, commentLines, expectedLinePrefix, lineIndent, lineNumber, lineText, lines, results, start;
          commentLines = getCommentLines(commentGroup);
          if (commentLines.some(function(value) {
            return value.includes('###');
          })) {
            return;
          }
          if (commentGroup.length > 1) {
            return context.report({
              loc: {
                start: commentGroup[0].loc.start,
                end: commentGroup[commentGroup.length - 1].loc.end
              },
              message: EXPECTED_BLOCK_ERROR,
              fix: function(fixer) {
                var range, starredBlock;
                range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                starredBlock = `###${convertToStarredBlock(commentGroup[0], commentLines)}###`;
                if (commentLines.some(function(value) {
                  return value.startsWith('#');
                })) {
                  return null;
                } else {
                  return fixer.replaceTextRange(range, starredBlock);
                }
              }
            });
          } else {
            block = commentGroup[0];
            lines = block.value.split(astUtils.LINEBREAK_MATCHER);
            lineIndent = sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0]);
            expectedLinePrefix = `${lineIndent} *`;
            if (!/^\*?\s*$/.test(lines[0])) {
              start = block.value.startsWith('*') ? block.range[0] + 1 : block.range[0];
              context.report({
                loc: {
                  start: block.loc.start,
                  end: {
                    line: block.loc.start.line,
                    column: block.loc.start.column + 2
                  }
                },
                message: START_NEWLINE_ERROR,
                fix: function(fixer) {
                  return fixer.insertTextAfterRange([start, start + '###'.length], `\n${expectedLinePrefix}`);
                }
              });
            }
            if (!/^\s*$/.test(lines[lines.length - 1])) {
              context.report({
                loc: {
                  start: {
                    line: block.loc.end.line,
                    column: block.loc.end.column - 2
                  },
                  end: block.loc.end
                },
                message: END_NEWLINE_ERROR,
                fix: function(fixer) {
                  return fixer.replaceTextRange([block.range[1] - '###'.length, block.range[1]], `\n${lineIndent}###`);
                }
              });
            }
            lineNumber = block.loc.start.line + 1;
            results = [];
            while (lineNumber <= block.loc.end.line) {
              lineText = sourceCode.lines[lineNumber - 1];
              if (!(lineNumber === block.loc.end.line ? lineText.startsWith(`${lineIndent}#`) || lineText.startsWith(`${lineIndent} *`) : lineText.startsWith(expectedLinePrefix))) {
                context.report({
                  loc: {
                    start: {
                      line: lineNumber,
                      column: 0
                    },
                    end: {
                      line: lineNumber,
                      column: sourceCode.lines[lineNumber - 1].length
                    }
                  },
                  message: lineNumber === block.loc.end.line || /^\s*\*/.test(lineText) ? ALIGNMENT_ERROR : MISSING_STAR_ERROR,
                  // eslint-disable-next-line coffee/no-loop-func
                  fix: function(fixer) {
                    var commentStartIndex, linePrefixLength, lineStartIndex, replacementText;
                    lineStartIndex = sourceCode.getIndexFromLoc({
                      line: lineNumber,
                      column: 0
                    });
                    linePrefixLength = lineText.match(/^\s*\*? ?/)[0].length;
                    commentStartIndex = lineStartIndex + linePrefixLength;
                    replacementText = lineNumber === block.loc.end.line ? lineIndent : lineText.length === linePrefixLength ? expectedLinePrefix : `${expectedLinePrefix} `;
                    return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
                  }
                });
              }
              results.push(lineNumber++);
            }
            return results;
          }
        },
        'separate-lines': function(commentGroup) {
          var block, commentLines, tokenAfter;
          if (!isJSDoc(commentGroup) && commentGroup[0].type === 'Block') {
            commentLines = getCommentLines(commentGroup);
            block = commentGroup[0];
            tokenAfter = sourceCode.getTokenAfter(block, {
              includeComments: true
            });
            if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) {
              return;
            }
            return context.report({
              loc: {
                start: block.loc.start,
                end: {
                  line: block.loc.start.line,
                  column: block.loc.start.column + 2
                }
              },
              message: EXPECTED_LINES_ERROR,
              fix: function(fixer) {
                return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(function(line) {
                  return line;
                })));
              }
            });
          }
        },
        'bare-block': function(commentGroup) {
          var block, commentLines, lines;
          if (!isJSDoc(commentGroup)) {
            commentLines = getCommentLines(commentGroup);
            // disallows consecutive line comments in favor of using a block comment.
            if (commentGroup[0].type === 'Line' && commentLines.length > 1 && !commentLines.some(function(value) {
              return value.includes('###');
            })) {
              context.report({
                loc: {
                  start: commentGroup[0].loc.start,
                  end: commentGroup[commentGroup.length - 1].loc.end
                },
                message: EXPECTED_BLOCK_ERROR,
                fix: function(fixer) {
                  var block, range;
                  range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                  block = convertToBlock(commentGroup[0], commentLines.filter(function(line) {
                    return line;
                  }));
                  return fixer.replaceTextRange(range, block);
                }
              });
            }
            // prohibits block comments from having a * at the beginning of each line.
            if (commentGroup[0].type === 'Block') {
              block = commentGroup[0];
              lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(function(line) {
                return line.trim();
              });
              if (lines.length > 0 && lines.every(function(line) {
                return /^\s*[*#]/.test(line);
              })) {
                return context.report({
                  loc: {
                    start: block.loc.start,
                    end: {
                      line: block.loc.start.line,
                      column: block.loc.start.column + 2
                    }
                  },
                  message: EXPECTED_BLOCK_ERROR,
                  fix: function(fixer) {
                    return fixer.replaceText(block, convertToBlock(block, commentLines.filter(function(line) {
                      return line;
                    })));
                  }
                });
              }
            }
          }
        }
      };
      return {
        /*
         * ----------------------------------------------------------------------
         * Public
         * ----------------------------------------------------------------------
         */
        Program: function() {
          return sourceCode.getAllComments().filter(function(comment) {
            return comment.type !== 'Shebang';
          }).filter(function(comment) {
            return !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value);
          }).filter(function(comment) {
            var tokenBefore;
            tokenBefore = sourceCode.getTokenBefore(comment, {
              includeComments: true
            });
            return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
          }).reduce(function(commentGroups, comment, index, commentList) {
            var tokenBefore;
            tokenBefore = sourceCode.getTokenBefore(comment, {
              includeComments: true
            });
            if (comment.type === 'Line' && index && commentList[index - 1].type === 'Line' && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
              commentGroups[commentGroups.length - 1].push(comment);
            } else {
              commentGroups.push([comment]);
            }
            return commentGroups;
          }, []).filter(function(commentGroup) {
            return !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line);
          }).forEach(commentGroupCheckers[option]);
        }
      };
    }
  };

}).call(this);
