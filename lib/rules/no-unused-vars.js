// Generated by CoffeeScript 2.3.1
(function() {
  /**
   * @fileoverview Rule to flag declared but unused variables
   * @author Ilya Volodin
   */
  'use strict';
  var astUtils, lodash, utils;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  lodash = require('lodash');

  astUtils = require('eslint/lib/ast-utils');

  utils = require('../util/ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow unused variables',
        category: 'Variables',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-unused-vars'
      },
      schema: [
        {
          oneOf: [
            {
              enum: ['all',
            'local']
            },
            {
              type: 'object',
              properties: {
                vars: {
                  enum: ['all',
            'local']
                },
                varsIgnorePattern: {
                  type: 'string'
                },
                args: {
                  enum: ['all',
            'after-used',
            'none']
                },
                ignoreRestSiblings: {
                  type: 'boolean'
                },
                argsIgnorePattern: {
                  type: 'string'
                },
                caughtErrors: {
                  enum: ['all',
            'none']
                },
                caughtErrorsIgnorePattern: {
                  type: 'string'
                }
              }
            }
          ]
        }
      ]
    },
    create: function(context) {
      /**
       * Gets an array of variables without read references.
       * @param {Scope} scope - an eslint-scope Scope object.
       * @param {Variable[]} unusedVars - an array that saving result.
       * @returns {Variable[]} unused variables of the scope and descendant scopes.
       * @private
       */
      /**
       * Generate the warning message about the variable being
       * assigned and unused, including the ignore pattern if configured.
       * @returns {string} The warning message to be used with this unused variable.
       */
      /**
       * Gets the index of a given variable name in a given comment.
       * @param {eslint-scope.Variable} variable - A variable to get.
       * @param {ASTNode} comment - A comment node which includes the variable name.
       * @returns {number} The index of the variable name's location.
       * @private
       */
      /**
       * Generate the warning message about the variable being
       * defined and unused, including the ignore pattern if configured.
       * @param {Variable} unusedVar - eslint-scope variable object.
       * @returns {string} The warning message to be used with this unused variable.
       */
      /**
       * Creates the correct location of a given variables.
       * The location is at its name string in a `/*global` comment.
       *
       * @param {eslint-scope.Variable} variable - A variable to get its location.
       * @returns {{line: number, column: number}} The location object for the variable.
       * @private
       */
      /**
       * If a given reference is left-hand side of an assignment, this gets
       * the right-hand side node of the assignment.
       *
       * In the following cases, this returns null.
       *
       * - The reference is not the LHS of an assignment expression.
       * - The reference is inside of a loop.
       * - The reference is inside of a function scope which is different from
       *   the declaration.
       *
       * @param {eslint-scope.Reference} ref - A reference to check.
       * @param {ASTNode} prevRhsNode - The previous RHS node.
       * @returns {ASTNode|null} The RHS node or null.
       * @private
       */
      /**
       * Determines if a variable has a sibling rest property
       * @param {Variable} variable - eslint-scope variable object.
       * @returns {boolean} True if the variable is exported, false if not.
       * @private
       */
      /**
       * Checks whether the given variable is after the last used parameter.
       *
       * @param {eslint-scope.Variable} variable - The variable to check.
       * @returns {boolean} `true` if the variable is defined after the last
       * used parameter.
       */
      /**
       * Determines if a given variable is being exported from a module.
       * @param {Variable} variable - eslint-scope variable object.
       * @returns {boolean} True if the variable is exported, false if not.
       * @private
       */
      /**
       * Determine if an identifier is used either in for-in loops.
       *
       * @param {Reference} ref - The reference to check.
       * @returns {boolean} whether reference is used in the for-in loops
       * @private
       */
      /**
       * Checks the position of given nodes.
       *
       * @param {ASTNode} inner - A node which is expected as inside.
       * @param {ASTNode} outer - A node which is expected as outside.
       * @returns {boolean} `true` if the `inner` node exists in the `outer` node.
       * @private
       */
      /**
       * Checks whether a given Identifier node exists inside of a function node which can be used later.
       *
       * "can be used later" means:
       * - the function is assigned to a variable.
       * - the function is bound to a property and the object can be used later.
       * - the function is bound as an argument of a function call.
       *
       * If a reference exists in a function which can be used later, the reference is read when the function is called.
       *
       * @param {ASTNode} id - An Identifier node to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.
       * @private
       */
      /**
       * Checks whether a given reference is a read to update itself or not.
       *
       * @param {eslint-scope.Reference} ref - A reference to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} The reference is a read to update itself.
       * @private
       */
      /**
       * Determines if a reference is a read operation.
       * @param {Reference} ref - An eslint-scope Reference
       * @returns {boolean} whether the given reference represents a read operation
       * @private
       */
      /**
       * Determine if an identifier is referencing an enclosing function name.
       * @param {Reference} ref - The reference to check.
       * @param {ASTNode[]} nodes - The candidate function nodes.
       * @returns {boolean} True if it's a self-reference, false if not.
       * @private
       */
      /**
       * Checks whether a given function node is stored to somewhere or not.
       * If the function node is stored, the function can be used later.
       *
       * @param {ASTNode} funcNode - A function node to check.
       * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
       * @returns {boolean} `true` if under the following conditions:
       *      - the funcNode is assigned to a variable.
       *      - the funcNode is bound as an argument of a function call.
       *      - the function is bound to a property and the object satisfies above conditions.
       * @private
       */
      /**
       * Determines if the variable is used.
       * @param {Variable} variable - The variable to check.
       * @returns {boolean} True if the variable is used
       * @private
       */
      var REST_PROPERTY_TYPE, STATEMENT_TYPE, collectUnusedVariables, config, firstOption, getAssignedMessage, getColumnInComment, getDefinedMessage, getLocation, getRhsNode, hasRestSpreadSibling, isAfterLastUsedArg, isExported, isForInRef, isIife, isInside, isInsideOfStorableFunction, isReadForItself, isReadRef, isSelfReference, isStorableFunction, isUsedVariable, sourceCode;
      sourceCode = context.getSourceCode();
      REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/;
      config = {
        vars: 'all',
        args: 'after-used',
        ignoreRestSiblings: false,
        caughtErrors: 'none'
      };
      firstOption = context.options[0];
      if (firstOption) {
        if (typeof firstOption === 'string') {
          config.vars = firstOption;
        } else {
          config.vars = firstOption.vars || config.vars;
          config.args = firstOption.args || config.args;
          config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
          config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
          if (firstOption.varsIgnorePattern) {
            config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
          }
          if (firstOption.argsIgnorePattern) {
            config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
          }
          if (firstOption.caughtErrorsIgnorePattern) {
            config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
          }
        }
      }
      getDefinedMessage = function(unusedVar) {
        var additional, defType, pattern, ref1, type;
        defType = ((ref1 = unusedVar.defs) != null ? ref1[0] : void 0) && unusedVar.defs[0].type;
        if (defType === 'CatchClause' && config.caughtErrorsIgnorePattern) {
          type = 'args';
          pattern = config.caughtErrorsIgnorePattern.toString();
        } else if (defType === 'Parameter' && config.argsIgnorePattern) {
          type = 'args';
          pattern = config.argsIgnorePattern.toString();
        } else if (defType !== 'Parameter' && config.varsIgnorePattern) {
          type = 'vars';
          pattern = config.varsIgnorePattern.toString();
        }
        additional = type ? ` Allowed unused ${type} must match ${pattern}.` : '';
        return `'{{name}}' is defined but never used.${additional}`;
      };
      getAssignedMessage = function() {
        var additional;
        additional = config.varsIgnorePattern ? ` Allowed unused vars must match ${config.varsIgnorePattern.toString()}.` : '';
        return `'{{name}}' is assigned a value but never used.${additional}`;
      };
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      STATEMENT_TYPE = /(?:Statement|Declaration)$/;
      isExported = function(variable) {
        var definition, node;
        definition = variable.defs[0];
        if (definition) {
          ({node} = definition);
          if (node.declaration) {
            node = node.parent;
          } else {
            if (definition.type === 'Parameter') {
              return false;
            }
          }
          return node.parent.type.indexOf('Export') === 0;
        }
        return false;
      };
      hasRestSpreadSibling = function(variable) {
        if (config.ignoreRestSiblings) {
          return variable.defs.some(function(def) {
            var patternNode, propertyNode;
            propertyNode = def.name.parent;
            patternNode = propertyNode.parent;
            return propertyNode.type === 'Property' && patternNode.type === 'ObjectPattern' && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
          });
        }
        return false;
      };
      isReadRef = function(ref) {
        return ref.isRead();
      };
      isSelfReference = function(ref, nodes) {
        var i, len, node, scope;
        scope = ref.from;
        while (scope) {
          for (i = 0, len = nodes.length; i < len; i++) {
            node = nodes[i];
            if (scope.block === node.parent.right) {
              return true;
            }
          }
          scope = scope.upper;
        }
        return false;
      };
      isInside = function(inner, outer) {
        return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
      };
      getRhsNode = function(ref, prevRhsNode) {
        var canBeUsedLater, granpa, id, parent, refScope, varScope;
        id = ref.identifier;
        ({parent} = id);
        granpa = parent.parent;
        refScope = ref.from.variableScope;
        varScope = ref.resolved.scope.variableScope;
        canBeUsedLater = refScope !== varScope || utils.isInLoop(id);
        if (prevRhsNode && isInside(id, prevRhsNode)) {
          /*
           * Inherits the previous node if this reference is in the node.
           * This is for `a = a + a`-like code.
           */
          return prevRhsNode;
        }
        if (parent.type === 'AssignmentExpression' && granpa.type === 'ExpressionStatement' && id === parent.left && !canBeUsedLater) {
          return parent.right;
        }
        return null;
      };
      isStorableFunction = function(funcNode, rhsNode) {
        var node, parent;
        node = funcNode;
        ({parent} = funcNode);
        while (parent && isInside(parent, rhsNode)) {
          switch (parent.type) {
            case 'SequenceExpression':
              if (!(parent.expressions[parent.expressions.length - 1] === node)) {
                return false;
              }
              break;
            case 'CallExpression':
            case 'NewExpression':
              return parent.callee !== node;
            case 'AssignmentExpression':
            case 'TaggedTemplateExpression':
            case 'YieldExpression':
              return true;
            default:
              if (STATEMENT_TYPE.test(parent.type)) {
                /*
                 * If it encountered statements, this is a complex pattern.
                 * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.
                 */
                return true;
              }
          }
          node = parent;
          ({parent} = parent);
        }
        return false;
      };
      isInsideOfStorableFunction = function(id, rhsNode) {
        var funcNode;
        funcNode = astUtils.getUpperFunction(id);
        return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
      };
      isReadForItself = function(ref, rhsNode) {
        var granpa, id, parent;
        id = ref.identifier;
        ({parent} = id);
        granpa = parent.parent;
        // self update. e.g. `a += 1`, `a++`
        // in RHS of an assignment for itself. e.g. `a = a + 1`
        return ref.isRead() && ((parent.type === 'AssignmentExpression' && !parent.returns && granpa.type === 'ExpressionStatement' && parent.left === id) || (parent.type === 'UpdateExpression' && granpa.type === 'ExpressionStatement') || (rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode)));
      };
      isForInRef = function(ref) {
        var target;
        target = ref.identifier.parent;
        // "for (var ...) { return; }"
        if (target.type === 'VariableDeclarator') {
          target = target.parent.parent;
        }
        if (target.type !== 'ForInStatement') {
          return false;
        }
        // "for (...) { return; }"
        if (target.body.type === 'BlockStatement') {
          target = target.body.body[0];
        } else {
          // "for (...) return;"
          target = target.body;
        }
        if (!target) {
          // For empty loop body
          return false;
        }
        return target.type === 'ReturnStatement';
      };
      isIife = function(functionNodes) {
        return functionNodes.every(function({
            parent: funcAssignment
          }) {
          var parent;
          ({parent} = funcAssignment);
          if (parent.type === 'UnaryExpression' && parent.operator === 'do') {
            return true;
          }
          if (parent.type === 'CallExpression' && parent.callee === funcAssignment) {
            return true;
          }
          return false;
        });
      };
      isUsedVariable = function(variable) {
        var functionNodes, isFunctionDefinition, rhsNode;
        functionNodes = variable.defs.filter(function({node}) {
          return node.type === 'Identifier' && node.declaration && node.parent.type === 'AssignmentExpression' && node.parent.right.type === 'FunctionExpression';
        }).map(function(def) {
          return def.node;
        });
        isFunctionDefinition = functionNodes.length > 0;
        rhsNode = null;
        return variable.references.some(function(ref) {
          var forItself;
          if (isForInRef(ref)) {
            return true;
          }
          forItself = isReadForItself(ref, rhsNode);
          rhsNode = getRhsNode(ref, rhsNode);
          return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes) && !isIife(functionNodes));
        });
      };
      isAfterLastUsedArg = function(variable) {
        var def, params, posteriorParams;
        def = variable.defs[0];
        params = context.getDeclaredVariables(def.node);
        posteriorParams = params.slice(params.indexOf(variable) + 1);
        // If any used parameters occur after this parameter, do not report.
        return !posteriorParams.some(function(v) {
          return v.references.length > 0;
        });
      };
      collectUnusedVariables = function(scope, unusedVars) {
        var childScope, childScopes, def, i, j, len, len1, ref1, ref2, ref3, ref4, type, variable, variables;
        ({variables, childScopes} = scope);
        if (scope.type !== 'TDZ' && (scope.type !== 'global' || config.vars === 'all')) {
          for (i = 0, len = variables.length; i < len; i++) {
            variable = variables[i];
            if (scope.type === 'class' && scope.block.id === variable.identifiers[0]) {
              // skip a variable of class itself name in the class scope
              continue;
            }
            if (scope.functionExpressionScope || variable.eslintUsed) {
              // skip function expression names and variables marked with markVariableAsUsed()
              continue;
            }
            if (scope.type === 'function' && variable.name === 'arguments' && variable.identifiers.length === 0) {
              // skip implicit "arguments" variable
              continue;
            }
            // explicit global variables don't have definitions.
            def = variable.defs[0];
            if (def) {
              ({type} = def);
              // skip catch variables
              if (type === 'CatchClause') {
                if (config.caughtErrors === 'none') {
                  continue;
                }
                if ((ref1 = config.caughtErrorsIgnorePattern) != null ? ref1.test(def.name.name) : void 0) {
                  // skip ignored parameters
                  continue;
                }
              }
              if (type === 'Parameter') {
                if (((ref2 = def.node.parent.type) === 'Property' || ref2 === 'MethodDefinition') && def.node.parent.kind === 'set') {
                  // skip any setter argument
                  continue;
                }
                if (config.args === 'none') {
                  // if "args" option is "none", skip any parameter
                  continue;
                }
                if ((ref3 = config.argsIgnorePattern) != null ? ref3.test(def.name.name) : void 0) {
                  // skip ignored parameters
                  continue;
                }
                if (config.args === 'after-used' && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                  // if "args" option is "after-used", skip used variables
                  continue;
                }
              // skip ignored variables
              } else if ((ref4 = config.varsIgnorePattern) != null ? ref4.test(def.name.name) : void 0) {
                continue;
              }
            }
            if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
              unusedVars.push(variable);
            }
          }
        }
        for (j = 0, len1 = childScopes.length; j < len1; j++) {
          childScope = childScopes[j];
          collectUnusedVariables(childScope, unusedVars);
        }
        return unusedVars;
      };
      getColumnInComment = function(variable, comment) {
        var match, namePattern;
        namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\s,:])`, 'g');
        // To ignore the first text "global".
        namePattern.lastIndex = comment.value.indexOf('global') + 6;
        // Search a given variable name.
        match = namePattern.exec(comment.value);
        if (match) {
          return match.index + 1;
        } else {
          return 0;
        }
      };
      getLocation = function(variable) {
        var comment;
        comment = variable.eslintExplicitGlobalComment;
        return sourceCode.getLocFromIndex(comment.range[0] + 2 + getColumnInComment(variable, comment));
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        'Program:exit': function(programNode) {
          var i, len, results, unusedVar, unusedVars;
          unusedVars = collectUnusedVariables(context.getScope(), []);
          results = [];
          for (i = 0, len = unusedVars.length; i < len; i++) {
            unusedVar = unusedVars[i];
            if (unusedVar.eslintExplicitGlobal) {
              results.push(context.report({
                node: programNode,
                loc: getLocation(unusedVar),
                message: getDefinedMessage(unusedVar),
                data: unusedVar
              }));
            } else if (unusedVar.defs.length > 0) {
              results.push(context.report({
                node: unusedVar.identifiers[0],
                message: unusedVar.references.some(function(ref) {
                  return ref.isWrite();
                }) ? getAssignedMessage() : getDefinedMessage(unusedVar),
                data: unusedVar
              }));
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };
    }
  };

}).call(this);
