// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
   * @author Josh Perez
   */
  'use strict';
  var astUtils, keywords, validIdentifier;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;

  keywords = require('../eslint-keywords');

  module.exports = {
    meta: {
      docs: {
        description: 'enforce dot notation whenever possible',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/dot-notation'
      },
      schema: [
        {
          type: 'object',
          properties: {
            allowKeywords: {
              type: 'boolean'
            },
            allowPattern: {
              type: 'string'
            }
          },
          additionalProperties: false
        }
      ],
      fixable: 'code',
      messages: {
        useDot: '[{{key}}] is better written in dot notation.',
        useBrackets: '.{{key}} is a syntax error.'
      }
    },
    create: function(context) {
      /**
       * Check if the property is valid dot notation
       * @param {ASTNode} node The dot notation node
       * @param {string} value Value which is to be checked
       * @returns {void}
       */
      var allowKeywords, allowPattern, checkComputedProperty, options, sourceCode;
      options = context.options[0] || {};
      allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
      sourceCode = context.getSourceCode();
      if (options.allowPattern) {
        allowPattern = new RegExp(options.allowPattern);
      }
      checkComputedProperty = function(node, value) {
        var formattedValue;
        if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern != null ? allowPattern.test(value) : void 0)) {
          formattedValue = node.property.type === 'Literal' ? JSON.stringify(value) : `\"${value}\"`;
          return context.report({
            node: node.property,
            messageId: 'useDot',
            data: {
              key: formattedValue
            },
            fix: function(fixer) {
              var leftBracket, needsSpaceAfterProperty, rightBracket, textAfterProperty, textBeforeDot, tokenAfterProperty;
              leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
              rightBracket = sourceCode.getLastToken(node);
              if (sourceCode.getFirstTokenBetween(leftBracket, rightBracket, {
                includeComments: true,
                filter: astUtils.isCommentToken
              })) {
                // Don't perform any fixes if there are comments inside the brackets.
                return null;
              }
              tokenAfterProperty = sourceCode.getTokenAfter(rightBracket);
              needsSpaceAfterProperty = tokenAfterProperty && rightBracket.range[1] === tokenAfterProperty.range[0] && !astUtils.canTokensBeAdjacent(String(value), tokenAfterProperty);
              textBeforeDot = astUtils.isDecimalInteger(node.object) ? ' ' : '';
              textAfterProperty = needsSpaceAfterProperty ? ' ' : '';
              return fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], `${textBeforeDot}.${value}${textAfterProperty}`);
            }
          });
        }
      };
      return {
        MemberExpression: function(node) {
          if (node.computed && node.property.type === 'Literal') {
            checkComputedProperty(node, node.property.value);
          }
          if (node.computed && node.property.type === 'TemplateLiteral' && node.property.expressions.length === 0) {
            // TODO: use cooked once exposed on AST?
            // checkComputedProperty node, node.property.quasis[0].value.cooked
            checkComputedProperty(node, node.property.quasis[0].value.raw);
          }
          if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
            return context.report({
              node: node.property,
              messageId: 'useBrackets',
              data: {
                key: node.property.name
              },
              fix: function(fixer) {
                var dot, textAfterDot;
                dot = sourceCode.getTokenBefore(node.property);
                textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);
                if (textAfterDot.trim()) {
                  // Don't perform any fixes if there are comments between the dot and the property name.
                  return null;
                }
                // ###
                // # A statement that starts with `let[` is parsed as a destructuring variable declaration, not
                // # a MemberExpression.
                // ###
                // return null if (
                //   node.object.type is 'Identifier' and node.object.name is 'let'
                // )
                return fixer.replaceTextRange([dot.range[0], node.property.range[1]], `[${textAfterDot}\"${node.property.name}\"]`);
              }
            });
          }
        }
      };
    }
  };

}).call(this);
