// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Report when a DOM element is using both children and dangerouslySetInnerHTML
   * @author David Petersen
   */
  'use strict';
  var docsUrl, isDeclarationAssignment, variableUtil;

  variableUtil = require('../util/react/variable');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Report when a DOM element is using both children and dangerouslySetInnerHTML',
        category: '',
        recommended: true,
        url: docsUrl('no-danger-with-children')
      },
      schema: [] // no options
    },
    create: function(context) {
      /**
       * Takes a JSXElement and returns the value of the prop if it has it
       * @param {object} node - JSXElement node
       * @param {string} propName - name of the prop to look for
       */
      /**
       * Takes a ObjectExpression and returns the value of the prop if it has it
       * @param {object} node - ObjectExpression node
       * @param {string} propName - name of the prop to look for
       */
      /**
       * Checks to see if a node is a line break
       * @param {ASTNode} node The AST node being checked
       * @returns {Boolean} True if node is a line break, false if not
       */
      var findJsxProp, findObjectProp, findSpreadVariable, isLineBreak;
      findSpreadVariable = function(name) {
        return variableUtil.variablesInScope(context).find(function(item) {
          return item.name === name;
        });
      };
      findObjectProp = function(node, propName, seenProps) {
        if (!node.properties) {
          return false;
        }
        return node.properties.find(function(prop) {
          var newSeenProps, ref, ref1, ref2, ref3, ref4, ref5, val, variable;
          if (prop.type === 'Property') {
            return prop.key.name === propName;
          } else if ((ref = prop.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
            variable = findSpreadVariable(prop.argument.name);
            if ((val = (ref1 = variable != null ? (ref2 = variable.defs) != null ? (ref3 = ref2[0]) != null ? ref3.node.init : void 0 : void 0 : void 0) != null ? ref1 : isDeclarationAssignment(variable != null ? (ref4 = variable.defs) != null ? (ref5 = ref4[0]) != null ? ref5.node.parent : void 0 : void 0 : void 0) && variable.defs[0].node.parent.right)) {
              if (seenProps.indexOf(prop.argument.name) > -1) {
                return false;
              }
              newSeenProps = seenProps.concat(prop.argument.name || []);
              return findObjectProp(val, propName, newSeenProps);
            }
          }
          return false;
        });
      };
      findJsxProp = function(node, propName) {
        var attributes;
        ({attributes} = node.openingElement);
        return attributes.find(function(attribute) {
          var ref, ref1, ref2, variable;
          if (attribute.type === 'JSXSpreadAttribute') {
            variable = findSpreadVariable(attribute.argument.name);
            if ((variable != null ? (ref = variable.defs) != null ? (ref1 = ref[0]) != null ? ref1.node.init : void 0 : void 0 : void 0)) {
              return findObjectProp(variable.defs[0].node.init, propName, []);
            }
            if (isDeclarationAssignment(variable != null ? (ref2 = variable.defs[0]) != null ? ref2.node.parent : void 0 : void 0)) {
              return findObjectProp(variable.defs[0].node.parent.right, propName, []);
            }
          }
          return attribute.name && attribute.name.name === propName;
        });
      };
      isLineBreak = function(node) {
        var isLiteral, isMultiline, isWhiteSpaces, ref;
        isLiteral = (ref = node.type) === 'Literal' || ref === 'JSXText';
        // isMultiline = node.loc.start.line isnt node.loc.end.line
        isMultiline = /\n/.test(node.value);
        isWhiteSpaces = /^\s*$/.test(node.value);
        return isLiteral && isMultiline && isWhiteSpaces;
      };
      return {
        JSXElement: function(node) {
          var hasChildren;
          hasChildren = false;
          if (node.children.length && !isLineBreak(node.children[0])) {
            hasChildren = true;
          } else if (findJsxProp(node, 'children')) {
            hasChildren = true;
          }
          if (node.openingElement.attributes && hasChildren && findJsxProp(node, 'dangerouslySetInnerHTML')) {
            return context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
          }
        },
        CallExpression: function(node) {
          var dangerously, hasChildren, props, ref, ref1, variable;
          if (node.callee && node.callee.type === 'MemberExpression' && node.callee.property.name === 'createElement' && node.arguments.length > 1) {
            hasChildren = false;
            props = node.arguments[1];
            if (props.type === 'Identifier') {
              variable = variableUtil.variablesInScope(context).find(function(item) {
                return item.name === props.name;
              });
              if (variable != null ? (ref = variable.defs[0]) != null ? ref.node.init : void 0 : void 0) {
                props = variable.defs[0].node.init;
              } else if (isDeclarationAssignment(variable != null ? (ref1 = variable.defs[0]) != null ? ref1.node.parent : void 0 : void 0)) {
                props = variable.defs[0].node.parent.right;
              }
            }
            dangerously = findObjectProp(props, 'dangerouslySetInnerHTML', []);
            if (node.arguments.length === 2) {
              if (findObjectProp(props, 'children', [])) {
                hasChildren = true;
              }
            } else {
              hasChildren = true;
            }
            if (dangerously && hasChildren) {
              return context.report(node, 'Only set one of `children` or `props.dangerouslySetInnerHTML`');
            }
          }
        }
      };
    }
  };

}).call(this);
