// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Validates JSDoc comments are syntactically correct
   * @author Nicholas C. Zakas
   */
  'use strict';
  var convertCommentToJsStyleJsdoc, doctrine;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  doctrine = require('doctrine');

  ({convertCommentToJsStyleJsdoc} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce valid JSDoc comments',
        category: 'Possible Errors',
        recommended: false,
        url: 'https://eslint.org/docs/rules/valid-jsdoc'
      },
      schema: [
        {
          type: 'object',
          properties: {
            prefer: {
              type: 'object',
              additionalProperties: {
                type: 'string'
              }
            },
            preferType: {
              type: 'object',
              additionalProperties: {
                type: 'string'
              }
            },
            // requireReturn:
            //   type: 'boolean'
            requireParamDescription: {
              type: 'boolean'
            },
            requireReturnDescription: {
              type: 'boolean'
            },
            matchDescription: {
              type: 'string'
            },
            requireReturnType: {
              type: 'boolean'
            },
            requireParamType: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      fixable: 'code'
    },
    create: function(context) {
      /**
       * Indicate that return has been found in the current function.
       * @param {ASTNode} node The return node.
       * @returns {void}
       * @private
       */
      /**
       * Check if type should be validated based on some exceptions
       * @param {Object} type JSDoc tag
       * @returns {boolean} True if it can be validated
       * @private
       */
      /**
       * Validate the JSDoc node and output warnings if anything is wrong.
       * @param {ASTNode} node The AST node to check.
       * @returns {void}
       * @private
       */
      /**
       * Gets the location of a JSDoc node in a file
       * @param {Token} jsdocComment The comment that this node is parsed from
       * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment
       * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag
       */
      /**
       * Extract the current and expected type based on the input type object
       * @param {Object} type JSDoc tag
       * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and
       * the expected name of the annotation
       * @private
       */
      /**
       * Check if node type is a Class
       * @param {ASTNode} node node to check.
       * @returns {boolean} True is its a class
       * @private
       */
      /**
       * Check if return tag type is void or undefined
       * @param {Object} tag JSDoc tag
       * @returns {boolean} True if its of type void or undefined
       * @private
       */
      /**
       * When parsing a new function, store it in our function stack.
       * @param {ASTNode} node A function node to check.
       * @returns {void}
       * @private
       */
      /**
       * Validate type for a given JSDoc node
       * @param {Object} jsdocNode JSDoc node
       * @param {Object} type JSDoc tag
       * @returns {void}
       * @private
       */
      var addReturn, canTypeBeValidated, checkJSDoc, checkPreferType, fns, getAbsoluteRange, getCurrentExpectedTypes, isTypeClass, isValidReturnType, options, prefer, preferType, requireParamDescription, requireParamType, requireReturnDescription, requireReturnType, sourceCode, startFunction, validateType;
      options = context.options[0] || {};
      prefer = options.prefer || {};
      sourceCode = context.getSourceCode();
      // these both default to true, so you have to explicitly make them false
      // requireReturn = options.requireReturn isnt no
      requireParamDescription = options.requireParamDescription !== false;
      requireReturnDescription = options.requireReturnDescription !== false;
      requireReturnType = options.requireReturnType !== false;
      requireParamType = options.requireParamType !== false;
      preferType = options.preferType || {};
      checkPreferType = Object.keys(preferType).length !== 0;
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------

      // Using a stack to store if a function returns or not (handling nested functions)
      fns = [];
      isTypeClass = function(node) {
        var ref;
        return (ref = node.type) === 'ClassExpression' || ref === 'ClassDeclaration';
      };
      startFunction = function(node) {
        return fns.push({
          returnPresent: (node.type === 'ArrowFunctionExpression' && node.body.type !== 'BlockStatement') || isTypeClass(node) || node.async
        });
      };
      addReturn = function(node) {
        var functionState;
        functionState = fns[fns.length - 1];
        if (functionState && node.argument !== null) {
          return functionState.returnPresent = true;
        }
      };
      isValidReturnType = function(tag) {
        return tag.type === null || tag.type.name === 'void' || tag.type.type === 'UndefinedLiteral';
      };
      canTypeBeValidated = function(type) {
        return type !== 'UndefinedLiteral' && type !== 'NullLiteral' && type !== 'NullableLiteral' && type !== 'FunctionType' && type !== 'AllLiteral'; // {*}
      };
      getCurrentExpectedTypes = function(type) {
        var currentType;
        if (type.name) {
          currentType = type;
        } else if (type.expression) {
          currentType = type.expression;
        }
        return {
          currentType,
          expectedTypeName: currentType && preferType[currentType.name]
        };
      };
      getAbsoluteRange = function(jsdocComment, parsedJsdocNode) {
        return {
          start: sourceCode.getLocFromIndex(jsdocComment.range[0] + '###'.length + parsedJsdocNode.range[0]),
          end: sourceCode.getLocFromIndex(jsdocComment.range[0] + '###'.length + parsedJsdocNode.range[1])
        };
      };
      validateType = function(jsdocNode, type) {
        var elements, typesToCheck;
        if (!type || !canTypeBeValidated(type.type)) {
          return;
        }
        typesToCheck = [];
        elements = [];
        switch (type.type) {
          case 'TypeApplication': // {Array.<String>}
            elements = type.applications[0].type === 'UnionType' ? type.applications[0].elements : type.applications;
            typesToCheck.push(getCurrentExpectedTypes(type));
            break;
          case 'RecordType': // {{20:String}}
            elements = type.fields;
            break;
          case 'UnionType':
          case 'ArrayType': // {[String, number, Test]}
            ({elements} = type); // {String|number|Test}
            break;
          case 'FieldType': // Array.<{count: number, votes: number}>
            if (type.value) {
              typesToCheck.push(getCurrentExpectedTypes(type.value));
            }
            break;
          default:
            typesToCheck.push(getCurrentExpectedTypes(type));
        }
        elements.forEach(validateType.bind(null, jsdocNode));
        return typesToCheck.forEach(function(typeToCheck) {
          if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {
            return context.report({
              node: jsdocNode,
              message: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
              loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
              data: {
                currentTypeName: typeToCheck.currentType.name,
                expectedTypeName: typeToCheck.expectedTypeName
              },
              fix: function(fixer) {
                return fixer.replaceTextRange(typeToCheck.currentType.range.map(function(indexInComment) {
                  return jsdocNode.range[0] + '###'.length + indexInComment;
                }), typeToCheck.expectedTypeName);
              }
            });
          }
        });
      };
      checkJSDoc = function(node) {
        var ex, functionData, hasConstructor, hasReturns, isAbstract, isInterface, isOverride, jsdoc, jsdocNode, jsdocParamNames, paramTags, paramTagsByName, regex, returnsTag;
        jsdocNode = sourceCode.getJSDocComment(node);
        // eslint-disable-next-line coffee/no-unused-vars
        functionData = fns.pop();
        paramTagsByName = Object.create(null);
        paramTags = [];
        returnsTag = null;
        hasReturns = false;
        hasConstructor = false;
        isInterface = false;
        isOverride = false;
        // eslint-disable-next-line coffee/no-unused-vars
        isAbstract = false;
        // make sure only to validate JSDoc comments
        if (jsdocNode) {
          try {
            jsdoc = doctrine.parse(convertCommentToJsStyleJsdoc(jsdocNode.value), {
              strict: true,
              unwrap: true,
              sloppy: true,
              range: true
            });
          } catch (error) {
            ex = error;
            if (/braces/i.test(ex.message)) {
              context.report({
                node: jsdocNode,
                message: 'JSDoc type missing brace.'
              });
            } else {
              context.report({
                node: jsdocNode,
                message: 'JSDoc syntax error.'
              });
            }
            return;
          }
          jsdoc.tags.forEach(function(tag) {
            var entireTagRange;
            switch (tag.title.toLowerCase()) {
              case 'param':
              case 'arg':
              case 'argument':
                paramTags.push(tag);
                break;
              case 'return':
              case 'returns':
                hasReturns = true;
                returnsTag = tag;
                break;
              case 'constructor':
              case 'class':
                hasConstructor = true;
                break;
              case 'override':
              case 'inheritdoc':
                isOverride = true;
                break;
              case 'abstract':
              case 'virtual':
                isAbstract = true;
                break;
              case 'interface':
                isInterface = true;
            }
            // no default

            // check tag preferences
            if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
              entireTagRange = getAbsoluteRange(jsdocNode, tag);
              context.report({
                node: jsdocNode,
                message: 'Use @{{name}} instead.',
                loc: {
                  start: entireTagRange.start,
                  end: {
                    line: entireTagRange.start.line,
                    column: entireTagRange.start.column + `@${tag.title}`.length
                  }
                },
                data: {
                  name: prefer[tag.title]
                },
                fix: function(fixer) {
                  return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + '###'.length + '@'.length, jsdocNode.range[0] + tag.range[0] + tag.title.length + '###'.length + '@'.length], prefer[tag.title]);
                }
              });
            }
            // validate the types
            if (checkPreferType && tag.type) {
              return validateType(jsdocNode, tag.type);
            }
          });
          paramTags.forEach(function(param) {
            if (requireParamType && !param.type) {
              context.report({
                node: jsdocNode,
                message: "Missing JSDoc parameter type for '{{name}}'.",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {
                  name: param.name
                }
              });
            }
            if (!param.description && requireParamDescription) {
              context.report({
                node: jsdocNode,
                message: "Missing JSDoc parameter description for '{{name}}'.",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {
                  name: param.name
                }
              });
            }
            if (paramTagsByName[param.name]) {
              return context.report({
                node: jsdocNode,
                message: "Duplicate JSDoc parameter '{{name}}'.",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {
                  name: param.name
                }
              });
            } else if (param.name.indexOf('.') === -1) {
              return paramTagsByName[param.name] = param;
            }
          });
          if (hasReturns) {
            // if (
            //   not requireReturn and
            //   not functionData.returnPresent and
            //   (returnsTag.type is null or not isValidReturnType(returnsTag)) and
            //   not isAbstract
            // )
            //   context.report
            //     node: jsdocNode
            //     message:
            //       'Unexpected @{{title}} tag; function has no return statement.'
            //     loc: getAbsoluteRange jsdocNode, returnsTag
            //     data:
            //       title: returnsTag.title
            // else
            if (requireReturnType && !returnsTag.type) {
              context.report({
                node: jsdocNode,
                message: 'Missing JSDoc return type.'
              });
            }
            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
              context.report({
                node: jsdocNode,
                message: 'Missing JSDoc return description.'
              });
            }
          }
          // check for functions missing @returns
          if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== 'get' && node.parent.kind !== 'constructor' && node.parent.kind !== 'set' && !isTypeClass(node)) {
            // if requireReturn or (functionData.returnPresent and not node.async)
            context.report({
              node: jsdocNode,
              message: 'Missing JSDoc @{{returns}} for function.',
              data: {
                returns: prefer.returns || 'returns'
              }
            });
          }
          // check the parameters
          jsdocParamNames = Object.keys(paramTagsByName);
          if (node.params) {
            node.params.forEach(function(param, paramsIndex) {
              var bindingParam, name;
              bindingParam = param.type === 'AssignmentPattern' ? param.left : param;
              if (bindingParam.type === 'MemberExpression' && bindingParam.object.type === 'ThisExpression') {
                bindingParam = bindingParam.property;
              }
              // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
              if (bindingParam.type === 'Identifier') {
                ({name} = bindingParam);
                if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {
                  return context.report({
                    node: jsdocNode,
                    message: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                    data: {
                      name,
                      jsdocName: jsdocParamNames[paramsIndex]
                    }
                  });
                } else if (!paramTagsByName[name] && !isOverride) {
                  return context.report({
                    node: jsdocNode,
                    message: "Missing JSDoc for parameter '{{name}}'.",
                    data: {name}
                  });
                }
              }
            });
          }
          if (options.matchDescription) {
            regex = new RegExp(options.matchDescription);
            if (!regex.test(jsdoc.description)) {
              return context.report({
                node: jsdocNode,
                message: 'JSDoc description does not satisfy the regex pattern.'
              });
            }
          }
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        ArrowFunctionExpression: startFunction,
        FunctionExpression: startFunction,
        FunctionDeclaration: startFunction,
        ClassExpression: startFunction,
        ClassDeclaration: startFunction,
        'ArrowFunctionExpression:exit': checkJSDoc,
        'FunctionExpression:exit': checkJSDoc,
        'FunctionDeclaration:exit': checkJSDoc,
        'ClassExpression:exit': checkJSDoc,
        'ClassDeclaration:exit': checkJSDoc,
        ReturnStatement: addReturn
      };
    }
  };

}).call(this);
