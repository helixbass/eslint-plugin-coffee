// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Enforce propTypes declarations alphabetical sorting
   */
  'use strict';
  var docsUrl, propsUtil, variableUtil;

  variableUtil = require('../util/react/variable');

  propsUtil = require('../util/react/props');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce propTypes declarations alphabetical sorting',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('sort-prop-types')
      },
      // fixable: 'code'
      schema: [
        {
          type: 'object',
          properties: {
            requiredFirst: {
              type: 'boolean'
            },
            callbacksLast: {
              type: 'boolean'
            },
            ignoreCase: {
              type: 'boolean'
            },
            // Whether alphabetical sorting should be enforced
            noSortAlphabetically: {
              type: 'boolean'
            },
            sortShapeProp: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Checks if propTypes declarations are sorted
       * @param {Array} declarations The array of AST nodes being checked.
       * @returns {void}
       */
      var callbacksLast, checkNode, checkSorted, configuration, getKey, getShapeProperties, getValueName, ignoreCase, isCallbackPropName, isRequiredProp, isShapeProp, noSortAlphabetically, propWrapperFunctions, requiredFirst, sortShapeProp, sorter, sourceCode;
      sourceCode = context.getSourceCode();
      configuration = context.options[0] || {};
      requiredFirst = configuration.requiredFirst || false;
      callbacksLast = configuration.callbacksLast || false;
      ignoreCase = configuration.ignoreCase || false;
      noSortAlphabetically = configuration.noSortAlphabetically || false;
      sortShapeProp = configuration.sortShapeProp || false;
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      getKey = function(node) {
        var ref;
        if ((ref = node.key) != null ? ref.value : void 0) {
          return node.key.value;
        }
        return sourceCode.getText(node.key || node.argument);
      };
      getValueName = function(node) {
        return node.type === 'Property' && node.value.property && node.value.property.name;
      };
      isCallbackPropName = function(propName) {
        return /^on[A-Z]/.test(propName);
      };
      isRequiredProp = function(node) {
        return getValueName(node) === 'isRequired';
      };
      isShapeProp = function(node) {
        return Boolean((node != null ? node.callee : void 0) && node.callee.property && node.callee.property.name === 'shape');
      };
      getShapeProperties = function(node) {
        var ref;
        return ((ref = node.arguments) != null ? ref[0] : void 0) && node.arguments[0].properties;
      };
      sorter = function(a, b) {
        var aKey, bKey;
        aKey = getKey(a);
        bKey = getKey(b);
        if (requiredFirst) {
          if (isRequiredProp(a) && !isRequiredProp(b)) {
            return -1;
          }
          if (!isRequiredProp(a) && isRequiredProp(b)) {
            return 1;
          }
        }
        if (callbacksLast) {
          if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {
            return 1;
          }
          if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {
            return -1;
          }
        }
        if (ignoreCase) {
          aKey = aKey.toLowerCase();
          bKey = bKey.toLowerCase();
        }
        if (aKey < bKey) {
          return -1;
        }
        if (aKey > bKey) {
          return 1;
        }
        return 0;
      };
      checkSorted = function(declarations) {
        var fix;
        // Declarations will be `undefined` if the `shape` is not a literal. For
        // example, if it is a propType imported from another file.
        if (!declarations) {
          return;
        }
        // eslint-disable-next-line coffee/no-unused-vars
        fix = function(fixer) {
          var rangeEnd, rangeStart, sortInSource, source;
          sortInSource = function(allNodes, source) {
            var nodeGroups, originalSource;
            originalSource = source;
            nodeGroups = allNodes.reduce(function(acc, curr) {
              var ref;
              if ((ref = curr.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
                acc.push([]);
              } else {
                acc[acc.length - 1].push(curr);
              }
              return acc;
            }, [[]]);
            nodeGroups.forEach(function(nodes) {
              var attr, attrSource, i, j, results, shape, sortedAttr, sortedAttrText, sortedAttributes;
              sortedAttributes = nodes.slice().sort(sorter);
              results = [];
              for (i = j = nodes.length - 1; j >= 0; i = j += -1) {
                attr = nodes[i];
                sortedAttr = sortedAttributes[i];
                attr = nodes[i];
                sortedAttrText = sourceCode.getText(sortedAttr);
                if (sortShapeProp && isShapeProp(sortedAttr.value)) {
                  shape = getShapeProperties(sortedAttr.value);
                  if (shape) {
                    attrSource = sortInSource(shape, originalSource);
                    sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);
                  }
                }
                results.push(source = `${source.slice(0, attr.range[0])}${sortedAttrText}${source.slice(attr.range[1])}`);
              }
              return results;
            });
            return source;
          };
          source = sortInSource(declarations, context.getSourceCode().getText());
          rangeStart = declarations[0].range[0];
          rangeEnd = declarations[declarations.length - 1].range[1];
          return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
        };
        return declarations.reduce(function(prev, curr, idx, decls) {
          var currentIsCallback, currentIsRequired, currentPropName, prevPropName, previousIsCallback, previousIsRequired, ref;
          if ((ref = curr.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
            return decls[idx + 1];
          }
          prevPropName = getKey(prev);
          currentPropName = getKey(curr);
          previousIsRequired = isRequiredProp(prev);
          currentIsRequired = isRequiredProp(curr);
          previousIsCallback = isCallbackPropName(prevPropName);
          currentIsCallback = isCallbackPropName(currentPropName);
          if (ignoreCase) {
            prevPropName = prevPropName.toLowerCase();
            currentPropName = currentPropName.toLowerCase();
          }
          if (requiredFirst) {
            if (previousIsRequired && !currentIsRequired) {
              // Transition between required and non-required. Don't compare for alphabetical.
              return curr;
            }
            if (!previousIsRequired && currentIsRequired) {
              // Encountered a non-required prop after a required prop
              context.report({
                node: curr,
                message: 'Required prop types must be listed before all other prop types'
              });
              // fix
              return curr;
            }
          }
          if (callbacksLast) {
            if (!previousIsCallback && currentIsCallback) {
              // Entering the callback prop section
              return curr;
            }
            if (previousIsCallback && !currentIsCallback) {
              // Encountered a non-callback prop after a callback prop
              context.report({
                node: prev,
                message: 'Callback prop types must be listed after all other prop types'
              });
              // fix
              return prev;
            }
          }
          if (!noSortAlphabetically && currentPropName < prevPropName) {
            context.report({
              node: curr,
              message: 'Prop types declarations should be sorted alphabetically'
            });
            // fix
            return prev;
          }
          return curr;
        }, declarations[0]);
      };
      checkNode = function(node) {
        var innerNode, propTypesObject, ref;
        switch (node != null ? node.type : void 0) {
          case 'ObjectExpression':
            return checkSorted(node.properties);
          case 'Identifier':
            propTypesObject = variableUtil.findVariableByName(context, node.name);
            if (propTypesObject != null ? propTypesObject.properties : void 0) {
              return checkSorted(propTypesObject.properties);
            }
            break;
          case 'CallExpression':
            innerNode = (ref = node.arguments) != null ? ref[0] : void 0;
            if (propWrapperFunctions.has(node.callee.name) && innerNode) {
              return checkNode(innerNode);
            }
        }
      };
      return {
        CallExpression: function(node) {
          var ref;
          if (!sortShapeProp || !isShapeProp(node) || !((ref = node.arguments) != null ? ref[0] : void 0)) {
            return;
          }
          return checkSorted(node.arguments[0].properties);
        },
        ClassProperty: function(node) {
          if (!propsUtil.isPropTypesDeclaration(node)) {
            return;
          }
          return checkNode(node.value);
        },
        MemberExpression: function(node) {
          if (!propsUtil.isPropTypesDeclaration(node)) {
            return;
          }
          return checkNode(node.parent.right);
        },
        ObjectExpression: function(node) {
          return node.properties.forEach(function(property) {
            if (!property.key) {
              return;
            }
            if (!propsUtil.isPropTypesDeclaration(property)) {
              return;
            }
            if (property.value.type === 'ObjectExpression') {
              return checkSorted(property.value.properties);
            }
          });
        }
      };
    }
  };

}).call(this);
