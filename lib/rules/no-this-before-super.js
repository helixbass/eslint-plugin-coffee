// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A rule to disallow using `this`/`super` before `super()`.
   * @author Toru Nagashima
   */
  'use strict';
  var astUtils, isConstructorFunction,
    indexOf = [].indexOf;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Checks whether or not a given node is a constructor.
   * @param {ASTNode} node - A node to check. This node type is one of
   *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
   *   `ArrowFunctionExpression`.
   * @returns {boolean} `true` if the node is a constructor.
   */
  isConstructorFunction = function(node) {
    return node.type === 'FunctionExpression' && node.parent.type === 'MethodDefinition' && node.parent.kind === 'constructor';
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow `this`/`super` before calling `super()` in constructors',
        category: 'ECMAScript 6',
        recommended: true,
        url: 'https://eslint.org/docs/rules/no-this-before-super'
      },
      schema: []
    },
    create: function(context) {
      /*
       * Information for each constructor.
       * - upper:      Information of the upper constructor.
       * - hasExtends: A flag which shows whether the owner class has a valid
       *   `extends` part.
       * - scope:      The scope of the owner class.
       * - codePath:   The code path of this constructor.
       */
      /**
       * Checks whether or not this is before `super()` is called.
       * @returns {boolean} `true` if this is before `super()` is called.
       */
      /**
       * Gets whether or not `super()` is called in a given code path segment.
       * @param {CodePathSegment} segment - A code path segment to get.
       * @returns {boolean} `true` if `super()` is called.
       */
      /**
       * Checks whether or not this is in a constructor.
       * @returns {boolean} `true` if this is in a constructor.
       */
      /*
       * Information for each code path segment.
       * Each key is the id of a code path segment.
       * Each value is an object:
       * - superCalled:  The flag which shows `super()` called in all code paths.
       * - invalidNodes: The array of invalid ThisExpression and Super nodes.
       */
      /**
       * Sets a given node as invalid.
       * @param {ASTNode} node - A node to set as invalid. This is one of
       *      a ThisExpression and a Super.
       * @returns {void}
       */
      /**
       * Sets the current segment as `super` was called.
       * @returns {void}
       */
      var funcInfo, isBeforeCallOfSuper, isCalled, isInConstructorOfDerivedClass, isThisParam, segInfoMap, setInvalid, setSuperCalled;
      funcInfo = null;
      segInfoMap = Object.create(null);
      isCalled = function(segment) {
        return !segment.reachable || segInfoMap[segment.id].superCalled;
      };
      isInConstructorOfDerivedClass = function() {
        return Boolean((funcInfo != null ? funcInfo.isConstructor : void 0) && funcInfo.hasExtends);
      };
      isBeforeCallOfSuper = function() {
        return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
      };
      setInvalid = function(node) {
        var i, len, results, segment, segments;
        segments = funcInfo.codePath.currentSegments;
        results = [];
        for (i = 0, len = segments.length; i < len; i++) {
          segment = segments[i];
          if (segment.reachable) {
            results.push(segInfoMap[segment.id].invalidNodes.push(node));
          }
        }
        return results;
      };
      setSuperCalled = function() {
        var i, len, results, segment, segments;
        segments = funcInfo.codePath.currentSegments;
        results = [];
        for (i = 0, len = segments.length; i < len; i++) {
          segment = segments[i];
          if (segment.reachable) {
            results.push(segInfoMap[segment.id].superCalled = true);
          }
        }
        return results;
      };
      isThisParam = function(node) {
        var currentNode, func, params, prevNode;
        func = funcInfo.node;
        ({params} = func);
        if (!params.length) {
          return false;
        }
        prevNode = node;
        currentNode = node.parent;
        while (currentNode && currentNode !== func) {
          prevNode = currentNode;
          currentNode = currentNode.parent;
        }
        return indexOf.call(params, prevNode) >= 0;
      };
      return {
        /**
         * Adds information of a constructor into the stack.
         * @param {CodePath} codePath - A code path which was started.
         * @param {ASTNode} node - The current node.
         * @returns {void}
         */
        onCodePathStart: function(codePath, node) {
          var classNode;
          if (isConstructorFunction(node)) {
            // Class > ClassBody > MethodDefinition > FunctionExpression
            classNode = node.parent.parent.parent;
            return funcInfo = {
              upper: funcInfo,
              isConstructor: true,
              hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
              codePath,
              node,
              thisParams: []
            };
          } else {
            return funcInfo = {
              upper: funcInfo,
              isConstructor: false,
              hasExtends: false,
              codePath,
              node,
              thisParams: []
            };
          }
        },
        /**
         * Removes the top of stack item.
         *
         * And this treverses all segments of this code path then reports every
         * invalid node.
         *
         * @param {CodePath} codePath - A code path which was ended.
         * @param {ASTNode} node - The current node.
         * @returns {void}
         */
        onCodePathEnd: function(codePath) {
          var hasSuperBeenCalled, i, isDerivedClass, len, results, thisParam, thisParams;
          isDerivedClass = funcInfo.hasExtends;
          ({thisParams} = funcInfo);
          funcInfo = funcInfo.upper;
          if (!isDerivedClass) {
            return;
          }
          hasSuperBeenCalled = false;
          codePath.traverseSegments(function(segment, controller) {
            var i, info, invalidNode, len, ref;
            info = segInfoMap[segment.id];
            ref = info.invalidNodes;
            for (i = 0, len = ref.length; i < len; i++) {
              invalidNode = ref[i];
              context.report({
                message: "'{{kind}}' is not allowed before 'super()'.",
                node: invalidNode,
                data: {
                  kind: invalidNode.type === 'Super' ? 'super' : 'this'
                }
              });
            }
            if (info.superCalled) {
              hasSuperBeenCalled = true;
              return controller.skip();
            }
          });
          if (!hasSuperBeenCalled) {
            results = [];
            for (i = 0, len = thisParams.length; i < len; i++) {
              thisParam = thisParams[i];
              results.push(context.report({
                message: "'{{kind}}' is not allowed before 'super()'.",
                node: thisParam,
                data: {
                  kind: 'this'
                }
              }));
            }
            return results;
          }
        },
        /**
         * Initialize information of a given code path segment.
         * @param {CodePathSegment} segment - A code path segment to initialize.
         * @returns {void}
         */
        onCodePathSegmentStart: function(segment) {
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          // Initialize info.
          return segInfoMap[segment.id] = {
            superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
            invalidNodes: []
          };
        },
        /**
         * Update information of the code path segment when a code path was
         * looped.
         * @param {CodePathSegment} fromSegment - The code path segment of the
         *      end of a loop.
         * @param {CodePathSegment} toSegment - A code path segment of the head
         *      of a loop.
         * @returns {void}
         */
        onCodePathSegmentLoop: function(fromSegment, toSegment) {
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          // Update information inside of the loop.
          return funcInfo.codePath.traverseSegments({
            first: toSegment,
            last: fromSegment
          }, function(segment, controller) {
            var info;
            info = segInfoMap[segment.id];
            if (info.superCalled) {
              info.invalidNodes = [];
              return controller.skip();
            } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
              info.superCalled = true;
              return info.invalidNodes = [];
            }
          });
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node - A target node.
         * @returns {void}
         */
        ThisExpression: function(node) {
          if (isBeforeCallOfSuper()) {
            if (isThisParam(node)) {
              return funcInfo.thisParams.push(node);
            } else {
              return setInvalid(node);
            }
          }
        },
        /**
         * Reports if this is before `super()`.
         * @param {ASTNode} node - A target node.
         * @returns {void}
         */
        Super: function(node) {
          if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
            return setInvalid(node);
          }
        },
        /**
         * Marks `super()` called.
         * @param {ASTNode} node - A target node.
         * @returns {void}
         */
        'CallExpression:exit': function(node) {
          if (node.callee.type === 'Super' && isBeforeCallOfSuper()) {
            return setSuperCalled();
          }
        },
        /**
         * Resets state.
         * @returns {void}
         */
        'Program:exit': function() {
          return segInfoMap = Object.create(null);
        }
      };
    }
  };

}).call(this);
