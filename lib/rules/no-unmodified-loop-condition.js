// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to disallow use of unmodified expressions in loop conditions
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Gets the function which encloses a given reference.
   * This supports only FunctionDeclaration.
   *
   * @param {eslint-scope.Reference} reference - A reference to get.
   * @returns {ASTNode|null} The function node or null.
   */
  /**
   * Checks whether or not a given reference is inside of a loop node's condition.
   *
   * @param {ASTNode} node - A node to check.
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is inside of the loop node's
   *      condition.
   */
  /**
   * Checks whether or not a given reference is inside of a given node.
   *
   * @param {ASTNode} node - A node to check.
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is inside of the node.
   */
  /**
   * Checks whether or not a given loop condition info does not have the modified
   * flag.
   *
   * @param {LoopConditionInfo} condition - A loop condition info to check.
   * @returns {boolean} `true` if the loop condition info is "unmodified".
   */
  /**
   * Checks whether or not a given loop condition info does not have the modified
   * flag and does not have the group this condition belongs to.
   *
   * @param {LoopConditionInfo} condition - A loop condition info to check.
   * @returns {boolean} `true` if the loop condition info is "unmodified".
   */
  /**
   * @typedef {Object} LoopConditionInfo
   * @property {eslint-scope.Reference} reference - The reference.
   * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes
   *      that the reference is belonging to.
   * @property {Function} isInLoop - The predicate which checks a given reference
   *      is in this loop.
   * @property {boolean} modified - The flag that the reference is modified in
   *      this loop.
   */
  /**
   * Checks whether or not a given reference is a write reference.
   *
   * @param {eslint-scope.Reference} reference - A reference to check.
   * @returns {boolean} `true` if the reference is a write reference.
   */
  /**
   * Updates the "modified" flags of given loop conditions with given modifiers.
   *
   * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.
   * @param {eslint-scope.Reference[]} modifiers - The references to update.
   * @returns {void}
   */
  var DYNAMIC_PATTERN, GROUP_PATTERN, LOOP_PATTERN, SENTINEL_PATTERN, SKIP_PATTERN, Traverser, astUtils, getEncloseFunctionName, isInLoop, isInRange, isUnmodified, isUnmodifiedAndNotBelongToGroup, isWriteReference, updateModifiedFlag;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  Traverser = (function() {
    try {
      return require('eslint/lib/util/traverser');
    } catch (error) {
      return require('eslint/lib/shared/traverser');
    }
  })();

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;

  LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/; // for-in/of statements don't have `test` property.

  GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;

  SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;

  DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;

  isWriteReference = function(reference) {
    var def, ref;
    if (reference.init) {
      def = (ref = reference.resolved) != null ? ref.defs[0] : void 0;
      if (!def || def.type !== 'Variable' || def.parent.kind !== 'var') {
        return false;
      }
    }
    return reference.isWrite();
  };

  isUnmodified = function(condition) {
    return !condition.modified;
  };

  isUnmodifiedAndNotBelongToGroup = function(condition) {
    return !(condition.modified || condition.group);
  };

  isInRange = function(node, reference) {
    var ir, nr;
    nr = node.range;
    ir = reference.identifier.range;
    return nr[0] <= ir[0] && ir[1] <= nr[1];
  };

  isInLoop = {
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement: function(node, reference) {
      return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
    }
  };

  getEncloseFunctionName = function(reference) {
    var node;
    node = reference.identifier;
    while (node) {
      if (node.type === 'FunctionExpression') {
        if (node.parent.type === 'AssignmentExpression' && node.parent.left.type === 'Identifier') {
          return node.parent.left.name;
        }
        return null;
      }
      node = node.parent;
    }
    return null;
  };

  updateModifiedFlag = function(conditions, modifiers) {
    var condition, funcName, funcVar, inLoop, j, len, modifier, results;
/*
 * Besides checking for the condition being in the loop, we want to
 * check the function that this modifier is belonging to is called
 * in the loop.
 * FIXME: This should probably be extracted to a function.
 */
    results = [];
    for (j = 0, len = conditions.length; j < len; j++) {
      condition = conditions[j];
      results.push((function() {
        var k, len1, results1;
        results1 = [];
        for (k = 0, len1 = modifiers.length; k < len1; k++) {
          modifier = modifiers[k];
          if (!(!condition.modified)) {
            continue;
          }
          inLoop = condition.isInLoop(modifier) || !!((funcName = getEncloseFunctionName(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcName)) && funcVar.references.some(condition.isInLoop));
          results1.push(condition.modified = inLoop);
        }
        return results1;
      })());
    }
    return results;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow unmodified loop conditions',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-unmodified-loop-condition'
      },
      schema: []
    },
    create: function(context) {
      /**
       * Reports references which are inside of unmodified groups.
       *
       * @param {LoopConditionInfo[]} conditions - A loop condition info to report.
       * @returns {void}
       */
      /**
       * Finds unmodified references which are inside of a loop condition.
       * Then reports the references which are outside of groups.
       *
       * @param {eslint-scope.Variable} variable - A variable to report.
       * @returns {void}
       */
      /**
       * Checks whether or not a given group node has any dynamic elements.
       *
       * @param {ASTNode} root - A node to check.
       *      This node is one of BinaryExpression or ConditionalExpression.
       * @returns {boolean} `true` if the node is dynamic.
       */
      /**
       * Registers given conditions to the group the condition belongs to.
       *
       * @param {LoopConditionInfo[]} conditions - A loop condition info to
       *      register.
       * @returns {void}
       */
      /**
       * Reports a given condition info.
       *
       * @param {LoopConditionInfo} condition - A loop condition info to report.
       * @returns {void}
       */
      /**
       * Creates the loop condition information from a given reference.
       *
       * @param {eslint-scope.Reference} reference - A reference to create.
       * @returns {LoopConditionInfo|null} Created loop condition info, or null.
       */
      var checkConditionsInGroup, checkReferences, groupMap, hasDynamicExpressions, registerConditionsToGroup, report, sourceCode, toLoopCondition;
      sourceCode = context.getSourceCode();
      groupMap = null;
      report = function(condition) {
        var node;
        node = condition.reference.identifier;
        return context.report({
          node,
          message: "'{{name}}' is not modified in this loop.",
          data: node
        });
      };
      registerConditionsToGroup = function(conditions) {
        var condition, group, i, results;
        i = 0;
        results = [];
        while (i < conditions.length) {
          condition = conditions[i];
          if (condition.group) {
            group = groupMap.get(condition.group);
            if (!group) {
              group = [];
              groupMap.set(condition.group, group);
            }
            group.push(condition);
          }
          results.push(++i);
        }
        return results;
      };
      checkConditionsInGroup = function(conditions) {
        if (conditions.every(isUnmodified)) {
          return conditions.forEach(report);
        }
      };
      hasDynamicExpressions = function(root) {
        var retv;
        retv = false;
        Traverser.traverse(root, {
          visitorKeys: sourceCode.visitorKeys,
          enter: function(node) {
            if (DYNAMIC_PATTERN.test(node.type)) {
              retv = true;
              return this.break();
            } else if (SKIP_PATTERN.test(node.type)) {
              return this.skip();
            }
          }
        });
        return retv;
      };
      toLoopCondition = function(reference) {
        var child, group, node;
        if (reference.init) {
          return null;
        }
        group = null;
        child = reference.identifier;
        node = child.parent;
        while (node) {
          if (SENTINEL_PATTERN.test(node.type)) {
            if (LOOP_PATTERN.test(node.type) && node.test === child) {
              return {
                // This reference is inside of a loop condition.
                reference,
                group,
                isInLoop: isInLoop[node.type].bind(null, node),
                modified: false
              };
            }
            // This reference is outside of a loop condition.
            break;
          }
          /*
           * If it's inside of a group, OK if either operand is modified.
           * So stores the group this reference belongs to.
           */
          if (GROUP_PATTERN.test(node.type)) {
            // If this expression is dynamic, no need to check.
            if (hasDynamicExpressions(node)) {
              break;
            } else {
              group = node;
            }
          }
          child = node;
          node = node.parent;
        }
        return null;
      };
      checkReferences = function(variable) {
        var conditions, modifiers;
        // Gets references that exist in loop conditions.
        conditions = variable.references.map(toLoopCondition).filter(Boolean);
        if (conditions.length === 0) {
          return;
        }
        // Registers the conditions to belonging groups.
        registerConditionsToGroup(conditions);
        // Check the conditions are modified.
        modifiers = variable.references.filter(isWriteReference);
        if (modifiers.length > 0) {
          updateModifiedFlag(conditions, modifiers);
        }
        /*
         * Reports the conditions which are not belonging to groups.
         * Others will be reported after all variables are done.
         */
        return conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
      };
      return {
        'Program:exit': function() {
          var queue, scope;
          queue = [context.getScope()];
          groupMap = new Map();
          while (scope = queue.pop()) {
            queue.push(...scope.childScopes);
            scope.variables.forEach(checkReferences);
          }
          groupMap.forEach(checkConditionsInGroup);
          return groupMap = null;
        }
      };
    }
  };

}).call(this);
