// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to enforce linebreaks after open and before close array brackets
   * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>
   */
  'use strict';
  var astUtils, hasIndentedLastLine;

  astUtils = require('../eslint-ast-utils');

  ({hasIndentedLastLine} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce linebreaks after opening and before closing array brackets',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/array-bracket-newline'
      },
      // fixable: 'whitespace'
      schema: [
        {
          oneOf: [
            {
              enum: ['always',
            'never',
            'consistent']
            },
            {
              type: 'object',
              properties: {
                multiline: {
                  type: 'boolean'
                },
                minItems: {
                  type: ['integer',
            'null'],
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
        unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
        missingOpeningLinebreak: "A linebreak is required after '['.",
        missingClosingLinebreak: "A linebreak is required before ']'."
      }
    },
    create: function(context) {
      /**
       * Normalizes a given option value.
       *
       * @param {string|Object|undefined} options - An option value to parse.
       * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.
       */
      /**
       * Reports that there shouldn't be a linebreak after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      var check, normalizeOptionValue, normalizeOptions, reportNoBeginningLinebreak, reportNoEndingLinebreak, reportRequiredBeginningLinebreak, reportRequiredEndingLinebreak, sourceCode;
      sourceCode = context.getSourceCode();
      //----------------------------------------------------------------------
      // Helpers
      //----------------------------------------------------------------------
      /**
       * Normalizes a given option value.
       *
       * @param {string|Object|undefined} option - An option value to parse.
       * @returns {{multiline: boolean, minItems: number}} Normalized option object.
       */
      normalizeOptionValue = function(option) {
        var consistent, minItems, multiline;
        consistent = false;
        multiline = false;
        minItems = 0;
        if (option) {
          if (option === 'consistent') {
            consistent = true;
            minItems = Number.POSITIVE_INFINITY;
          } else if (option === 'always' || option.minItems === 0) {
            minItems = 0;
          } else if (option === 'never') {
            minItems = Number.POSITIVE_INFINITY;
          } else {
            multiline = Boolean(option.multiline);
            minItems = option.minItems || Number.POSITIVE_INFINITY;
          }
        } else {
          consistent = false;
          multiline = true;
          minItems = Number.POSITIVE_INFINITY;
        }
        return {consistent, multiline, minItems};
      };
      normalizeOptions = function(options) {
        var value;
        value = normalizeOptionValue(options);
        return {
          ArrayExpression: value,
          ArrayPattern: value
        };
      };
      reportNoBeginningLinebreak = function(node, token) {
        return context.report({
          node,
          loc: token.loc,
          messageId: 'unexpectedOpeningLinebreak'
        });
      };
      /**
       * Reports that there shouldn't be a linebreak before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      // fix: (fixer) ->
      //   nextToken = sourceCode.getTokenAfter token, includeComments: yes

      //   return null if astUtils.isCommentToken nextToken

      //   fixer.removeRange [token.range[1], nextToken.range[0]]
      reportNoEndingLinebreak = function(node, token) {
        return context.report({
          node,
          loc: token.loc,
          messageId: 'unexpectedClosingLinebreak'
        });
      };
      /**
       * Reports that there should be a linebreak after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      // fix: (fixer) ->
      //   previousToken = sourceCode.getTokenBefore token, includeComments: yes

      //   return null if astUtils.isCommentToken previousToken

      //   fixer.removeRange [previousToken.range[1], token.range[0]]
      reportRequiredBeginningLinebreak = function(node, token) {
        return context.report({
          node,
          loc: token.loc,
          messageId: 'missingOpeningLinebreak'
        });
      };
      /**
       * Reports that there should be a linebreak before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      // fix: (fixer) -> fixer.insertTextAfter token, '\n'
      reportRequiredEndingLinebreak = function(node, token) {
        return context.report({
          node,
          loc: token.loc,
          messageId: 'missingClosingLinebreak'
        });
      };
      // getIndentSize: ({node, openBracket}) ->
      //   openBracketLine = openBracket.loc.start.line
      //   currentMin = null
      //   for element in node.elements when node.loc.start.line > openBracketLine
      //     {column} = element.loc.start
      //     currentMin = column if not currentMin? or column < currentMin
      /**
       * Reports a given node if it violated this rule.
       *
       * @param {ASTNode} node - A node to check. This is an ArrayExpression node or an ArrayPattern node.
       * @returns {void}
       */
      // fix: (fixer) -> fixer.insertTextBefore token, '\n'
      check = function(node) {
        var closeBracket, elements, first, firstIncComment, last, lastElementHasIndentedBody, lastIncComment, needsLinebreaks, normalizedOptions, openBracket, options;
        ({elements} = node);
        normalizedOptions = normalizeOptions(context.options[0]);
        options = normalizedOptions[node.type];
        openBracket = sourceCode.getFirstToken(node);
        closeBracket = sourceCode.getLastToken(node);
        firstIncComment = sourceCode.getTokenAfter(openBracket, {
          includeComments: true
        });
        lastIncComment = sourceCode.getTokenBefore(closeBracket, {
          includeComments: true
        });
        first = sourceCode.getTokenAfter(openBracket);
        last = sourceCode.getTokenBefore(closeBracket);
        // indentSize = getIndentSize {node, openBracket}
        lastElementHasIndentedBody = (function() {
          var lastElement;
          if (!elements.length) {
            return false;
          }
          lastElement = elements[elements.length - 1];
          if (!lastElement) {
            return false;
          }
          if (!(lastElement.loc.start.line < lastElement.loc.end.line)) {
            return false;
          }
          if (lastElement.loc.start.line === openBracket.loc.start.line) {
            return true;
          }
          return hasIndentedLastLine({
            node: lastElement,
            sourceCode
          });
        })();
        needsLinebreaks = elements.length >= options.minItems || (options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line) || (elements.length === 0 && firstIncComment.type === 'Block' && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment) || (options.consistent && firstIncComment.loc.start.line !== openBracket.loc.end.line);
        /*
         * Use tokens or comments to check multiline or not.
         * But use only tokens to check whether linebreaks are needed.
         * This allows:
         *     var arr = [ // eslint-disable-line foo
         *         'a'
         *     ]
         */
        if (needsLinebreaks) {
          if (astUtils.isTokenOnSameLine(openBracket, first)) {
            reportRequiredBeginningLinebreak(node, openBracket);
          }
          if (astUtils.isTokenOnSameLine(last, closeBracket)) {
            return reportRequiredEndingLinebreak(node, closeBracket);
          }
        } else {
          if (!astUtils.isTokenOnSameLine(openBracket, first)) {
            reportNoBeginningLinebreak(node, openBracket);
          }
          if (!lastElementHasIndentedBody && !astUtils.isTokenOnSameLine(last, closeBracket)) {
            return reportNoEndingLinebreak(node, closeBracket);
          }
        }
      };
      return {
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        ArrayPattern: check,
        ArrayExpression: check
      };
    }
  };

}).call(this);
