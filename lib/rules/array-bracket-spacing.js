// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Disallows or enforces spaces inside of array brackets.
   * @author Jamund Ferguson
   */
  'use strict';
  var astUtils;

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing inside array brackets',
        category: 'Stylistic Issues',
        recommended: false,
        url: 'https://eslint.org/docs/rules/array-bracket-spacing'
      },
      fixable: 'whitespace',
      schema: [
        {
          enum: ['always',
        'never']
        },
        {
          type: 'object',
          properties: {
            singleValue: {
              type: 'boolean'
            },
            objectsInArrays: {
              type: 'boolean'
            },
            arraysInArrays: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'."
      }
    },
    create: function(context) {
      /**
       * Determines if a node is an array type
       * @param {ASTNode} node - The node to check.
       * @returns {boolean} Whether or not the node is an array type.
       */
      /**
       * Determines if a node is an object type
       * @param {ASTNode} node - The node to check.
       * @returns {boolean} Whether or not the node is an object type.
       */
      /**
       * Determines whether an option is set, relative to the spacing option.
       * If spaced is "always", then check whether option is set to false.
       * If spaced is "never", then check whether option is set to true.
       * @param {Object} option - The option to exclude.
       * @returns {boolean} Whether or not the property is excluded.
       */
      /**
       * Reports that there shouldn't be a space before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Reports that there should be a space after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Reports that there should be a space before the last token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      /**
       * Validates the spacing around array brackets
       * @param {ASTNode} node - The node we're checking for spacing
       * @returns {void}
       */
      var isArrayType, isObjectType, isOptionSet, options, reportNoBeginningSpace, reportNoEndingSpace, reportRequiredBeginningSpace, reportRequiredEndingSpace, sourceCode, spaced, validateArraySpacing;
      spaced = context.options[0] === 'always';
      sourceCode = context.getSourceCode();
      isOptionSet = function(option) {
        if (context.options[1]) {
          return context.options[1][option] === !spaced;
        } else {
          return false;
        }
      };
      options = {
        spaced,
        singleElementException: isOptionSet('singleValue'),
        objectsInArraysException: isOptionSet('objectsInArrays'),
        arraysInArraysException: isOptionSet('arraysInArrays')
      };
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * Reports that there shouldn't be a space after the first token
       * @param {ASTNode} node - The node to report in the event of an error.
       * @param {Token} token - The token to use for the report.
       * @returns {void}
       */
      reportNoBeginningSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          messageId: 'unexpectedSpaceAfter',
          data: {
            tokenValue: token.value
          },
          fix: function(fixer) {
            var nextToken;
            nextToken = sourceCode.getTokenAfter(token);
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      };
      reportNoEndingSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          messageId: 'unexpectedSpaceBefore',
          data: {
            tokenValue: token.value
          },
          fix: function(fixer) {
            var previousToken;
            previousToken = sourceCode.getTokenBefore(token);
            return fixer.removeRange([previousToken.range[1], token.range[0]]);
          }
        });
      };
      reportRequiredBeginningSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          messageId: 'missingSpaceAfter',
          data: {
            tokenValue: token.value
          },
          fix: function(fixer) {
            return fixer.insertTextAfter(token, ' ');
          }
        });
      };
      reportRequiredEndingSpace = function(node, token) {
        return context.report({
          node,
          loc: token.loc.start,
          messageId: 'missingSpaceBefore',
          data: {
            tokenValue: token.value
          },
          fix: function(fixer) {
            return fixer.insertTextBefore(token, ' ');
          }
        });
      };
      isObjectType = function(node) {
        var ref;
        return node && ((ref = node.type) === 'ObjectExpression' || ref === 'ObjectPattern') && !node.implicit;
      };
      isArrayType = function(node) {
        var ref;
        return node && ((ref = node.type) === 'ArrayExpression' || ref === 'ArrayPattern');
      };
      validateArraySpacing = function(node) {
        var closingBracketMustBeSpaced, first, firstElement, last, lastElement, openingBracketMustBeSpaced, penultimate, second;
        if (options.spaced && node.elements.length === 0) {
          return;
        }
        first = sourceCode.getFirstToken(node);
        second = sourceCode.getFirstToken(node, 1);
        last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node);
        penultimate = sourceCode.getTokenBefore(last);
        firstElement = node.elements[0];
        lastElement = node.elements[node.elements.length - 1];
        openingBracketMustBeSpaced = ((options.objectsInArraysException && isObjectType(firstElement)) || (options.arraysInArraysException && isArrayType(firstElement)) || (options.singleElementException && node.elements.length === 1)) ? !options.spaced : options.spaced;
        closingBracketMustBeSpaced = ((options.objectsInArraysException && isObjectType(lastElement)) || (options.arraysInArraysException && isArrayType(lastElement)) || (options.singleElementException && node.elements.length === 1)) ? !options.spaced : options.spaced;
        if (astUtils.isTokenOnSameLine(first, second)) {
          if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
            reportRequiredBeginningSpace(node, first);
          }
          if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
            reportNoBeginningSpace(node, first);
          }
        }
        if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
          if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
            reportRequiredEndingSpace(node, last);
          }
          if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
            return reportNoEndingSpace(node, last);
          }
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        ArrayPattern: validateArraySpacing,
        ArrayExpression: validateArraySpacing
      };
    }
  };

}).call(this);
