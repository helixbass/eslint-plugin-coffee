// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Ensures that the results of typeof are compared against a valid string
   * @author Ian Christian Myers
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce comparing `typeof` expressions against valid strings',
        category: 'Possible Errors',
        recommended: true,
        url: 'https://eslint.org/docs/rules/valid-typeof'
      },
      schema: [
        {
          type: 'object',
          properties: {
            requireStringLiterals: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Determines whether a node is a typeof expression.
       * @param {ASTNode} node The node
       * @returns {boolean} `true` if the node is a typeof expression
       */
      var OPERATORS, VALID_TYPES, isTypeofExpression, ref, requireStringLiterals;
      VALID_TYPES = ['symbol', 'undefined', 'object', 'boolean', 'number', 'string', 'function'];
      OPERATORS = ['==', 'is', '!=', 'isnt'];
      requireStringLiterals = (ref = context.options[0]) != null ? ref.requireStringLiterals : void 0;
      isTypeofExpression = function(node) {
        return node.type === 'UnaryExpression' && node.operator === 'typeof';
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        UnaryExpression: function(node) {
          var parent, sibling, value;
          if (isTypeofExpression(node)) {
            parent = context.getAncestors().pop();
            if (parent.type === 'BinaryExpression' && OPERATORS.indexOf(parent.operator) !== -1) {
              sibling = parent.left === node ? parent.right : parent.left;
              if (sibling.type === 'Literal' || (sibling.type === 'TemplateLiteral' && !sibling.expressions.length)) {
                value = sibling.type === 'Literal' ? sibling.value : sibling.quasis[0].value.cooked;
                if (VALID_TYPES.indexOf(value) === -1) {
                  return context.report({
                    node: sibling,
                    message: 'Invalid typeof comparison value.'
                  });
                }
              } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
                return context.report({
                  node: sibling,
                  message: 'Typeof comparisons should be to string literals.'
                });
              }
            }
          }
        }
      };
    }
  };

}).call(this);
