// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent common casing typos
   */
  'use strict';
  var Components, LIFECYCLE_METHODS, PROP_TYPES, STATIC_CLASS_PROPERTIES, docsUrl;

  Components = require('../util/react/Components');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  STATIC_CLASS_PROPERTIES = ['propTypes', 'contextTypes', 'childContextTypes', 'defaultProps'];

  LIFECYCLE_METHODS = ['getDerivedStateFromProps', 'componentWillMount', 'UNSAFE_componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'UNSAFE_componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'UNSAFE_componentWillUpdate', 'getSnapshotBeforeUpdate', 'componentDidUpdate', 'componentDidCatch', 'componentWillUnmount', 'render'];

  PROP_TYPES = Object.keys(require('prop-types'));

  module.exports = {
    meta: {
      docs: {
        description: 'Prevent common typos',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('no-typos')
      },
      schema: []
    },
    create: Components.detect(function(context, components, utils) {
      /* eslint-disable coffee/no-use-before-define */
      /* eslint-enable no-use-before-define */
      var checkValidCallExpression, checkValidProp, checkValidPropObject, checkValidPropType, checkValidPropTypeQualifier, isPropTypesPackage, propTypesPackageName, reactPackageName, reportErrorIfClassPropertyCasingTypo, reportErrorIfLifecycleMethodCasingTypo;
      propTypesPackageName = null;
      reactPackageName = null;
      checkValidPropTypeQualifier = function(node) {
        if (node.name !== 'isRequired') {
          return context.report({
            node,
            message: `Typo in prop type chain qualifier: ${node.name}`
          });
        }
      };
      checkValidPropType = function(node) {
        if (node.name && !PROP_TYPES.some(function(propTypeName) {
          return propTypeName === node.name;
        })) {
          return context.report({
            node,
            message: `Typo in declared prop type: ${node.name}`
          });
        }
      };
      isPropTypesPackage = function(node) {
        return (node.type === 'Identifier' && node.name === propTypesPackageName) || (node.type === 'MemberExpression' && node.property.name === 'PropTypes' && node.object.name === reactPackageName);
      };
      checkValidCallExpression = function(node) {
        var args, callee;
        ({callee} = node);
        if (callee.type === 'MemberExpression' && callee.property.name === 'shape') {
          return checkValidPropObject(node.arguments[0]);
        } else if (callee.type === 'MemberExpression' && callee.property.name === 'oneOfType') {
          args = node.arguments[0];
          if (args && args.type === 'ArrayExpression') {
            return args.elements.forEach(function(el) {
              return checkValidProp(el);
            });
          }
        }
      };
      checkValidProp = function(node) {
        if ((!propTypesPackageName && !reactPackageName) || !node) {
          return;
        }
        if (node.type === 'MemberExpression') {
          if (node.object.type === 'MemberExpression' && isPropTypesPackage(node.object.object)) {
            // PropTypes.myProp.isRequired
            checkValidPropType(node.object.property);
            return checkValidPropTypeQualifier(node.property);
          } else if (isPropTypesPackage(node.object) && node.property.name !== 'isRequired') {
            // PropTypes.myProp
            return checkValidPropType(node.property);
          } else if (node.object.type === 'CallExpression') {
            checkValidPropTypeQualifier(node.property);
            return checkValidCallExpression(node.object);
          }
        } else if (node.type === 'CallExpression') {
          return checkValidCallExpression(node);
        }
      };
      checkValidPropObject = function(node) {
        if (node && node.type === 'ObjectExpression') {
          return node.properties.forEach(function(prop) {
            return checkValidProp(prop.value);
          });
        }
      };
      reportErrorIfClassPropertyCasingTypo = function(node, propertyName) {
        if (propertyName === 'propTypes' || propertyName === 'contextTypes' || propertyName === 'childContextTypes') {
          checkValidPropObject(node);
        }
        return STATIC_CLASS_PROPERTIES.forEach(function(CLASS_PROP) {
          if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) {
            return context.report({
              node,
              message: 'Typo in static class property declaration'
            });
          }
        });
      };
      reportErrorIfLifecycleMethodCasingTypo = function(node) {
        return LIFECYCLE_METHODS.forEach(function(method) {
          if (method.toLowerCase() === node.key.name.toLowerCase() && method !== node.key.name) {
            return context.report({
              node,
              message: 'Typo in component lifecycle method declaration'
            });
          }
        });
      };
      return {
        ImportDeclaration: function(node) {
          var propTypesSpecifier;
          if (node.source && node.source.value === 'prop-types') {
            // import PropType from "prop-types"
            return propTypesPackageName = node.specifiers[0].local.name;
          } else if (node.source && node.source.value === 'react') {
            // import { PropTypes } from "react"
            if (node.specifiers.length > 0) {
              reactPackageName = node.specifiers[0].local.name; // guard against accidental anonymous `import "react"`
            }
            if (node.specifiers.length >= 1) {
              propTypesSpecifier = node.specifiers.find(function(specifier) {
                return specifier.imported && specifier.imported.name === 'PropTypes';
              });
              if (propTypesSpecifier) {
                return propTypesPackageName = propTypesSpecifier.local.name;
              }
            }
          }
        },
        ClassProperty: function(node) {
          var propertyName, tokens;
          if (!node.static || !utils.isES6Component(node.parent.parent)) {
            return;
          }
          tokens = context.getFirstTokens(node, 2);
          propertyName = tokens[1].value;
          return reportErrorIfClassPropertyCasingTypo(node.value, propertyName);
        },
        MemberExpression: function(node) {
          var propertyName, relatedComponent;
          propertyName = node.property.name;
          if (!propertyName || STATIC_CLASS_PROPERTIES.map(function(prop) {
            return prop.toLocaleLowerCase();
          }).indexOf(propertyName.toLowerCase()) === -1) {
            return;
          }
          relatedComponent = utils.getRelatedComponent(node);
          if (relatedComponent && (utils.isES6Component(relatedComponent.node) || utils.isReturningJSX(relatedComponent.node)) && (node.parent && node.parent.type === 'AssignmentExpression' && node.parent.right)) {
            return reportErrorIfClassPropertyCasingTypo(node.parent.right, propertyName);
          }
        },
        MethodDefinition: function(node) {
          if (!utils.isES6Component(node.parent.parent)) {
            return;
          }
          return reportErrorIfLifecycleMethodCasingTypo(node);
        }
      };
    })
  };

}).call(this);
