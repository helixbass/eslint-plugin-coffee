// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Validates whitespace in and around the JSX opening and closing brackets
   * @author Diogo Franco (Kovensky)
   */
  'use strict';
  var docsUrl, getTokenBeforeClosingBracket, optionDefaults, validateBeforeClosing, validateBeforeSelfClosing;

  getTokenBeforeClosingBracket = require('eslint-plugin-react/lib/util/getTokenBeforeClosingBracket');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  // ------------------------------------------------------------------------------
  // Validators
  // ------------------------------------------------------------------------------
  validateBeforeSelfClosing = function(context, node, option) {
    var ALWAYS_MESSAGE, NEVER_MESSAGE, closingSlash, leftToken, sourceCode;
    sourceCode = context.getSourceCode();
    NEVER_MESSAGE = 'A space is forbidden before closing bracket';
    ALWAYS_MESSAGE = 'A space is required before closing bracket';
    leftToken = getTokenBeforeClosingBracket(node);
    closingSlash = sourceCode.getTokenAfter(leftToken);
    if (leftToken.loc.end.line !== closingSlash.loc.start.line) {
      return;
    }
    if (option === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
      return context.report({
        node,
        loc: closingSlash.loc.start,
        message: ALWAYS_MESSAGE,
        fix: function(fixer) {
          return fixer.insertTextBefore(closingSlash, ' ');
        }
      });
    } else if (option === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) {
      return context.report({
        node,
        loc: closingSlash.loc.start,
        message: NEVER_MESSAGE,
        fix: function(fixer) {
          var previousToken;
          previousToken = sourceCode.getTokenBefore(closingSlash);
          return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
        }
      });
    }
  };

  validateBeforeClosing = function(context, node, option) {
    var ALWAYS_MESSAGE, NEVER_MESSAGE, adjacent, closingToken, lastTokens, leftToken, sourceCode;
    // Don't enforce this rule for self closing tags
    if (!node.selfClosing) {
      sourceCode = context.getSourceCode();
      NEVER_MESSAGE = 'A space is forbidden before closing bracket';
      ALWAYS_MESSAGE = 'Whitespace is required before closing bracket';
      lastTokens = sourceCode.getLastTokens(node, 2);
      closingToken = lastTokens[1];
      leftToken = lastTokens[0];
      if (leftToken.loc.start.line !== closingToken.loc.start.line) {
        return;
      }
      adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);
      if (option === 'never' && !adjacent) {
        return context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: closingToken.loc.start
          },
          message: NEVER_MESSAGE,
          fix: function(fixer) {
            return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);
          }
        });
      } else if (option === 'always' && adjacent) {
        return context.report({
          node,
          loc: {
            start: leftToken.loc.end,
            end: closingToken.loc.start
          },
          message: ALWAYS_MESSAGE,
          fix: function(fixer) {
            return fixer.insertTextBefore(closingToken, ' ');
          }
        });
      }
    }
  };

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  optionDefaults = {
    beforeSelfClosing: 'always',
    beforeClosing: 'allow'
  };

  module.exports = {
    meta: {
      docs: {
        description: 'Validate whitespace in and around the JSX opening and closing brackets',
        category: 'Stylistic Issues',
        recommended: false,
        url: docsUrl('jsx-tag-spacing')
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            beforeSelfClosing: {
              enum: ['always',
        'never',
        'allow']
            },
            beforeClosing: {
              enum: ['always',
        'never',
        'allow']
            }
          },
          default: optionDefaults,
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      var options;
      options = {...optionDefaults, ...context.options[0]};
      return {
        JSXOpeningElement: function(node) {
          if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {
            validateBeforeSelfClosing(context, node, options.beforeSelfClosing);
          }
          if (options.beforeClosing !== 'allow') {
            return validateBeforeClosing(context, node, options.beforeClosing);
          }
        }
      };
    }
  };

  // JSXClosingElement: (node) ->
//   unless options.beforeClosing is 'allow'
//     validateBeforeClosing context, node, options.beforeClosing

}).call(this);
