// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to disallow empty functions.
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Gets the kind of a given function node.
   *
   * @param {ASTNode} node - A function node to get. This is one of
   *      an ArrowFunctionExpression, a FunctionDeclaration, or a
   *      FunctionExpression.
   * @returns {string} The kind of the function. This is one of "functions",
   *      "arrowFunctions", "generatorFunctions", "asyncFunctions", "methods",
   *      "generatorMethods", "asyncMethods", "getters", "setters", and
   *      "constructors".
   */
  var ALLOW_OPTIONS, astUtils, getKind;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  ALLOW_OPTIONS = Object.freeze([
    'functions',
    'methods',
    // 'getters'
    // 'setters'
    'constructors'
  ]);

  getKind = function(node) {
    var kind, parent, prefix;
    ({parent} = node);
    kind = '';
    // return 'arrowFunctions' if node.type is 'ArrowFunctionExpression'

    // Detects main kind.
    if (parent.type === 'Property') {
      if (parent.kind === 'get') {
        return 'getters';
      }
      if (parent.kind === 'set') {
        return 'setters';
      }
      kind = parent.method || parent.value.type === 'FunctionExpression' ? 'methods' : 'functions';
    } else if (parent.type === 'MethodDefinition') {
      if (parent.kind === 'get') {
        return 'getters';
      }
      if (parent.kind === 'set') {
        return 'setters';
      }
      if (parent.kind === 'constructor') {
        return 'constructors';
      }
      kind = 'methods';
    } else {
      kind = 'functions';
    }
    // Detects prefix.
    prefix = '';
    if (node.generator) {
      prefix = 'generator';
    } else if (node.async) {
      prefix = 'async';
    } else {
      return kind;
    }
    return prefix + kind[0].toUpperCase() + kind.slice(1);
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow empty functions',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-empty-function'
      },
      schema: [
        {
          type: 'object',
          properties: {
            allow: {
              type: 'array',
              items: {
                enum: ALLOW_OPTIONS
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: 'Unexpected empty {{name}}.'
      }
    },
    create: function(context) {
      /**
       * Reports a given function node if the node matches the following patterns.
       *
       * - Not allowed by options.
       * - The body is empty.
       * - The body doesn't have any comments.
       *
       * @param {ASTNode} node - A function node to report. This is one of
       *      an ArrowFunctionExpression, a FunctionDeclaration, or a
       *      FunctionExpression.
       * @returns {void}
       */
      var allowed, options, reportIfEmpty, sourceCode;
      options = context.options[0] || {};
      allowed = options.allow || [];
      sourceCode = context.getSourceCode();
      reportIfEmpty = function(node) {
        var comment, comments, i, innerComments, kind, len, name, nextToken;
        kind = getKind(node);
        name = astUtils.getFunctionNameWithKind(node);
        innerComments = sourceCode.getTokens(node.body, {
          includeComments: true,
          filter: astUtils.isCommentToken
        });
        if (node.body.loc.start.line === node.body.loc.end.line) {
          // Look for trailing comments that weren't included in body location data
          nextToken = sourceCode.getTokenAfter(node.body);
          if (!nextToken) {
            comments = sourceCode.getTokensAfter(node.body, {
              includeComments: true
            });
          } else if (sourceCode.commentsExistBetween(node.body, nextToken)) {
            comments = sourceCode.getTokensBetween(node.body, nextToken);
          }
          if (comments != null ? comments.length : void 0) {
            for (i = 0, len = comments.length; i < len; i++) {
              comment = comments[i];
              if (comment.loc.start.line !== node.body.loc.start.line) {
                break;
              }
              innerComments.push(comment);
            }
          }
        }
        if (allowed.indexOf(kind) === -1 && node.body.type === 'BlockStatement' && node.body.body.length === 0 && innerComments.length === 0) {
          return context.report({
            node,
            loc: node.body.loc.start,
            messageId: 'unexpected',
            data: {name}
          });
        }
      };
      return {
        ArrowFunctionExpression: reportIfEmpty,
        FunctionDeclaration: reportIfEmpty,
        FunctionExpression: reportIfEmpty
      };
    }
  };

}).call(this);
