// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Rule to define spacing before/after arrow function's arrow.
   * @author Jxck
   */
  'use strict';
  var isArrowToken,
    indexOf = [].indexOf;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  isArrowToken = function(token) {
    var ref;
    return (ref = token != null ? token.value : void 0) === '=>' || ref === '->';
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce consistent spacing before and after the arrow in arrow functions',
        category: 'ECMAScript 6',
        recommended: false,
        url: 'https://eslint.org/docs/rules/arrow-spacing'
      },
      fixable: 'whitespace',
      schema: [
        {
          type: 'object',
          properties: {
            before: {
              type: 'boolean'
            },
            after: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedBefore: 'Missing space before arrow.',
        unexpectedBefore: 'Unexpected space before arrow.',
        expectedAfter: 'Missing space after arrow.',
        unexpectedAfter: 'Unexpected space after arrow.'
      }
    },
    create: function(context) {
      /**
       * Count spaces before/after arrow(`=>`) token.
       * @param {Object} tokens Tokens before/after arrow.
       * @returns {Object} count of space before/after arrow.
       */
      /**
       * Get tokens of arrow(`=>`) and before/after arrow.
       * @param {ASTNode} node The arrow function node.
       * @returns {Object} Tokens of arrow and before/after arrow.
       */
      /**
       * Determines whether space(s) before after arrow(`=>`) is satisfy rule.
       * if before/after value is `true`, there should be space(s).
       * if before/after value is `false`, there should be no space.
       * @param {ASTNode} node The arrow function node.
       * @returns {void}
       */
      var countSpaces, getTokens, isIndented, option, rule, sourceCode, spaces;
      // merge rules with default
      rule = {
        before: true,
        after: true
      };
      option = context.options[0] || {};
      rule.before = option.before !== false;
      rule.after = option.after !== false;
      sourceCode = context.getSourceCode();
      getTokens = function(node) {
        var arrow;
        arrow = sourceCode.getTokenBefore(node.body, isArrowToken);
        return {
          before: sourceCode.getTokenBefore(arrow),
          arrow,
          after: sourceCode.getTokenAfter(arrow)
        };
      };
      isIndented = function(afterToken, arrowToken) {
        return indexOf.call(sourceCode.getText().slice(arrowToken.range[1], afterToken.range[0]), '\n') >= 0;
      };
      countSpaces = function(tokens) {
        var after, before, ref, ref1;
        before = ((ref = tokens.before) != null ? ref.value : void 0) === ')' ? tokens.arrow.range[0] - tokens.before.range[1] : 'ignore';
        after = (tokens.after && ((ref1 = tokens.after.value) !== '.' && ref1 !== ')' && ref1 !== ',') && !isIndented(tokens.after, tokens.arrow)) ? tokens.after.range[0] - tokens.arrow.range[1] : 'ignore';
        return {before, after};
      };
      spaces = function(node) {
        var countSpace, tokens;
        tokens = getTokens(node);
        countSpace = countSpaces(tokens);
        if (countSpace.before !== 'ignore') {
          if (rule.before) {
            // should be space(s) before arrow
            if (countSpace.before === 0) {
              context.report({
                node: tokens.before,
                messageId: 'expectedBefore',
                fix: function(fixer) {
                  return fixer.insertTextBefore(tokens.arrow, ' ');
                }
              });
            }
          // should be no space before arrow
          } else if (countSpace.before > 0) {
            context.report({
              node: tokens.before,
              messageId: 'unexpectedBefore',
              fix: function(fixer) {
                return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
              }
            });
          }
        }
        if (countSpace.after !== 'ignore') {
          if (rule.after) {
            // should be space(s) after arrow
            if (countSpace.after === 0) {
              return context.report({
                node: tokens.after,
                messageId: 'expectedAfter',
                fix: function(fixer) {
                  return fixer.insertTextAfter(tokens.arrow, ' ');
                }
              });
            }
          // should be no space after arrow
          } else if (countSpace.after > 0) {
            return context.report({
              node: tokens.after,
              messageId: 'unexpectedAfter',
              fix: function(fixer) {
                return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
              }
            });
          }
        }
      };
      return {
        FunctionExpression: spaces,
        ArrowFunctionExpression: spaces
      };
    }
  };

}).call(this);
