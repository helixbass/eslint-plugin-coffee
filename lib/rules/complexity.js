// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.
   * Counts the number of if, conditional, for, whilte, try, switch/case,
   * @author Patrick Brosset
   */
  'use strict';
  var astUtils, lodash;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  lodash = require('lodash');

  astUtils = require('../eslint-ast-utils');

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'enforce a maximum cyclomatic complexity allowed in a program',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/complexity'
      },
      schema: [
        {
          oneOf: [
            {
              type: 'integer',
              minimum: 0
            },
            {
              type: 'object',
              properties: {
                maximum: {
                  type: 'integer',
                  minimum: 0
                },
                max: {
                  type: 'integer',
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        complex: '{{name}} has a complexity of {{complexity}}.'
      }
    },
    create: function(context) {
      /**
       * Evaluate the node at the end of function
       * @param {ASTNode} node node to evaluate
       * @returns {void}
       * @private
       */
      /**
       * Increase the complexity of the function in context
       * @returns {void}
       * @private
       */
      /**
       * Increase the switch complexity in context
       * @param {ASTNode} node node to evaluate
       * @returns {void}
       * @private
       */
      /**
       * When parsing a new function, store it in our function stack
       * @returns {void}
       * @private
       */
      var THRESHOLD, endFunction, fns, increaseComplexity, increaseSwitchComplexity, option, startFunction;
      option = context.options[0];
      THRESHOLD = 20;
      if (typeof option === 'object' && Object.prototype.hasOwnProperty.call(option, 'maximum') && typeof option.maximum === 'number') {
        THRESHOLD = option.maximum;
      }
      if (typeof option === 'object' && Object.prototype.hasOwnProperty.call(option, 'max') && typeof option.max === 'number') {
        THRESHOLD = option.max;
      }
      if (typeof option === 'number') {
        THRESHOLD = option;
      }
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------

      // Using a stack to store complexity (handling nested functions)
      fns = [];
      startFunction = function() {
        return fns.push(1);
      };
      endFunction = function(node) {
        var complexity, name;
        name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
        complexity = fns.pop();
        if (complexity > THRESHOLD) {
          return context.report({
            node,
            messageId: 'complex',
            data: {name, complexity}
          });
        }
      };
      increaseComplexity = function() {
        if (fns.length) {
          return fns[fns.length - 1]++;
        }
      };
      increaseSwitchComplexity = function(node) {
        // Avoiding `default`
        if (node.test) {
          return increaseComplexity();
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        'FunctionDeclaration:exit': endFunction,
        'FunctionExpression:exit': endFunction,
        'ArrowFunctionExpression:exit': endFunction,
        CatchClause: increaseComplexity,
        ConditionalExpression: increaseComplexity,
        LogicalExpression: increaseComplexity,
        ForStatement: increaseComplexity,
        ForInStatement: increaseComplexity,
        ForOfStatement: increaseComplexity,
        For: increaseComplexity,
        IfStatement: increaseComplexity,
        SwitchCase: increaseSwitchComplexity,
        WhileStatement: increaseComplexity,
        DoWhileStatement: increaseComplexity
      };
    }
  };

}).call(this);
