// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prefer destructuring from arrays and objects
   * @author Alex LaFroscia
   */
  'use strict';
  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'require destructuring from arrays and/or objects',
        category: 'ECMAScript 6',
        recommended: false,
        url: 'https://eslint.org/docs/rules/prefer-destructuring'
      },
      schema: [
        {
          /*
           * old support {array: Boolean, object: Boolean}
           * new support {VariableDeclarator: {}, AssignmentExpression: {}}
           */
          type: 'object',
          properties: {
            array: {
              type: 'boolean'
            },
            object: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        },
        {
          type: 'object',
          properties: {
            enforceForRenamedProperties: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Run the `prefer-destructuring` check on an AssignmentExpression
       *
       * @param {ASTNode} node the AssignmentExpression node
       * @returns {void}
       */
      /**
       * Determines if the given node is accessing an array index
       *
       * This is used to differentiate array index access from object property
       * access.
       *
       * @param {ASTNode} node the node to evaluate
       * @returns {boolean} whether or not the node is an integer
       */
      /**
       * Check that the `prefer-destructuring` rules are followed based on the
       * given left- and right-hand side of the assignment.
       *
       * Pulled out into a separate method so that VariableDeclarators and
       * AssignmentExpressions can share the same verification logic.
       *
       * @param {ASTNode} leftNode the left-hand side of the assignment
       * @param {ASTNode} rightNode the right-hand side of the assignment
       * @param {ASTNode} reportNode the node to report the error on
       * @returns {void}
       */
      /**
       * Report that the given node should use destructuring
       *
       * @param {ASTNode} reportNode the node to report
       * @param {string} type the type of destructuring that should have been done
       * @returns {void}
       */
      var checkAssigmentExpression, enabledTypes, enforceForRenamedProperties, isArrayIndexAccess, performCheck, ref, ref1, report, shouldCheck;
      enabledTypes = (ref = context.options[0]) != null ? ref : {
        array: true,
        object: true
      };
      enforceForRenamedProperties = (ref1 = context.options[1]) != null ? ref1.enforceForRenamedProperties : void 0;
      //--------------------------------------------------------------------------
      // Helpers
      //--------------------------------------------------------------------------
      /**
       * @param {string} nodeType "AssignmentExpression" or "VariableDeclarator"
       * @param {string} destructuringType "array" or "object"
       * @returns {boolean} `true` if the destructuring type should be checked for the given node
       */
      shouldCheck = function(destructuringType) {
        return enabledTypes[destructuringType];
      };
      isArrayIndexAccess = function(node) {
        return Number.isInteger(node.property.value);
      };
      report = function(reportNode, type) {
        return context.report({
          node: reportNode,
          message: 'Use {{type}} destructuring.',
          data: {type}
        });
      };
      performCheck = function(leftNode, rightNode, reportNode) {
        var property;
        if (rightNode.type !== 'MemberExpression' || rightNode.object.type === 'Super' || rightNode.optional) {
          return;
        }
        if (isArrayIndexAccess(rightNode)) {
          if (shouldCheck('array')) {
            report(reportNode, 'array');
          }
          return;
        }
        if (!shouldCheck('object')) {
          return;
        }
        if (enforceForRenamedProperties) {
          report(reportNode, 'object');
          return;
        }
        ({property} = rightNode);
        if ((property.type === 'Literal' && leftNode.name === property.value) || (property.type === 'Identifier' && leftNode.name === property.name && !rightNode.computed)) {
          return report(reportNode, 'object');
        }
      };
      checkAssigmentExpression = function(node) {
        if (node.operator === '=') {
          return performCheck(node.left, node.right, node);
        }
      };
      return {
        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------
        AssignmentExpression: checkAssigmentExpression
      };
    }
  };

}).call(this);
