// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Checks whether or not a given function node is the default `this` binding.
   *
   * First, this checks the node:
   *
   * - The function name does not start with uppercase (it's a constructor).
   * - The function does not have a JSDoc comment that has a @this tag.
   *
   * Next, this checks the location of the node.
   * If the location is below, this judges `this` is valid.
   *
   * - The location is not on an object literal.
   * - The location is not assigned to a variable which starts with an uppercase letter.
   * - The location is not on an ES2015 class.
   * - Its `bind`/`call`/`apply` method is not called directly.
   * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
   *
   * @param {ASTNode} node - A function node to check.
   * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
   * @returns {boolean} The function node is the default `this` binding.
   */
  var arrayMethodPattern, bindOrCallOrApplyPattern, getUpperFunction, hasJSDocThisTag, isArrayFromMethod, isBoundMethod, isCallee, isDefaultThisBinding, isDestructuredAssignmentKey, isES5Constructor, isFatArrowFunction, isMethodWhichHasThisArg, isNullLiteral, isNullOrUndefined, isReflectApply, startsWithUpperCase, thisTagPattern;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  ({getUpperFunction, isNullLiteral, isArrayFromMethod, isES5Constructor} = require('../eslint-ast-utils'));

  // getFunctionName
  ({isFatArrowFunction, isBoundMethod} = require('../util/ast-utils'));

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  startsWithUpperCase = function(s) {
    return s && s[0] !== s[0].toLocaleLowerCase();
  };

  bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;

  arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;

  thisTagPattern = /^[\s*#]*@this/m;

  // isES5Constructor = (node) ->
  //   startsWithUpperCase getFunctionName node
  isCallee = function(node) {
    if (node.parent.type === 'CallExpression' && node.parent.callee === node) {
      return true;
    }
    if (node.parent.type === 'UnaryExpression' && node.parent.operator === 'do') {
      return true;
    }
    return false;
  };

  hasJSDocThisTag = function(node, sourceCode) {
    var jsdocComment;
    jsdocComment = sourceCode.getJSDocComment(node);
    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
      return true;
    }
    return sourceCode.getCommentsBefore(node).some(function(comment) {
      return thisTagPattern.test(comment.value);
    });
  };

  isNullOrUndefined = function(node) {
    return isNullLiteral(node) || (node.type === 'Identifier' && node.name === 'undefined') || (node.type === 'UnaryExpression' && node.operator === 'void');
  };

  isReflectApply = function(node) {
    return node.type === 'MemberExpression' && node.object.type === 'Identifier' && node.object.name === 'Reflect' && node.property.type === 'Identifier' && node.property.name === 'apply' && !node.computed;
  };

  isMethodWhichHasThisArg = function(node) {
    var currentNode;
    currentNode = node;
    while (currentNode.type === 'MemberExpression' && !currentNode.computed) {
      if (currentNode.property.type === 'Identifier') {
        return arrayMethodPattern.test(currentNode.property.name);
      }
      currentNode = currentNode.property;
    }
    return false;
  };

  isDefaultThisBinding = function(node, sourceCode) {
    var currentNode, func, isAnonymous, parent;
    if (/Class/.test(node.type)) {
      return false;
    }
    if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
      return false;
    }
    isAnonymous = node.id === null;
    currentNode = node;
    while (currentNode) {
      ({parent} = currentNode);
      if (currentNode.returns) {
        func = getUpperFunction(parent);
        if (func === null || !isCallee(func)) {
          return true;
        }
        currentNode = func.parent;
        continue;
      }
      switch (parent.type) {
        /*
         * Looks up the destination.
         * e.g., obj.foo = nativeFoo || function foo() { ... };
         */
        case 'LogicalExpression':
        case 'ConditionalExpression':
          currentNode = parent;
          break;
        /*
         * If the upper function is IIFE, checks the destination of the return value.
         * e.g.
         *   obj.foo = (function() {
         *     // setup...
         *     return function foo() { ... };
         *   })();
         *   obj.foo = (() =>
         *     function foo() { ... }
         *   )();
         */
        case 'ReturnStatement':
          func = getUpperFunction(parent);
          if (func === null || !isCallee(func)) {
            return true;
          }
          currentNode = func.parent;
          break;
        case 'FunctionExpression':
          if (!parent.bound) {
            return true;
          }
          if (!(currentNode === parent.body && isCallee(parent))) {
            return true;
          }
          currentNode = parent.parent;
          break;
        /*
         * e.g.
         *   var obj = { foo() { ... } };
         *   var obj = { foo: function() { ... } };
         *   class A { constructor() { ... } }
         *   class A { foo() { ... } }
         *   class A { get foo() { ... } }
         *   class A { set foo() { ... } }
         *   class A { static foo() { ... } }
         */
        case 'Property':
        case 'MethodDefinition':
          return parent.value !== currentNode;
        /*
         * e.g.
         *   obj.foo = function foo() { ... };
         *   Foo = function() { ... };
         *   [obj.foo = function foo() { ... }] = a;
         *   [Foo = function() { ... }] = a;
         */
        case 'AssignmentExpression':
        case 'AssignmentPattern':
          if (parent.left.type === 'MemberExpression') {
            return false;
          }
          if (isAnonymous && parent.left.type === 'Identifier' && startsWithUpperCase(parent.left.name)) {
            return false;
          }
          return true;
        /*
         * e.g.
         *   var Foo = function() { ... };
         */
        case 'VariableDeclarator':
          return !(isAnonymous && parent.init === currentNode && parent.id.type === 'Identifier' && startsWithUpperCase(parent.id.name));
        /*
         * e.g.
         *   var foo = function foo() { ... }.bind(obj);
         *   (function foo() { ... }).call(obj);
         *   (function foo() { ... }).apply(obj, []);
         */
        case 'MemberExpression':
          return parent.object !== currentNode || parent.property.type !== 'Identifier' || !bindOrCallOrApplyPattern.test(parent.property.name) || !isCallee(parent) || parent.parent.arguments.length === 0 || isNullOrUndefined(parent.parent.arguments[0]);
        /*
         * e.g.
         *   Reflect.apply(function() {}, obj, []);
         *   Array.from([], function() {}, obj);
         *   list.forEach(function() {}, obj);
         */
        case 'CallExpression':
          if (isReflectApply(parent.callee)) {
            return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
          }
          if (isArrayFromMethod(parent.callee)) {
            return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
          }
          if (isMethodWhichHasThisArg(parent.callee)) {
            return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
          }
          return true;
        default:
          // Otherwise `this` is default.
          return true;
      }
    }
    return true;
  };

  isDestructuredAssignmentKey = function({parent}) {
    if (parent.type !== 'MemberExpression') {
      return false;
    }
    if (!(parent.parent.type === 'Property' && parent.parent.shorthand && parent.parent.parent.type === 'ObjectPattern' && parent === parent.parent.key)) {
      return false;
    }
    return true;
  };

  //------------------------------------------------------------------------------
  // Rule Definition
  //------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'disallow `this` keywords outside of classes or class-like objects',
        category: 'Best Practices',
        recommended: false,
        url: 'https://eslint.org/docs/rules/no-invalid-this'
      },
      schema: [
        {
          type: 'object',
          properties: {
            fatArrowsOk: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: function(context) {
      /**
       * Pushs new checking context into the stack.
       *
       * The checking context is not initialized yet.
       * Because most functions don't have `this` keyword.
       * When `this` keyword was found, the checking context is initialized.
       *
       * @param {ASTNode} node - A function node that was entered.
       * @returns {void}
       */
      /**
       * Pops the current checking context from the stack.
       * @returns {void}
       */
      var enterClass, enterFunction, exitClass, exitFunction, fatArrowsOk, ref, sourceCode, stack;
      stack = [];
      sourceCode = context.getSourceCode();
      ({fatArrowsOk} = (ref = context.options[0]) != null ? ref : {});
      /**
       * Gets the current checking context.
       *
       * The return value has a flag that whether or not `this` keyword is valid.
       * The flag is initialized when got at the first time.
       *
       * @returns {{valid: boolean}}
       *   an object which has a flag that whether or not `this` keyword is valid.
       */
      stack.getCurrent = function() {
        var current;
        current = this[this.length - 1];
        if (!current.init) {
          current.init = true;
          current.valid = fatArrowsOk && isFatArrowFunction(current.node) ? true : !isDefaultThisBinding(current.node, sourceCode);
        }
        return current;
      };
      enterFunction = function(node) {
        if (isFatArrowFunction(node) && !isBoundMethod(node) && !fatArrowsOk) {
          return;
        }
        // `this` can be invalid only under strict mode.
        return stack.push({
          init: !context.getScope().isStrict,
          node,
          valid: true
        });
      };
      enterClass = function(node) {
        return stack.push({
          init: !context.getScope().isStrict,
          node,
          valid: true
        });
      };
      exitFunction = function(node) {
        if (isFatArrowFunction(node)) {
          return;
        }
        return stack.pop();
      };
      exitClass = function() {
        return stack.pop();
      };
      return {
        /*
         * `this` is invalid only under strict mode.
         * Modules is always strict mode.
         */
        Program: function(node) {
          var features, scope;
          scope = context.getScope();
          features = context.parserOptions.ecmaFeatures || {};
          return stack.push({
            init: true,
            node,
            valid: !(scope.isStrict || node.sourceType === 'module' || (features.globalReturn && scope.childScopes[0].isStrict))
          });
        },
        'Program:exit': function() {
          return stack.pop();
        },
        FunctionDeclaration: enterFunction,
        'FunctionDeclaration:exit': exitFunction,
        FunctionExpression: enterFunction,
        'FunctionExpression:exit': exitFunction,
        ArrowFunctionExpression: enterFunction,
        'ArrowFunctionExpression:exit': exitFunction,
        ClassDeclaration: enterClass,
        'ClassDeclaration:exit': exitClass,
        ClassExpression: enterClass,
        'ClassExpression:exit': exitClass,
        // Reports if `this` of the current context is invalid.
        ThisExpression: function(node) {
          var current;
          // TODO: can't distinguish shorthand key from value eg in ({@a}) ->?
          // So it's currently double-triggering.
          // return if isDestructuredAssignmentKey node
          current = stack.getCurrent();
          if (current && !current.valid) {
            return context.report({
              node,
              message: "Unexpected 'this'."
            });
          }
        }
      };
    }
  };

}).call(this);
