// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileOverview Enforce a defaultProps definition for every prop that is not a required prop.
   * @author Vitor Balocco
   */
  'use strict';
  var Components, QUOTES_REGEX, annotations, astUtil, docsUrl, propsUtil, variableUtil,
    hasProp = {}.hasOwnProperty;

  Components = require('../util/react/Components');

  variableUtil = require('../util/react/variable');

  annotations = require('eslint-plugin-react/lib/util/annotations');

  astUtil = require('../util/react/ast');

  propsUtil = require('../util/react/props');

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  QUOTES_REGEX = /^["']|["']$/g;

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Enforce a defaultProps definition for every prop that is not a required prop.',
        category: 'Best Practices',
        url: docsUrl('require-default-props')
      },
      schema: [
        {
          type: 'object',
          properties: {
            forbidDefaultForRequired: {
              type: 'boolean'
            }
          },
          additionalProperties: false
        }
      ]
    },
    create: Components.detect(function(context, components, utils) {
      /**
       * Adds defaultProps to the component passed in.
       * @param   {ASTNode}         component    The component to add the defaultProps to.
       * @param   {String[]|String} defaultProps defaultProps to add to the component or the string "unresolved"
       *                                         if this component has defaultProps that can't be resolved.
       * @returns {void}
       */
      /**
       * Adds propTypes to the component passed in.
       * @param   {ASTNode}  component The component to add the propTypes to.
       * @param   {Object[]} propTypes propTypes to add to the component.
       * @returns {void}
       */
      /**
       * Extracts a DefaultProp from an ObjectExpression node.
       * @param   {ASTNode} objectExpression ObjectExpression node.
       * @returns {Object|string}            Object representation of a defaultProp, to be consumed by
       *                                     `addDefaultPropsToComponent`, or string "unresolved", if the defaultProps
       *                                     from this ObjectExpression can't be resolved.
       */
      /**
       * Extracts a PropType from a TypeAnnotation contained in generic node.
       * @param   {ASTNode} node TypeAnnotation node.
       * @returns {Object[]}     Array of PropType object representations, to be consumed by `addPropTypesToComponent`.
       */
      /**
       * Extracts a PropType from an ObjectExpression node.
       * @param   {ASTNode} objectExpression ObjectExpression node.
       * @returns {Object[]}        Array of PropType object representations, to be consumed by `addPropTypesToComponent`.
       */
      /**
       * Extracts a PropType from a TypeAnnotation node.
       * @param   {ASTNode} node TypeAnnotation node.
       * @returns {Object[]}     Array of PropType object representations, to be consumed by `addPropTypesToComponent`.
       */
      /**
       * Tries to find a props type annotation in a stateless component.
       * @param  {ASTNode} node The AST node to look for a props type annotation.
       * @return {void}
       */
      /**
       * Marks a component's DefaultProps declaration as "unresolved". A component's DefaultProps is
       * marked as "unresolved" if we cannot safely infer the values of its defaultProps declarations
       * without risking false negatives.
       * @param   {Object} component The component to mark.
       * @returns {void}
       */
      /**
       * Reports all propTypes passed in that don't have a defaultProp counterpart.
       * @param  {Object[]} propTypes    List of propTypes to check.
       * @param  {Object}   defaultProps Object of defaultProps to check. Keys are the props names.
       * @return {void}
       */
      /**
       * Tries to find the definition of a GenericTypeAnnotation in the current scope.
       * @param  {ASTNode}      node The node GenericTypeAnnotation node to resolve.
       * @return {ASTNode|null}      Return null if definition cannot be found, ASTNode otherwise.
       */
      /**
       * Try to resolve the node passed in to a variable in the current scope. If the node passed in is not
       * an Identifier, then the node is simply returned.
       * @param   {ASTNode} node The node to resolve.
       * @returns {ASTNode|null} Return null if the value could not be resolved, ASTNode otherwise.
       */
      /**
       * Helper for accessing the current scope in the stack.
       * @param {string} key The name of the identifier to access. If omitted, returns the full scope.
       * @param {ASTNode} value If provided sets the new value for the identifier.
       * @returns {Object|ASTNode} Either the whole scope or the ASTNode associated with the given identifier.
       */
      var addDefaultPropsToComponent, addPropTypesToComponent, configuration, forbidDefaultForRequired, getDefaultPropsFromObjectExpression, getPropTypesFromGeneric, getPropTypesFromObjectExpression, getPropTypesFromTypeAnnotation, handlePropTypeAnnotationClassProperty, handlePropTypesAsGeneric, handleStatelessComponent, hasPropTypesAsGeneric, isPropTypeAnnotation, markDefaultPropsAsUnresolved, propWrapperFunctions, reportPropTypesWithoutDefault, resolveGenericTypeAnnotation, resolveNodeValue, resolveUnionTypeAnnotation, sourceCode, stack, typeScope;
      sourceCode = context.getSourceCode();
      propWrapperFunctions = new Set(context.settings.propWrapperFunctions || []);
      configuration = context.options[0] || {};
      forbidDefaultForRequired = configuration.forbidDefaultForRequired || false;
      // Used to track the type annotations in scope.
      // Necessary because babel's scopes do not track type annotations.
      stack = null;
      resolveNodeValue = function(node) {
        var ref;
        if (node.type === 'Identifier') {
          return variableUtil.findVariableByName(context, node.name);
        }
        if (node.type === 'CallExpression' && propWrapperFunctions.has(node.callee.name) && ((ref = node.arguments) != null ? ref[0] : void 0)) {
          return resolveNodeValue(node.arguments[0]);
        }
        return node;
      };
      typeScope = function(key, value) {
        if (arguments.length === 0) {
          return stack[stack.length - 1];
        }
        if (arguments.length === 1) {
          return stack[stack.length - 1][key];
        }
        stack[stack.length - 1][key] = value;
        return value;
      };
      resolveGenericTypeAnnotation = function(node) {
        if (node.type !== 'GenericTypeAnnotation' || node.id.type !== 'Identifier') {
          return null;
        }
        return variableUtil.findVariableByName(context, node.id.name) || typeScope(node.id.name);
      };
      resolveUnionTypeAnnotation = function(node) {
        // Go through all the union and resolve any generic types.
        return node.types.map(function(annotation) {
          if (annotation.type === 'GenericTypeAnnotation') {
            return resolveGenericTypeAnnotation(annotation);
          }
          return annotation;
        });
      };
      getPropTypesFromObjectExpression = function(objectExpression) {
        var props;
        props = objectExpression.properties.filter(function(property) {
          return property.type !== 'ExperimentalSpreadProperty' && property.type !== 'SpreadElement';
        });
        return props.map(function(property) {
          return {
            name: sourceCode.getText(property.key).replace(QUOTES_REGEX, ''),
            isRequired: propsUtil.isRequiredPropType(property.value),
            node: property
          };
        });
      };
      getPropTypesFromTypeAnnotation = function(node) {
        var annotation, properties, props, union;
        switch (node.typeAnnotation.type) {
          case 'GenericTypeAnnotation':
            annotation = resolveGenericTypeAnnotation(node.typeAnnotation);
            if (annotation != null ? annotation.id : void 0) {
              annotation = variableUtil.findVariableByName(context, annotation.id.name);
            }
            properties = annotation ? annotation.properties || [] : [];
            break;
          case 'UnionTypeAnnotation':
            union = resolveUnionTypeAnnotation(node.typeAnnotation);
            properties = union.reduce(function(acc, curr) {
              if (!curr) {
                return acc;
              }
              return acc.concat(curr.properties);
            }, []);
            break;
          case 'ObjectTypeAnnotation':
            ({properties} = node.typeAnnotation);
            break;
          default:
            properties = [];
        }
        props = properties.filter(function(property) {
          return property.type === 'ObjectTypeProperty';
        });
        return props.map(function(property) {
          var name, tokens;
          // the `key` property is not present in ObjectTypeProperty nodes, so we need to get the key name manually.
          tokens = context.getFirstTokens(property, 1);
          name = tokens[0].value;
          return {
            name,
            isRequired: !property.optional,
            node: property
          };
        });
      };
      getDefaultPropsFromObjectExpression = function(objectExpression) {
        var hasSpread;
        hasSpread = objectExpression.properties.find(function(property) {
          var ref;
          return (ref = property.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement';
        });
        if (hasSpread) {
          return 'unresolved';
        }
        return objectExpression.properties.map(function(property) {
          return sourceCode.getText(property.key).replace(QUOTES_REGEX, '');
        });
      };
      markDefaultPropsAsUnresolved = function(component) {
        return components.set(component.node, {
          defaultProps: 'unresolved'
        });
      };
      addPropTypesToComponent = function(component, propTypes) {
        var props;
        props = component.propTypes || [];
        return components.set(component.node, {
          propTypes: props.concat(propTypes)
        });
      };
      addDefaultPropsToComponent = function(component, defaultProps) {
        var defaults;
        // Early return if this component's defaultProps is already marked as "unresolved".
        if (component.defaultProps === 'unresolved') {
          return;
        }
        if (defaultProps === 'unresolved') {
          markDefaultPropsAsUnresolved(component);
          return;
        }
        defaults = component.defaultProps || {};
        defaultProps.forEach(function(defaultProp) {
          return defaults[defaultProp] = true;
        });
        return components.set(component.node, {
          defaultProps: defaults
        });
      };
      handleStatelessComponent = function(node) {
        var component;
        if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) {
          return;
        }
        // find component this props annotation belongs to
        component = components.get(utils.getParentStatelessComponent());
        if (!component) {
          return;
        }
        return addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.params[0].typeAnnotation, context));
      };
      handlePropTypeAnnotationClassProperty = function(node) {
        var component;
        // find component this props annotation belongs to
        component = components.get(utils.getParentES6Component());
        if (!component) {
          return;
        }
        return addPropTypesToComponent(component, getPropTypesFromTypeAnnotation(node.typeAnnotation, context));
      };
      isPropTypeAnnotation = function(node) {
        return astUtil.getPropertyName(node) === 'props' && !!node.typeAnnotation;
      };
      reportPropTypesWithoutDefault = function(propTypes, defaultProps) {
        // If this defaultProps is "unresolved", then we should ignore this component and not report
        // any errors for it, to avoid false-positives with e.g. external defaultProps declarations or spread operators.
        if (defaultProps === 'unresolved') {
          return;
        }
        return propTypes.forEach(function(prop) {
          if (prop.isRequired) {
            if (forbidDefaultForRequired && defaultProps[prop.name]) {
              context.report(prop.node, 'propType "{{name}}" is required and should not have a defaultProp declaration.', {
                name: prop.name
              });
            }
            return;
          }
          if (defaultProps[prop.name]) {
            return;
          }
          return context.report(prop.node, 'propType "{{name}}" is not required, but has no corresponding defaultProp declaration.', {
            name: prop.name
          });
        });
      };
      getPropTypesFromGeneric = function(node) {
        var annotation, properties, props;
        annotation = resolveGenericTypeAnnotation(node);
        if (annotation != null ? annotation.id : void 0) {
          annotation = variableUtil.findVariableByName(context, annotation.id.name);
        }
        properties = annotation ? annotation.properties || [] : [];
        props = properties.filter(function(property) {
          return property.type === 'ObjectTypeProperty';
        });
        return props.map(function(property) {
          var name, tokens;
          // the `key` property is not present in ObjectTypeProperty nodes, so we need to get the key name manually.
          tokens = context.getFirstTokens(property, 1);
          name = tokens[0].value;
          return {
            name,
            isRequired: !property.optional,
            node: property
          };
        });
      };
      hasPropTypesAsGeneric = function(node) {
        return (node != null ? node.parent : void 0) && node.parent.type === 'ClassDeclaration';
      };
      handlePropTypesAsGeneric = function(node) {
        var component;
        component = components.get(utils.getParentES6Component());
        if (!component) {
          return;
        }
        if (node.params[0]) {
          return addPropTypesToComponent(component, getPropTypesFromGeneric(node.params[0], context));
        }
      };
      return {
        // --------------------------------------------------------------------------
        // Public API
        // --------------------------------------------------------------------------
        MemberExpression: function(node) {
          var component, expression, isDefaultProp, isPropType;
          isPropType = propsUtil.isPropTypesDeclaration(node);
          isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = utils.getRelatedComponent(node);
          if (!component) {
            return;
          }
          // e.g.:
          // MyComponent.propTypes = {
          //   foo: PropTypes.string.isRequired,
          //   bar: PropTypes.string
          // };

          // or:

          // MyComponent.propTypes = myPropTypes;
          if (node.parent.type === 'AssignmentExpression') {
            expression = resolveNodeValue(node.parent.right);
            if (!expression || expression.type !== 'ObjectExpression') {
              // If a value can't be found, we mark the defaultProps declaration as "unresolved", because
              // we should ignore this component and not report any errors for it, to avoid false-positives
              // with e.g. external defaultProps declarations.
              if (isDefaultProp) {
                markDefaultPropsAsUnresolved(component);
              }
              return;
            }
            if (isPropType) {
              addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
            } else {
              addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
            }
            return;
          }
          // e.g.:
          // MyComponent.propTypes.baz = PropTypes.string;
          if (node.parent.type === 'MemberExpression' && node.parent.parent.type === 'AssignmentExpression') {
            if (isPropType) {
              return addPropTypesToComponent(component, [
                {
                  name: node.parent.property.name,
                  isRequired: propsUtil.isRequiredPropType(node.parent.parent.right),
                  node: node.parent.parent
                }
              ]);
            } else {
              return addDefaultPropsToComponent(component, [node.parent.property.name]);
            }
          }
        },
        // e.g.:
        // class Hello extends React.Component {
        //   static get propTypes() {
        //     return {
        //       name: PropTypes.string
        //     };
        //   }
        //   static get defaultProps() {
        //     return {
        //       name: 'Dean'
        //     };
        //   }
        //   render() {
        //     return <div>Hello {this.props.name}</div>;
        //   }
        // }
        MethodDefinition: function(node) {
          var component, expression, isDefaultProp, isPropType, returnStatement;
          if (!node.static || node.kind !== 'get') {
            return;
          }
          isPropType = propsUtil.isPropTypesDeclaration(node);
          isDefaultProp = propsUtil.isDefaultPropsDeclaration(node);
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = components.get(utils.getParentES6Component());
          if (!component) {
            return;
          }
          returnStatement = utils.findReturnStatement(node);
          if (!returnStatement.expression) {
            return;
          }
          expression = resolveNodeValue(returnStatement.expression);
          if (!expression || expression.type !== 'ObjectExpression') {
            return;
          }
          if (isPropType) {
            return addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
          } else {
            return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
          }
        },
        // e.g.:
        // class Greeting extends React.Component {
        //   render() {
        //     return (
        //       <h1>Hello, {this.props.foo} {this.props.bar}</h1>
        //     );
        //   }
        //   static propTypes = {
        //     foo: PropTypes.string,
        //     bar: PropTypes.string.isRequired
        //   };
        // }
        ClassProperty: function(node) {
          var component, expression, isDefaultProp, isPropType;
          if (isPropTypeAnnotation(node)) {
            handlePropTypeAnnotationClassProperty(node);
            return;
          }
          if (!node.static) {
            return;
          }
          if (!node.value) {
            return;
          }
          isPropType = astUtil.getPropertyName(node) === 'propTypes';
          isDefaultProp = astUtil.getPropertyName(node) === 'defaultProps' || astUtil.getPropertyName(node) === 'getDefaultProps';
          if (!isPropType && !isDefaultProp) {
            return;
          }
          // find component this propTypes/defaultProps belongs to
          component = components.get(utils.getParentES6Component());
          if (!component) {
            return;
          }
          expression = resolveNodeValue(node.value);
          if (!expression || expression.type !== 'ObjectExpression') {
            return;
          }
          if (isPropType) {
            return addPropTypesToComponent(component, getPropTypesFromObjectExpression(expression));
          } else {
            return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(expression));
          }
        },
        // e.g.:
        // createReactClass({
        //   render: function() {
        //     return <div>{this.props.foo}</div>;
        //   },
        //   propTypes: {
        //     foo: PropTypes.string.isRequired,
        //   },
        //   getDefaultProps: function() {
        //     return {
        //       foo: 'default'
        //     };
        //   }
        // });
        ObjectExpression: function(node) {
          var component;
          // find component this propTypes/defaultProps belongs to
          component = utils.isES5Component(node) && components.get(node);
          if (!component) {
            return;
          }
          // Search for the proptypes declaration
          return node.properties.forEach(function(property) {
            var isDefaultProp, isPropType, ref, ref1, returnStatement;
            if ((ref = property.type) === 'ExperimentalSpreadProperty' || ref === 'SpreadElement') {
              return;
            }
            isPropType = propsUtil.isPropTypesDeclaration(property);
            isDefaultProp = propsUtil.isDefaultPropsDeclaration(property);
            if (!isPropType && !isDefaultProp) {
              return;
            }
            if (isPropType && property.value.type === 'ObjectExpression') {
              addPropTypesToComponent(component, getPropTypesFromObjectExpression(property.value));
              return;
            }
            if (isDefaultProp && property.value.type === 'FunctionExpression') {
              returnStatement = utils.findReturnStatement(property);
              if (((ref1 = returnStatement.expression) != null ? ref1.type : void 0) !== 'ObjectExpression') {
                return;
              }
              return addDefaultPropsToComponent(component, getDefaultPropsFromObjectExpression(returnStatement.expression));
            }
          });
        },
        TypeAlias: function(node) {
          return typeScope(node.id.name, node.right);
        },
        Program: function() {
          return stack = [{}];
        },
        BlockStatement: function() {
          return stack.push(Object.create(typeScope()));
        },
        'BlockStatement:exit': function() {
          return stack.pop();
        },
        // e.g.:
        // type HelloProps = {
        //   foo?: string
        // };
        // class Hello extends React.Component<HelloProps> {
        //   static defaultProps = {
        //     foo: 'default'
        //   }
        //   render() {
        //     return <div>{this.props.foo}</div>;
        //   }
        // };
        TypeParameterInstantiation: function(node) {
          if (hasPropTypesAsGeneric(node)) {
            return handlePropTypesAsGeneric(node);
          }
        },
        // Check for type annotations in stateless components
        FunctionDeclaration: handleStatelessComponent,
        ArrowFunctionExpression: handleStatelessComponent,
        FunctionExpression: handleStatelessComponent,
        'Program:exit': function() {
          var _, component, ref, results;
          stack = null;
          ref = components.list();
          results = [];
          for (_ in ref) {
            if (!hasProp.call(ref, _)) continue;
            component = ref[_];
            if (component.propTypes) {
              // If no propTypes could be found, we don't report anything.
              results.push(reportPropTypesWithoutDefault(component.propTypes, component.defaultProps || {}));
            }
          }
          return results;
        }
      };
    })
  };

}).call(this);
