// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview Prevent usage of this.state within setState
   * @author Rolf Erik Lekang, JÃ¸rgen Aaberg
   */
  'use strict';
  var docsUrl, isDeclarationAssignment;

  docsUrl = require('eslint-plugin-react/lib/util/docsUrl');

  ({isDeclarationAssignment} = require('../util/ast-utils'));

  // ------------------------------------------------------------------------------
  // Rule Definition
  // ------------------------------------------------------------------------------
  module.exports = {
    meta: {
      docs: {
        description: 'Reports when this.state is accessed within setState',
        category: 'Possible Errors',
        recommended: false,
        url: docsUrl('no-access-state-in-setstate')
      }
    },
    create: function(context) {
      var isFirstArgumentInSetStateCall, isSetStateCall, methods, vars;
      isSetStateCall = function(node) {
        return node.type === 'CallExpression' && node.callee.property && node.callee.property.name === 'setState' && node.callee.object.type === 'ThisExpression';
      };
      isFirstArgumentInSetStateCall = function(current, node) {
        if (!isSetStateCall(current)) {
          return false;
        }
        while (node && node.parent !== current) {
          node = node.parent;
        }
        return current.arguments[0] === node;
      };
      // The methods array contains all methods or functions that are using this.state
      // or that are calling another method or function using this.state
      methods = [];
      // The vars array contains all variables that contains this.state
      vars = [];
      return {
        CallExpression: function(node) {
          var current, i, len, method, methodName, results;
          // Appends all the methods that are calling another
          // method containing this.state to the methods array
          methods.map(function(method) {
            var current, results;
            if (node.callee.name === method.methodName) {
              current = node.parent;
              results = [];
              while (current.type !== 'Program') {
                if (current.type === 'MethodDefinition') {
                  methods.push({
                    methodName: current.key.name,
                    node: method.node
                  });
                  break;
                }
                results.push(current = current.parent);
              }
              return results;
            }
          });
          // Finding all CallExpressions that is inside a setState
          // to further check if they contains this.state
          current = node.parent;
          results = [];
          while (current.type !== 'Program') {
            if (isFirstArgumentInSetStateCall(current, node)) {
              methodName = node.callee.name;
              for (i = 0, len = methods.length; i < len; i++) {
                method = methods[i];
                if (method.methodName === methodName) {
                  context.report(method.node, 'Use callback in setState when referencing the previous state.');
                }
              }
              break;
            }
            results.push(current = current.parent);
          }
          return results;
        },
        MemberExpression: function(node) {
          var current, prev, results;
          if (node.property.name === 'state' && node.object.type === 'ThisExpression') {
            current = node;
            prev = null;
            results = [];
            while (current.type !== 'Program') {
              // Reporting if this.state is directly within this.setState
              if (isFirstArgumentInSetStateCall(current, node)) {
                context.report(node, 'Use callback in setState when referencing the previous state.');
                break;
              }
              // Storing all functions and methods that contains this.state
              if (current.type === 'MethodDefinition') {
                methods.push({
                  methodName: current.key.name,
                  node
                });
                break;
              } else if (current.type === 'FunctionExpression' && current.parent.key) {
                methods.push({
                  methodName: current.parent.key.name,
                  node
                });
                break;
              }
              // Storing all variables containg this.state
              if (current.type === 'VariableDeclarator') {
                vars.push({
                  node,
                  scope: context.getScope(),
                  variableName: current.id.name
                });
                break;
              }
              if (isDeclarationAssignment(current) && current.left.type === 'Identifier' && current.right === prev) {
                vars.push({
                  node,
                  scope: context.getScope(),
                  variableName: current.left.name
                });
                break;
              }
              prev = current;
              results.push(current = current.parent);
            }
            return results;
          }
        },
        Identifier: function(node) {
          var current, results;
          // Checks if the identifier is a variable within an object
          current = node;
          while (current.parent.type === 'BinaryExpression') {
            current = current.parent;
          }
          if (current.parent.value === current || current.parent.object === current) {
            results = [];
            while (current.type !== 'Program') {
              if (isFirstArgumentInSetStateCall(current, node)) {
                vars.filter(function(v) {
                  return v.scope === context.getScope() && v.variableName === node.name;
                }).map(function(v) {
                  return context.report(v.node, 'Use callback in setState when referencing the previous state.');
                });
              }
              results.push(current = current.parent);
            }
            return results;
          }
        },
        ObjectPattern: function(node) {
          var isDerivedFromThis;
          isDerivedFromThis = (node.parent.init && node.parent.init.type === 'ThisExpression') || (isDeclarationAssignment(node.parent) && node.parent.right.type === 'ThisExpression');
          return node.properties.forEach(function(property) {
            if ((property != null ? property.key : void 0) && property.key.name === 'state' && isDerivedFromThis) {
              return vars.push({
                node: property.key,
                scope: context.getScope(),
                variableName: property.key.name
              });
            }
          });
        }
      };
    }
  };

}).call(this);
