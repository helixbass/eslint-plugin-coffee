// Generated by CoffeeScript 2.5.0
(function() {
  var Exports, declaredScope, docsUrl, getDeprecation, message;

  ({
    default: declaredScope
  } = require('eslint-module-utils/declaredScope'));

  ({
    default: Exports
  } = require('../eslint-plugin-import-export-map'));

  ({
    default: docsUrl
  } = require('eslint-plugin-import/lib/docsUrl'));

  message = function(deprecation) {
    return `Deprecated${deprecation.description ? `: ${deprecation.description}` : '.'}`;
  };

  getDeprecation = function(metadata) {
    var deprecation;
    if (!(metadata != null ? metadata.doc : void 0)) {
      return;
    }
    deprecation = null;
    if (metadata.doc.tags.some(function(t) {
      return t.title === 'deprecated' && (deprecation = t);
    })) {
      return deprecation;
    }
  };

  module.exports = {
    meta: {
      type: 'suggestion',
      docs: {
        url: docsUrl('no-deprecated')
      }
    },
    create: function(context) {
      var checkSpecifiers, deprecated, namespaces;
      deprecated = new Map();
      namespaces = new Map();
      checkSpecifiers = function(node) {
        var imports, moduleDeprecation, ref;
        if (node.type !== 'ImportDeclaration') {
          return;
        }
        if (node.source == null) {
          return; // local export, ignore
        }
        imports = Exports.get(node.source.value, context);
        if (imports == null) {
          return;
        }
        moduleDeprecation = null;
        if ((ref = imports.doc) != null ? ref.tags.some(function(t) {
          return t.title === 'deprecated' && (moduleDeprecation = t);
        }) : void 0) {
          context.report({
            node,
            message: message(moduleDeprecation)
          });
        }
        if (imports.errors.length) {
          imports.reportErrors(context, node);
          return;
        }
        return node.specifiers.forEach(function(im) {
          var deprecation, exported, imported, local;
          switch (im.type) {
            case 'ImportNamespaceSpecifier':
              if (!imports.size) {
                return;
              }
              namespaces.set(im.local.name, imports);
              return;
            case 'ImportDefaultSpecifier':
              imported = 'default';
              local = im.local.name;
              break;
            case 'ImportSpecifier':
              imported = im.imported.name;
              local = im.local.name; // can't handle this one
              break;
            default:
              return;
          }
          
          // unknown thing can't be deprecated
          exported = imports.get(imported);
          if (exported == null) {
            return;
          }
          // capture import of deep namespace
          if (exported.namespace) {
            namespaces.set(local, exported.namespace);
          }
          deprecation = getDeprecation(imports.get(imported));
          if (!deprecation) {
            return;
          }
          context.report({
            node: im,
            message: message(deprecation)
          });
          return deprecated.set(local, deprecation);
        });
      };
      return {
        Program: function({body}) {
          return body.forEach(checkSpecifiers);
        },
        Identifier: function(node) {
          // handled by MemberExpression
          if (node.parent.type === 'MemberExpression' && node.parent.property === node) {
            return;
          }
          // ignore specifier identifiers
          if (node.parent.type.slice(0, 6) === 'Import') {
            return;
          }
          if (!deprecated.has(node.name)) {
            return;
          }
          if (declaredScope(context, node.name) !== 'module') {
            return;
          }
          return context.report({
            node,
            message: message(deprecated.get(node.name))
          });
        },
        MemberExpression: function(dereference) {
          var deprecation, metadata, namepath, namespace;
          if (dereference.object.type !== 'Identifier') {
            return;
          }
          if (!namespaces.has(dereference.object.name)) {
            return;
          }
          if (declaredScope(context, dereference.object.name) !== 'module') {
            return;
          }
          // go deep
          namespace = namespaces.get(dereference.object.name);
          namepath = [dereference.object.name];
          // while property is namespace and parent is member expression, keep validating
          while (namespace instanceof Exports && dereference.type === 'MemberExpression') {
            // ignore computed parts for now
            if (dereference.computed) {
              return;
            }
            metadata = namespace.get(dereference.property.name);
            if (!metadata) {
              break;
            }
            deprecation = getDeprecation(metadata);
            if (deprecation) {
              context.report({
                node: dereference.property,
                message: message(deprecation)
              });
            }
            // stash and pop
            namepath.push(dereference.property.name);
            ({namespace} = metadata);
            dereference = dereference.parent;
          }
        }
      };
    }
  };

}).call(this);
