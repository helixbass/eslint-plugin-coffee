// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A class of the code path segment.
   * @author Toru Nagashima
   */
  'use strict';
  var CodePathSegment, debug, isReachable;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  debug = require('../eslint-code-path-analysis-debug-helpers');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Checks whether or not a given segment is reachable.
   *
   * @param {CodePathSegment} segment - A segment to check.
   * @returns {boolean} `true` if the segment is reachable.
   */
  isReachable = function(segment) {
    return segment.reachable;
  };

  //------------------------------------------------------------------------------
  // Public Interface
  //------------------------------------------------------------------------------
  /**
   * A code path segment.
   */
  CodePathSegment = class CodePathSegment {
    /**
     * @param {string} id - An identifier.
     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
     *   This array includes unreachable segments.
     * @param {boolean} reachable - A flag which shows this is reachable.
     */
    constructor(id1, allPrevSegments1, reachable) {
      /**
       * The identifier of this code path.
       * Rules use it to store additional information of each rule.
       * @type {string}
       */
      this.id = id1;
      /**
       * An array of the previous segments.
       * This array includes unreachable segments.
       * @type {CodePathSegment[]}
       */
      this.allPrevSegments = allPrevSegments1;
      /**
       * A flag which shows this is reachable.
       * @type {boolean}
       */
      this.reachable = reachable;
      /**
       * An array of the next segments.
       * @type {CodePathSegment[]}
       */
      this.nextSegments = [];
      /**
       * An array of the previous segments.
       * @type {CodePathSegment[]}
       */
      this.prevSegments = this.allPrevSegments.filter(isReachable);
      /**
       * An array of the next segments.
       * This array includes unreachable segments.
       * @type {CodePathSegment[]}
       */
      this.allNextSegments = [];
      // Internal data.
      Object.defineProperty(this, 'internal', {
        value: {
          used: false,
          loopedPrevSegments: []
        }
      });
      /* istanbul ignore if */
      if (debug.enabled) {
        this.internal.nodes = [];
        this.internal.exitNodes = [];
      }
    }

    /**
     * Checks a given previous segment is coming from the end of a loop.
     *
     * @param {CodePathSegment} segment - A previous segment to check.
     * @returns {boolean} `true` if the segment is coming from the end of a loop.
     */
    isLoopedPrevSegment(segment) {
      return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
    }

    /**
     * Creates the root segment.
     *
     * @param {string} id - An identifier.
     * @returns {CodePathSegment} The created segment.
     */
    static newRoot(id) {
      return new CodePathSegment(id, [], true);
    }

    /**
     * Creates a segment that follows given segments.
     *
     * @param {string} id - An identifier.
     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newNext(id, allPrevSegments) {
      return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
    }

    /**
     * Creates an unreachable segment that follows given segments.
     *
     * @param {string} id - An identifier.
     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newUnreachable(id, allPrevSegments) {
      var segment;
      segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
      /*
       * In `if (a) return a; foo();` case, the unreachable segment preceded by
       * the return statement is not used but must not be remove.
       */
      CodePathSegment.markUsed(segment);
      return segment;
    }

    /**
     * Creates a segment that follows given segments.
     * This factory method does not connect with `allPrevSegments`.
     * But this inherits `reachable` flag.
     *
     * @param {string} id - An identifier.
     * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
     * @returns {CodePathSegment} The created segment.
     */
    static newDisconnected(id, allPrevSegments) {
      return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
    }

    /**
     * Makes a given segment being used.
     *
     * And this function registers the segment into the previous segments as a next.
     *
     * @param {CodePathSegment} segment - A segment to mark.
     * @returns {void}
     */
    static markUsed(segment) {
      var i, j, len, len1, prevSegment, ref, ref1, results, results1;
      if (segment.internal.used) {
        return;
      }
      segment.internal.used = true;
      if (segment.reachable) {
        ref = segment.allPrevSegments;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          prevSegment = ref[i];
          prevSegment.allNextSegments.push(segment);
          results.push(prevSegment.nextSegments.push(segment));
        }
        return results;
      } else {
        ref1 = segment.allPrevSegments;
        results1 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          prevSegment = ref1[j];
          results1.push(prevSegment.allNextSegments.push(segment));
        }
        return results1;
      }
    }

    /**
     * Marks a previous segment as looped.
     *
     * @param {CodePathSegment} segment - A segment.
     * @param {CodePathSegment} prevSegment - A previous segment to mark.
     * @returns {void}
     */
    static markPrevSegmentAsLooped(segment, prevSegment) {
      return segment.internal.loopedPrevSegments.push(prevSegment);
    }

    /**
     * Replaces unused segments with the previous segments of each unused segment.
     *
     * @param {CodePathSegment[]} segments - An array of segments to replace.
     * @returns {CodePathSegment[]} The replaced array.
     */
    static flattenUnusedSegments(segments) {
      var done, i, j, len, len1, prevSegment, ref, retv, segment;
      done = Object.create(null);
      retv = [];
      for (i = 0, len = segments.length; i < len; i++) {
        segment = segments[i];
        if (done[segment.id]) {
          // Ignores duplicated.
          continue;
        }
        // Use previous segments if unused.
        if (!segment.internal.used) {
          ref = segment.allPrevSegments;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            prevSegment = ref[j];
            if (!done[prevSegment.id]) {
              done[prevSegment.id] = true;
              retv.push(prevSegment);
            }
          }
        } else {
          done[segment.id] = true;
          retv.push(segment);
        }
      }
      return retv;
    }

  };

  module.exports = CodePathSegment;

}).call(this);
