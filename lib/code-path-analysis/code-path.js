// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A class of the code path.
   * @author Toru Nagashima
   */
  'use strict';
  var CodePath, CodePathState, IdGenerator;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  CodePathState = require('./code-path-state');

  IdGenerator = require('../eslint-code-path-analysis-id-generator');

  //------------------------------------------------------------------------------
  // Public Interface
  //------------------------------------------------------------------------------
  /**
   * A code path.
   */
  CodePath = class CodePath {
    /**
     * @param {string} id - An identifier.
     * @param {CodePath|null} upper - The code path of the upper function scope.
     * @param {Function} onLooped - A callback function to notify looping.
     */
    constructor(id, upper, onLooped) {
      var ref;
      /**
       * The identifier of this code path.
       * Rules use it to store additional information of each rule.
       * @type {string}
       */
      this.id = id;
      /**
       * The code path of the upper function scope.
       * @type {CodePath|null}
       */
      this.upper = upper;
      /**
       * The code paths of nested function scopes.
       * @type {CodePath[]}
       */
      this.childCodePaths = [];
      // Initializes internal state.
      Object.defineProperty(this, 'internal', {
        value: new CodePathState(new IdGenerator(`${this.id}_`), onLooped)
      });
      // Adds this into `childCodePaths` of `upper`.
      if ((ref = this.upper) != null) {
        ref.childCodePaths.push(this);
      }
    }

    /**
     * Gets the state of a given code path.
     *
     * @param {CodePath} codePath - A code path to get.
     * @returns {CodePathState} The state of the code path.
     */
    static getState(codePath) {
      return codePath.internal;
    }

    /**
     * Traverses all segments in this code path.
     *
     *     codePath.traverseSegments(function(segment, controller) {
     *         // do something.
     *     });
     *
     * This method enumerates segments in order from the head.
     *
     * The `controller` object has two methods.
     *
     * - `controller.skip()` - Skip the following segments in this branch.
     * - `controller.break()` - Skip all following segments.
     *
     * @param {Object} [options] - Omittable.
     * @param {CodePathSegment} [options.first] - The first segment to traverse.
     * @param {CodePathSegment} [options.last] - The last segment to traverse.
     * @param {Function} callback - A callback function.
     * @returns {void}
     */
    traverseSegments(options, callback) {
      /**
       * Checks a given previous segment has been visited.
       * @param {CodePathSegment} prevSegment - A previous segment to check.
       * @returns {boolean} `true` if the segment has been visited.
       */
      var broken, controller, end, index, isVisited, item, lastSegment, resolvedCallback, resolvedOptions, results, segment, skippedSegment, stack, startSegment, visited;
      if (typeof options === 'function') {
        resolvedCallback = options;
        resolvedOptions = {};
      } else {
        resolvedOptions = options || {};
        resolvedCallback = callback;
      }
      startSegment = resolvedOptions.first || this.internal.initialSegment;
      lastSegment = resolvedOptions.last;
      item = null;
      index = 0;
      end = 0;
      segment = null;
      visited = Object.create(null);
      stack = [[startSegment, 0]];
      skippedSegment = null;
      broken = false;
      controller = {
        skip: function() {
          if (stack.length <= 1) {
            return broken = true;
          } else {
            return skippedSegment = stack[stack.length - 2][0];
          }
        },
        break: function() {
          return broken = true;
        }
      };
      isVisited = function(prevSegment) {
        return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
      };
      results = [];
      while (stack.length > 0) {
        item = stack[stack.length - 1];
        segment = item[0];
        index = item[1];
        if (index === 0) {
          // Skip if this segment has been visited already.
          if (visited[segment.id]) {
            stack.pop();
            continue;
          }
          // Skip if all previous segments have not been visited.
          if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
            stack.pop();
            continue;
          }
          // Reset the flag of skipping if all branches have been skipped.
          if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
            skippedSegment = null;
          }
          visited[segment.id] = true;
          // Call the callback when the first time.
          if (!skippedSegment) {
            resolvedCallback.call(this, segment, controller);
            if (segment === lastSegment) {
              controller.skip();
            }
            if (broken) {
              break;
            }
          }
        }
        // Update the stack.
        end = segment.nextSegments.length - 1;
        if (index < end) {
          item[1] += 1;
          results.push(stack.push([segment.nextSegments[index], 0]));
        } else if (index === end) {
          item[0] = segment.nextSegments[index];
          results.push(item[1] = 0);
        } else {
          results.push(stack.pop());
        }
      }
      return results;
    }

  };

  /**
   * Current code path segments.
   * @type {CodePathSegment[]}
   */
  Object.defineProperty(CodePath.prototype, 'currentSegments', {
    get: function() {
      return this.internal.currentSegments;
    }
  });

  /**
   * The initial code path segment.
   * @type {CodePathSegment}
   */
  Object.defineProperty(CodePath.prototype, 'initialSegment', {
    get: function() {
      return this.internal.initialSegment;
    }
  });

  /**
   * Final code path segments.
   * This array is a mix of `returnedSegments` and `thrownSegments`.
   * @type {CodePathSegment[]}
   */
  Object.defineProperty(CodePath.prototype, 'finalSegments', {
    get: function() {
      return this.internal.finalSegments;
    }
  });

  /**
   * Final code path segments which is with `return` statements.
   * This array contains the last path segment if it's reachable.
   * Since the reachable last path returns `undefined`.
   * @type {CodePathSegment[]}
   */
  Object.defineProperty(CodePath.prototype, 'returnedSegments', {
    get: function() {
      return this.internal.returnedForkContext;
    }
  });

  /**
   * Final code path segments which is with `throw` statements.
   * @type {CodePathSegment[]}
   */
  Object.defineProperty(CodePath.prototype, 'thrownSegments', {
    get: function() {
      return this.internal.thrownForkContext;
    }
  });

  module.exports = CodePath;

}).call(this);
