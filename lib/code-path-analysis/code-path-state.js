// Generated by CoffeeScript 2.5.0
(function() {
  /**
   * @fileoverview A class to manage state of generating a code path.
   * @author Toru Nagashima
   */
  'use strict';
  /**
   * Finalizes segments of `test` chunk of a ForStatement.
   *
   * - Adds `false` paths to paths which are leaving from the loop.
   * - Sets `true` paths to paths which go to the body.
   *
   * @param {LoopContext} context - A loop context to modify.
   * @param {ChoiceContext} choiceContext - A choice context of this loop.
   * @param {CodePathSegment[]} head - The current head paths.
   * @returns {void}
   */
  /**
   * Gets a context for a `break` statement.
   *
   * @param {CodePathState} state - A state to get.
   * @param {string} label - The label of a `break` statement.
   * @returns {LoopContext|SwitchContext} A context for a `break` statement.
   */
  /**
   * Gets a loop-context for a `continue` statement.
   *
   * @param {CodePathState} state - A state to get.
   * @param {string} label - The label of a `continue` statement.
   * @returns {LoopContext} A loop-context for a `continue` statement.
   */
  /**
   * Gets a context for a `return` statement.
   *
   * @param {CodePathState} state - A state to get.
   * @returns {TryContext|CodePathState} A context for a `return` statement.
   */
  /**
   * Gets a context for a `throw` statement.
   *
   * @param {CodePathState} state - A state to get.
   * @returns {TryContext|CodePathState} A context for a `throw` statement.
   */
  /**
   * Creates looping path.
   *
   * @param {CodePathState} state - The instance.
   * @param {CodePathSegment[]} unflattenedFromSegments - Segments which are source.
   * @param {CodePathSegment[]} unflattenedToSegments - Segments which are destination.
   * @returns {void}
   */
  /**
   * Removes a given element from a given array.
   *
   * @param {any[]} xs - An array to remove the specific element.
   * @param {any} x - An element to be removed.
   * @returns {void}
   */
  /**
   * Disconnect given segments.
   *
   * This is used in a process for switch statements.
   * If there is the "default" chunk before other cases, the order is different
   * between node's and running's.
   *
   * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.
   * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.
   * @returns {void}
   */
  var CodePathSegment, CodePathState, ForkContext, addToReturnedOrThrown, finalizeTestSegmentsOfFor, getBreakContext, getContinueContext, getReturnContext, getThrowContext, makeLooped, remove, removeConnection;

  //------------------------------------------------------------------------------
  // Requirements
  //------------------------------------------------------------------------------
  CodePathSegment = require('./code-path-segment');

  ForkContext = require('./fork-context');

  //------------------------------------------------------------------------------
  // Helpers
  //------------------------------------------------------------------------------
  /**
   * Adds given segments into the `dest` array.
   * If the `others` array does not includes the given segments, adds to the `all`
   * array as well.
   *
   * This adds only reachable and used segments.
   *
   * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).
   * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).
   * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).
   * @param {CodePathSegment[]} segments - Segments to add.
   * @returns {void}
   */
  addToReturnedOrThrown = function(dest, others, all, segments) {
    var i, results, segment;
    i = 0;
    results = [];
    while (i < segments.length) {
      segment = segments[i];
      dest.push(segment);
      if (others.indexOf(segment) === -1) {
        all.push(segment);
      }
      results.push(++i);
    }
    return results;
  };

  getContinueContext = function(state, label) {
    var context;
    if (!label) {
      return state.loopContext;
    }
    context = state.loopContext;
    while (context) {
      if (context.label === label) {
        return context;
      }
      context = context.upper;
    }
    /* istanbul ignore next: foolproof (syntax error) */
    return null;
  };

  getBreakContext = function(state, label) {
    var context;
    context = state.breakContext;
    while (context) {
      if ((label ? context.label === label : context.breakable)) {
        return context;
      }
      context = context.upper;
    }
    /* istanbul ignore next: foolproof (syntax error) */
    return null;
  };

  getReturnContext = function(state) {
    var context;
    context = state.tryContext;
    while (context) {
      if (context.hasFinalizer && context.position !== 'finally') {
        return context;
      }
      context = context.upper;
    }
    return state;
  };

  getThrowContext = function(state) {
    var context;
    context = state.tryContext;
    while (context) {
      if (context.position === 'try' || (context.hasFinalizer && context.position === 'catch')) {
        return context;
      }
      context = context.upper;
    }
    return state;
  };

  remove = function(xs, x) {
    return xs.splice(xs.indexOf(x), 1);
  };

  removeConnection = function(prevSegments, nextSegments) {
    var i, nextSegment, prevSegment, results;
    i = 0;
    results = [];
    while (i < prevSegments.length) {
      prevSegment = prevSegments[i];
      nextSegment = nextSegments[i];
      remove(prevSegment.nextSegments, nextSegment);
      remove(prevSegment.allNextSegments, nextSegment);
      remove(nextSegment.prevSegments, prevSegment);
      remove(nextSegment.allPrevSegments, prevSegment);
      results.push(++i);
    }
    return results;
  };

  makeLooped = function(state, unflattenedFromSegments, unflattenedToSegments) {
    var end, fromSegment, fromSegments, i, results, toSegment, toSegments;
    fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
    toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
    end = Math.min(fromSegments.length, toSegments.length);
    i = 0;
    results = [];
    while (i < end) {
      fromSegment = fromSegments[i];
      toSegment = toSegments[i];
      if (toSegment.reachable) {
        fromSegment.nextSegments.push(toSegment);
      }
      if (fromSegment.reachable) {
        toSegment.prevSegments.push(fromSegment);
      }
      fromSegment.allNextSegments.push(toSegment);
      toSegment.allPrevSegments.push(fromSegment);
      if (toSegment.allPrevSegments.length >= 2) {
        CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
      }
      state.notifyLooped(fromSegment, toSegment);
      results.push(++i);
    }
    return results;
  };

  finalizeTestSegmentsOfFor = function(context, choiceContext, head) {
    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(head);
      choiceContext.falseForkContext.add(head);
    }
    if (context.test !== true) {
      context.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    return context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
  };

  //------------------------------------------------------------------------------
  // Public Interface
  //------------------------------------------------------------------------------
  /**
   * A class which manages state to analyze code paths.
   */
  CodePathState = class CodePathState {
    /**
     * @param {IdGenerator} idGenerator - An id generator to generate id for code
     *   path segments.
     * @param {Function} onLooped - A callback function to notify looping.
     */
    constructor(idGenerator, notifyLooped) {
      var final, returned, thrown;
      this.idGenerator = idGenerator;
      this.notifyLooped = notifyLooped;
      this.forkContext = ForkContext.newRoot(this.idGenerator);
      this.choiceContext = null;
      this.switchContext = null;
      this.tryContext = null;
      this.loopContext = null;
      this.breakContext = null;
      this.currentSegments = [];
      this.initialSegment = this.forkContext.head[0];
      // returnedSegments and thrownSegments push elements into finalSegments also.
      final = this.finalSegments = [];
      returned = this.returnedForkContext = [];
      thrown = this.thrownForkContext = [];
      returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
      thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
    }

    /**
     * Creates and stacks new forking context.
     *
     * @param {boolean} forkLeavingPath - A flag which shows being in a
     *   "finally" block.
     * @returns {ForkContext} The created context.
     */
    pushForkContext(forkLeavingPath) {
      this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);
      return this.forkContext;
    }

    /**
     * Pops and merges the last forking context.
     * @returns {ForkContext} The last context.
     */
    popForkContext() {
      var lastContext;
      lastContext = this.forkContext;
      this.forkContext = lastContext.upper;
      this.forkContext.replaceHead(lastContext.makeNext(0, -1));
      return lastContext;
    }

    /**
     * Creates a new path.
     * @returns {void}
     */
    forkPath() {
      return this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }

    /**
     * Creates a bypass path.
     * This is used for such as IfStatement which does not have "else" chunk.
     *
     * @returns {void}
     */
    forkBypassPath() {
      return this.forkContext.add(this.parentForkContext.head);
    }

    //--------------------------------------------------------------------------
    // ConditionalExpression, LogicalExpression, IfStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context for ConditionalExpression, LogicalExpression,
     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
     *
     * LogicalExpressions have cases that it goes different paths between the
     * `true` case and the `false` case.
     *
     * For Example:
     *
     *     if (a || b) {
     *         foo();
     *     } else {
     *         bar();
     *     }
     *
     * In this case, `b` is evaluated always in the code path of the `else`
     * block, but it's not so in the code path of the `if` block.
     * So there are 3 paths.
     *
     *     a -> foo();
     *     a -> b -> foo();
     *     a -> b -> bar();
     *
     * @param {string} kind - A kind string.
     *   If the new context is LogicalExpression's, this is `"&&"` or `"||"`.
     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
     *   Otherwise, this is `"loop"`.
     * @param {boolean} isForkingAsResult - A flag that shows that goes different
     *   paths between `true` and `false`.
     * @returns {void}
     */
    pushChoiceContext(kind, isForkingAsResult) {
      return this.choiceContext = {
        upper: this.choiceContext,
        kind,
        isForkingAsResult,
        trueForkContext: ForkContext.newEmpty(this.forkContext),
        falseForkContext: ForkContext.newEmpty(this.forkContext),
        processed: false
      };
    }

    /**
     * Pops the last choice context and finalizes it.
     *
     * @returns {ChoiceContext} The popped context.
     */
    popChoiceContext() {
      var context, falseForkContext, forkContext, headSegments, isForkingAsResult, kind, parentContext, prevForkContext, processed, trueForkContext, upper;
      context = this.choiceContext;
      ({trueForkContext, falseForkContext, processed, upper, kind, isForkingAsResult} = context);
      this.choiceContext = upper;
      ({forkContext} = this);
      headSegments = forkContext.head;
      switch (kind) {
        case '&&':
        case '||':
        case 'and':
        case 'or':
        case '?':
          /*
           * If any result were not transferred from child contexts,
           * this sets the head segments to both cases.
           * The head segments are the path of the right-hand operand.
           */
          if (!processed) {
            trueForkContext.add(headSegments);
            falseForkContext.add(headSegments);
          }
          /*
           * Transfers results to upper context if this context is in
           * test chunk.
           */
          if (isForkingAsResult) {
            parentContext = this.choiceContext;
            parentContext.trueForkContext.addAll(trueForkContext);
            parentContext.falseForkContext.addAll(falseForkContext);
            parentContext.processed = true;
            return context;
          }
          break;
        case 'test':
          if (!processed) {
            /*
             * The head segments are the path of the `if` block here.
             * Updates the `true` path with the end of the `if` block.
             */
            trueForkContext.clear();
            trueForkContext.add(headSegments);
          } else {
            /*
             * The head segments are the path of the `else` block here.
             * Updates the `false` path with the end of the `else`
             * block.
             */
            falseForkContext.clear();
            falseForkContext.add(headSegments);
          }
          break;
        case 'loop':
          /*
           * Loops are addressed in popLoopContext().
           * This is called from popLoopContext().
           */
          return context;
        default:
          /* istanbul ignore next */
          throw new Error('unreachable');
      }
      // Merges all paths.
      prevForkContext = trueForkContext;
      prevForkContext.addAll(falseForkContext);
      forkContext.replaceHead(prevForkContext.makeNext(0, -1));
      return context;
    }

    /**
     * Makes a code path segment of the right-hand operand of a logical
     * expression.
     *
     * @returns {void}
     */
    makeLogicalRight() {
      /*
       * This got segments already from the child choice context.
       * Creates the next path from own true/false fork context.
       */
      var context, forkContext, prevForkContext, ref, ref1;
      ({
        choiceContext: context,
        forkContext
      } = this);
      if (context.processed) {
        /* kind === "||" */
        prevForkContext = (ref = context.kind) === '&&' || ref === 'and' ? context.trueForkContext : context.falseForkContext;
        forkContext.replaceHead(prevForkContext.makeNext(0, -1));
        prevForkContext.clear();
        return context.processed = false;
      } else {
        /*
         * This did not get segments from the child choice context.
         * So addresses the head segments.
         * The head segments are the path of the left-hand operand.
         */
        if ((ref1 = context.kind) === '&&' || ref1 === 'and') {
          // The path does short-circuit if false.
          context.falseForkContext.add(forkContext.head);
        } else {
          // The path does short-circuit if true.
          context.trueForkContext.add(forkContext.head);
        }
        return forkContext.replaceHead(forkContext.makeNext(-1, -1));
      }
    }

    /**
     * Makes a code path segment of the `if` block.
     *
     * @returns {void}
     */
    makeIfConsequent() {
      var context, falseForkContext, forkContext, head, processed, trueForkContext;
      ({
        choiceContext: context,
        forkContext
      } = this);
      ({processed, trueForkContext, falseForkContext} = context);
      ({head} = forkContext);
      /*
       * If any result were not transferred from child contexts,
       * this sets the head segments to both cases.
       * The head segments are the path of the test expression.
       */
      if (!processed) {
        trueForkContext.add(head);
        falseForkContext.add(head);
      }
      context.processed = false;
      // Creates new path from the `true` case.
      return forkContext.replaceHead(trueForkContext.makeNext(0, -1));
    }

    /**
     * Makes a code path segment of the `else` block.
     *
     * @returns {void}
     */
    makeIfAlternate() {
      var context, falseForkContext, forkContext, head, trueForkContext;
      ({
        choiceContext: context,
        forkContext
      } = this);
      ({trueForkContext, falseForkContext} = context);
      ({head} = forkContext);
      /*
       * The head segments are the path of the `if` block.
       * Updates the `true` path with the end of the `if` block.
       */
      trueForkContext.clear();
      trueForkContext.add(head);
      context.processed = true;
      // Creates new path from the `false` case.
      return forkContext.replaceHead(falseForkContext.makeNext(0, -1));
    }

    //--------------------------------------------------------------------------
    // SwitchStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of SwitchStatement and stacks it.
     *
     * @param {boolean} hasCase - `true` if the switch statement has one or more
     *   case parts.
     * @param {string|null} label - The label text.
     * @returns {void}
     */
    pushSwitchContext(hasCase, label) {
      this.switchContext = {
        upper: this.switchContext,
        hasCase,
        defaultSegments: null,
        defaultBodySegments: null,
        foundDefault: false,
        lastIsDefault: false,
        countForks: 0
      };
      return this.pushBreakContext(true, label);
    }

    /**
     * Pops the last context of SwitchStatement and finalizes it.
     *
     * - Disposes all forking stack for `case` and `default`.
     * - Creates the next code path segment from `context.brokenForkContext`.
     * - If the last `SwitchCase` node is not a `default` part, creates a path
     *   to the `default` body.
     *
     * @returns {void}
     */
    popSwitchContext() {
      var brokenForkContext, context, forkContext, i, lastCaseSegments, lastSegments;
      context = this.switchContext;
      this.switchContext = context.upper;
      ({forkContext} = this);
      ({brokenForkContext} = this.popBreakContext());
      if (context.countForks === 0) {
        /*
         * When there is only one `default` chunk and there is one or more
         * `break` statements, even if forks are nothing, it needs to merge
         * those.
         */
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext.makeNext(-1, -1));
          forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
        return;
      }
      lastSegments = forkContext.head;
      this.forkBypassPath();
      lastCaseSegments = forkContext.head;
      /*
       * `brokenForkContext` is used to make the next segment.
       * It must add the last segment into `brokenForkContext`.
       */
      brokenForkContext.add(lastSegments);
      /*
       * A path which is failed in all case test should be connected to path
       * of `default` chunk.
       */
      if (!context.lastIsDefault) {
        if (context.defaultBodySegments) {
          /*
           * Remove a link from `default` label to its chunk.
           * It's false route.
           */
          removeConnection(context.defaultSegments, context.defaultBodySegments);
          makeLooped(this, lastCaseSegments, context.defaultBodySegments);
        } else {
          /*
           * It handles the last case body as broken if `default` chunk
           * does not exist.
           */
          brokenForkContext.add(lastCaseSegments);
        }
      }
      i = 0;
      // Pops the segment context stack until the entry segment.
      while (i < context.countForks) {
        this.forkContext = this.forkContext.upper;
        ++i;
      }
      /*
       * Creates a path from all brokenForkContext paths.
       * This is a path after switch statement.
       */
      return this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }

    /**
     * Makes a code path segment for a `SwitchCase` node.
     *
     * @param {boolean} isEmpty - `true` if the body is empty.
     * @param {boolean} isDefault - `true` if the body is the default case.
     * @returns {void}
     */
    makeSwitchCaseBody(isEmpty, isDefault) {
      /*
       * Merge forks.
       * The parent fork context has two segments.
       * Those are from the current case and the body of the previous case.
       */
      var context, forkContext, parentForkContext;
      context = this.switchContext;
      if (!context.hasCase) {
        return;
      }
      parentForkContext = this.forkContext;
      forkContext = this.pushForkContext();
      forkContext.add(parentForkContext.makeNext(0, -1));
      /*
       * Save `default` chunk info.
       * If the `default` label is not at the last, we must make a path from
       * the last `case` to the `default` chunk.
       */
      if (isDefault) {
        context.defaultSegments = parentForkContext.head;
        if (isEmpty) {
          context.foundDefault = true;
        } else {
          context.defaultBodySegments = forkContext.head;
        }
      } else if (!isEmpty && context.foundDefault) {
        context.foundDefault = false;
        context.defaultBodySegments = forkContext.head;
      }
      context.lastIsDefault = isDefault;
      return context.countForks += 1;
    }

    //--------------------------------------------------------------------------
    // TryStatement
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of TryStatement and stacks it.
     *
     * @param {boolean} hasFinalizer - `true` if the try statement has a
     *   `finally` block.
     * @returns {void}
     */
    pushTryContext(hasFinalizer) {
      return this.tryContext = {
        upper: this.tryContext,
        position: 'try',
        hasFinalizer,
        returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,
        thrownForkContext: ForkContext.newEmpty(this.forkContext),
        lastOfTryIsReachable: false,
        lastOfCatchIsReachable: false
      };
    }

    /**
     * Pops the last context of TryStatement and finalizes it.
     *
     * @returns {void}
     */
    popTryContext() {
      /*
       * The following process is executed only when there is the `finally`
       * block.
       */
      var context, headSegments, leavingSegments, normalSegments, returned, thrown;
      context = this.tryContext;
      this.tryContext = context.upper;
      if (context.position === 'catch') {
        // Merges two paths from the `try` block and `catch` block merely.
        this.popForkContext();
        return;
      }
      returned = context.returnedForkContext;
      thrown = context.thrownForkContext;
      if (returned.empty && thrown.empty) {
        return;
      }
      // Separate head to normal paths and leaving paths.
      headSegments = this.forkContext.head;
      this.forkContext = this.forkContext.upper;
      normalSegments = headSegments.slice(0, (headSegments.length / 2) | 0);
      leavingSegments = headSegments.slice((headSegments.length / 2) | 0);
      // Forwards the leaving path to upper contexts.
      if (!returned.empty) {
        getReturnContext(this).returnedForkContext.add(leavingSegments);
      }
      if (!thrown.empty) {
        getThrowContext(this).thrownForkContext.add(leavingSegments);
      }
      // Sets the normal path as the next.
      this.forkContext.replaceHead(normalSegments);
      /*
       * If both paths of the `try` block and the `catch` block are
       * unreachable, the next path becomes unreachable as well.
       */
      if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
        return this.forkContext.makeUnreachable();
      }
    }

    /**
     * Makes a code path segment for a `catch` block.
     *
     * @returns {void}
     */
    makeCatchBlock() {
      var context, forkContext, thrown, thrownSegments;
      ({
        tryContext: context,
        forkContext
      } = this);
      thrown = context.thrownForkContext;
      // Update state.
      context.position = 'catch';
      context.thrownForkContext = ForkContext.newEmpty(forkContext);
      context.lastOfTryIsReachable = forkContext.reachable;
      // Merge thrown paths.
      thrown.add(forkContext.head);
      thrownSegments = thrown.makeNext(0, -1);
      // Fork to a bypass and the merged thrown path.
      this.pushForkContext();
      this.forkBypassPath();
      return this.forkContext.add(thrownSegments);
    }

    /**
     * Makes a code path segment for a `finally` block.
     *
     * In the `finally` block, parallel paths are created. The parallel paths
     * are used as leaving-paths. The leaving-paths are paths from `return`
     * statements and `throw` statements in a `try` block or a `catch` block.
     *
     * @returns {void}
     */
    makeFinallyBlock() {
      /*
       * Create a parallel segment from merging returned and thrown.
       * This segment will leave at the end of this finally block.
       */
      var context, forkContext, headOfLeavingSegments, i, j, prevSegsOfLeavingSegment, returned, segments, thrown;
      ({
        tryContext: context,
        forkContext
      } = this);
      returned = context.returnedForkContext;
      thrown = context.thrownForkContext;
      headOfLeavingSegments = forkContext.head;
      // Update state.
      if (context.position === 'catch') {
        // Merges two paths from the `try` block and `catch` block.
        this.popForkContext();
        ({forkContext} = this);
        context.lastOfCatchIsReachable = forkContext.reachable;
      } else {
        context.lastOfTryIsReachable = forkContext.reachable;
      }
      context.position = 'finally';
      // This path does not leave.
      if (returned.empty && thrown.empty) {
        return;
      }
      segments = forkContext.makeNext(-1, -1);
      i = 0;
      while (i < forkContext.count) {
        prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
        j = 0;
        while (j < returned.segmentsList.length) {
          prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
          ++j;
        }
        j = 0;
        while (j < thrown.segmentsList.length) {
          prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
          ++j;
        }
        segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
        ++i;
      }
      this.pushForkContext(true);
      return this.forkContext.add(segments);
    }

    /**
     * Makes a code path segment from the first throwable node to the `catch`
     * block or the `finally` block.
     *
     * @returns {void}
     */
    makeFirstThrowablePathInTryBlock() {
      var context, forkContext;
      ({forkContext} = this);
      if (!forkContext.reachable) {
        return;
      }
      context = getThrowContext(this);
      if (context === this || context.position !== 'try' || !context.thrownForkContext.empty) {
        return;
      }
      context.thrownForkContext.add(forkContext.head);
      return forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }

    //--------------------------------------------------------------------------
    // Loop Statements
    //--------------------------------------------------------------------------
    /**
     * Creates a context object of a loop statement and stacks it.
     *
     * @param {string} type - The type of the node which was triggered. One of
     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
     *   and `ForStatement`.
     * @param {string|null} label - A label of the node which was triggered.
     * @returns {void}
     */
    pushLoopContext(type, label) {
      var breakContext, forkContext;
      ({forkContext} = this);
      breakContext = this.pushBreakContext(true, label);
      switch (type) {
        case 'WhileStatement':
          this.pushChoiceContext('loop', false);
          return this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
        case 'DoWhileStatement':
          this.pushChoiceContext('loop', false);
          return this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            entrySegments: null,
            continueForkContext: ForkContext.newEmpty(forkContext),
            brokenForkContext: breakContext.brokenForkContext
          };
        case 'ForStatement':
          this.pushChoiceContext('loop', false);
          return this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            endOfInitSegments: null,
            testSegments: null,
            endOfTestSegments: null,
            updateSegments: null,
            endOfUpdateSegments: null,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
        case 'ForInStatement':
        case 'ForOfStatement':
        case 'For':
          return this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            prevSegments: null,
            leftSegments: null,
            endOfLeftSegments: null,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
        default:
          /* istanbul ignore next */
          throw new Error(`unknown type: \"${type}\"`);
      }
    }

    /**
     * Pops the last context of a loop statement and finalizes it.
     *
     * @returns {void}
     */
    popLoopContext() {
      var brokenForkContext, choiceContext, context, forkContext, i, segmentsList;
      context = this.loopContext;
      this.loopContext = context.upper;
      ({forkContext} = this);
      ({brokenForkContext} = this.popBreakContext());
      // Creates a looped path.
      switch (context.type) {
        case 'WhileStatement':
        case 'ForStatement':
          this.popChoiceContext();
          makeLooped(this, forkContext.head, context.continueDestSegments);
          break;
        case 'DoWhileStatement':
          choiceContext = this.popChoiceContext();
          if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
          }
          if (context.test !== true) {
            brokenForkContext.addAll(choiceContext.falseForkContext);
          }
          // `true` paths go to looping.
          ({segmentsList} = choiceContext.trueForkContext);
          i = 0;
          while (i < segmentsList.length) {
            makeLooped(this, segmentsList[i], context.entrySegments);
            ++i;
          }
          break;
        case 'ForInStatement':
        case 'ForOfStatement':
        case 'For':
          brokenForkContext.add(forkContext.head);
          if (context.leftSegments) {
            makeLooped(this, forkContext.head, context.leftSegments);
          }
          break;
        default:
          /* istanbul ignore next */
          throw new Error('unreachable');
      }
      // Go next.
      if (brokenForkContext.empty) {
        return forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      } else {
        return forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }

    /**
     * Makes a code path segment for the test part of a WhileStatement.
     *
     * @param {boolean|undefined} test - The test value (only when constant).
     * @returns {void}
     */
    makeWhileTest(test) {
      var context, testSegments;
      context = this.loopContext;
      testSegments = this.forkContext.makeNext(0, -1);
      // Update state.
      context.test = test;
      context.continueDestSegments = testSegments;
      return this.forkContext.replaceHead(testSegments);
    }

    /**
     * Makes a code path segment for the body part of a WhileStatement.
     *
     * @returns {void}
     */
    makeWhileBody() {
      var choiceContext, context, forkContext;
      ({
        loopContext: context,
        choiceContext,
        forkContext
      } = this);
      if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(forkContext.head);
        choiceContext.falseForkContext.add(forkContext.head);
      }
      // Update state.
      if (context.test !== true) {
        context.brokenForkContext.addAll(choiceContext.falseForkContext);
      }
      return forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    }

    /**
     * Makes a code path segment for the body part of a DoWhileStatement.
     *
     * @returns {void}
     */
    makeDoWhileBody() {
      var bodySegments, context, forkContext;
      ({
        loopContext: context,
        forkContext
      } = this);
      bodySegments = forkContext.makeNext(-1, -1);
      // Update state.
      context.entrySegments = bodySegments;
      return forkContext.replaceHead(bodySegments);
    }

    /**
     * Makes a code path segment for the test part of a DoWhileStatement.
     *
     * @param {boolean|undefined} test - The test value (only when constant).
     * @returns {void}
     */
    makeDoWhileTest(test) {
      var context, forkContext, testSegments;
      ({
        loopContext: context,
        forkContext
      } = this);
      context.test = test;
      // Creates paths of `continue` statements.
      if (!context.continueForkContext.empty) {
        context.continueForkContext.add(forkContext.head);
        testSegments = context.continueForkContext.makeNext(0, -1);
        return forkContext.replaceHead(testSegments);
      }
    }

    /**
     * Makes a code path segment for the test part of a ForStatement.
     *
     * @param {boolean|undefined} test - The test value (only when constant).
     * @returns {void}
     */
    makeForTest(test) {
      var context, endOfInitSegments, forkContext, testSegments;
      ({
        loopContext: context,
        forkContext
      } = this);
      endOfInitSegments = forkContext.head;
      testSegments = forkContext.makeNext(-1, -1);
      // Update state.
      context.test = test;
      context.endOfInitSegments = endOfInitSegments;
      context.continueDestSegments = context.testSegments = testSegments;
      return forkContext.replaceHead(testSegments);
    }

    /**
     * Makes a code path segment for the update part of a ForStatement.
     *
     * @returns {void}
     */
    makeForUpdate() {
      var choiceContext, context, forkContext, updateSegments;
      ({
        loopContext: context,
        choiceContext,
        forkContext
      } = this);
      // Make the next paths of the test.
      if (context.testSegments) {
        finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
      } else {
        context.endOfInitSegments = forkContext.head;
      }
      // Update state.
      updateSegments = forkContext.makeDisconnected(-1, -1);
      context.continueDestSegments = context.updateSegments = updateSegments;
      return forkContext.replaceHead(updateSegments);
    }

    /**
     * Makes a code path segment for the body part of a ForStatement.
     *
     * @returns {void}
     */
    makeForBody() {
      /*
       * If there is not the `test` part, the `body` path comes from the
       * `init` part and the `update` part.
       */
      var bodySegments, choiceContext, context, forkContext, prevForkContext;
      ({
        loopContext: context,
        choiceContext,
        forkContext
      } = this);
      // Update state.
      if (context.updateSegments) {
        context.endOfUpdateSegments = forkContext.head;
        // `update` -> `test`
        if (context.testSegments) {
          makeLooped(this, context.endOfUpdateSegments, context.testSegments);
        }
      } else if (context.testSegments) {
        finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);
      } else {
        context.endOfInitSegments = forkContext.head;
      }
      bodySegments = context.endOfTestSegments;
      if (!bodySegments) {
        prevForkContext = ForkContext.newEmpty(forkContext);
        prevForkContext.add(context.endOfInitSegments);
        if (context.endOfUpdateSegments) {
          prevForkContext.add(context.endOfUpdateSegments);
        }
        bodySegments = prevForkContext.makeNext(0, -1);
      }
      context.continueDestSegments || (context.continueDestSegments = bodySegments);
      return forkContext.replaceHead(bodySegments);
    }

    /**
     * Makes a code path segment for the left part of a ForInStatement and a
     * ForOfStatement.
     *
     * @returns {void}
     */
    makeForInOfLeft() {
      var context, forkContext, leftSegments;
      context = this.loopContext;
      if (context.leftSegments) {
        return;
      }
      ({forkContext} = this);
      leftSegments = forkContext.makeDisconnected(-1, -1);
      // Update state.
      context.prevSegments = forkContext.head;
      context.leftSegments = context.continueDestSegments = leftSegments;
      return forkContext.replaceHead(leftSegments);
    }

    /**
     * Makes a code path segment for the right part of a ForInStatement and a
     * ForOfStatement.
     *
     * @returns {void}
     */
    makeForInOfRight() {
      var context, forkContext, rightSegments, temp;
      ({
        loopContext: context,
        forkContext
      } = this);
      temp = ForkContext.newEmpty(forkContext);
      if (context.leftSegments) {
        temp.add(context.prevSegments);
      } else {
        temp.add(forkContext.head);
      }
      rightSegments = temp.makeNext(-1, -1);
      // Update state.
      if (context.leftSegments) {
        context.endOfLeftSegments = forkContext.head;
      }
      return forkContext.replaceHead(rightSegments);
    }

    /**
     * Makes a code path segment for the body part of a ForInStatement and a
     * ForOfStatement.
     *
     * @returns {void}
     */
    makeForInOfBody() {
      var bodySegments, context, forkContext, temp;
      context = this.loopContext;
      ({forkContext} = this);
      temp = ForkContext.newEmpty(forkContext);
      if (context.leftSegments) {
        temp.add(context.endOfLeftSegments);
      } else {
        temp.add(forkContext.head);
      }
      bodySegments = temp.makeNext(-1, -1);
      if (context.leftSegments) {
        // Make a path: `right` -> `left`.
        makeLooped(this, forkContext.head, context.leftSegments);
      }
      context.continueDestSegments || (context.continueDestSegments = bodySegments);
      // Update state.
      context.brokenForkContext.add(forkContext.head);
      return forkContext.replaceHead(bodySegments);
    }

    //--------------------------------------------------------------------------
    // Control Statements
    //--------------------------------------------------------------------------
    /**
     * Creates new context for BreakStatement.
     *
     * @param {boolean} breakable - The flag to indicate it can break by
     *      an unlabeled BreakStatement.
     * @param {string|null} label - The label of this context.
     * @returns {Object} The new context.
     */
    pushBreakContext(breakable, label) {
      this.breakContext = {
        upper: this.breakContext,
        breakable,
        label,
        brokenForkContext: ForkContext.newEmpty(this.forkContext)
      };
      return this.breakContext;
    }

    /**
     * Removes the top item of the break context stack.
     *
     * @returns {Object} The removed context.
     */
    popBreakContext() {
      var brokenForkContext, context, forkContext;
      ({
        breakContext: context,
        forkContext
      } = this);
      this.breakContext = context.upper;
      // Process this context here for other than switches and loops.
      if (!context.breakable) {
        ({brokenForkContext} = context);
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext.head);
          forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
      }
      return context;
    }

    /**
     * Makes a path for a `break` statement.
     *
     * It registers the head segment to a context of `break`.
     * It makes new unreachable segment, then it set the head with the segment.
     *
     * @param {string} label - A label of the break statement.
     * @returns {void}
     */
    makeBreak(label) {
      var context, forkContext;
      ({forkContext} = this);
      if (!forkContext.reachable) {
        return;
      }
      context = getBreakContext(this, label);
      /* istanbul ignore else: foolproof (syntax error) */
      if (context) {
        context.brokenForkContext.add(forkContext.head);
      }
      return forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }

    /**
     * Makes a path for a `continue` statement.
     *
     * It makes a looping path.
     * It makes new unreachable segment, then it set the head with the segment.
     *
     * @param {string} label - A label of the continue statement.
     * @returns {void}
     */
    makeContinue(label) {
      var context, forkContext, ref;
      ({forkContext} = this);
      if (!forkContext.reachable) {
        return;
      }
      context = getContinueContext(this, label);
      /* istanbul ignore else: foolproof (syntax error) */
      if (context) {
        if (context.continueDestSegments) {
          makeLooped(this, forkContext.head, context.continueDestSegments);
          // If the context is a for-in/of loop, this effects a break also.
          if ((ref = context.type) === 'ForInStatement' || ref === 'ForOfStatement' || ref === 'For') {
            context.brokenForkContext.add(forkContext.head);
          }
        } else {
          context.continueForkContext.add(forkContext.head);
        }
      }
      return forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }

    /**
     * Makes a path for a `return` statement.
     *
     * It registers the head segment to a context of `return`.
     * It makes new unreachable segment, then it set the head with the segment.
     *
     * @returns {void}
     */
    makeReturn() {
      var forkContext;
      ({forkContext} = this);
      if (forkContext.reachable) {
        getReturnContext(this).returnedForkContext.add(forkContext.head);
        return forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
    }

    /**
     * Makes a path for a `throw` statement.
     *
     * It registers the head segment to a context of `throw`.
     * It makes new unreachable segment, then it set the head with the segment.
     *
     * @returns {void}
     */
    makeThrow() {
      var forkContext;
      ({forkContext} = this);
      if (forkContext.reachable) {
        getThrowContext(this).thrownForkContext.add(forkContext.head);
        return forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
    }

    /**
     * Makes the final path.
     * @returns {void}
     */
    makeFinal() {
      var segments;
      segments = this.currentSegments;
      if (segments.length > 0 && segments[0].reachable) {
        return this.returnedForkContext.add(segments);
      }
    }

  };

  /**
   * The head segments.
   * @type {CodePathSegment[]}
   */
  Object.defineProperty(CodePathState.prototype, 'headSegments', {
    get: function() {
      return this.forkContext.head;
    }
  });

  /**
   * The parent forking context.
   * This is used for the root of new forks.
   * @type {ForkContext}
   */
  Object.defineProperty(CodePathState.prototype, 'parentForkContext', {
    get: function() {
      var ref;
      return (ref = this.forkContext) != null ? ref.upper : void 0;
    }
  });

  module.exports = CodePathState;

}).call(this);
