// Generated by CoffeeScript 2.5.0
(function() {

  /**
   * parse docs from the first node that has leading comments
   */
  /**
   * parse JSDoc from leading comments
   * @param  {...[type]} comments [description]
   * @return {{doc: object}}
   */
  /**
   * parse TomDoc section from comments
   */
  /**
   * don't hold full context object in memory, just grab what we need.
   */
  /**
   * sometimes legacy support isn't _that_ hard... right?
   */
  /**
   * Traverse a pattern/identifier node, calling 'callback'
   * for each leaf identifier.
   * @param  {node}   pattern
   * @param  {Function} callback
   * @return {void}
   */
  /**
   * The creation of this closure is isolated from other scopes
   * to avoid over-retention of unrelated variables, which has
   * caused memory leaks. See #1266.
   */
  var ExportMap, SourceCode, availableDocStyleParsers, captureDoc, captureJsDoc, captureTomDoc, childContext, convertCommentToJsStyleJsdoc, debug, doctrine, exportCache, fs, hasValidExtension, hashObject, isIgnored, log, makeSourceCode, parse, recursivePatternCapture, resolve, thunkFor, unambiguous;

  fs = require('fs');

  doctrine = require('doctrine');

  ({
    default: debug
  } = require('debug'));

  ({SourceCode} = require('eslint'));

  ({
    default: parse
  } = require('eslint-module-utils/parse'));

  ({
    default: resolve
  } = require('eslint-module-utils/resolve'));

  ({
    default: isIgnored,
    hasValidExtension
  } = require('eslint-module-utils/ignore'));

  ({hashObject} = require('eslint-module-utils/hash'));

  unambiguous = require('eslint-module-utils/unambiguous');

  ({convertCommentToJsStyleJsdoc} = require('./util/ast-utils'));

  // {default: BaseExportMap} = require 'eslint-plugin-import/lib/ExportMap'
  log = debug('eslint-plugin-import:ExportMap');

  exportCache = new Map();

  ExportMap = class ExportMap { // extends BaseExportMap
    constructor(path) {
      this.path = path;
      this.namespace = new Map();
      // todo: restructure to key on path, value is resolver + map of names
      this.reexports = new Map();
      /**
       * star-exports
       * @type {Set} of () => ExportMap
       */
      this.dependencies = new Set();
      /**
       * dependencies of this module that are not explicitly re-exported
       * @type {Map} from path = () => ExportMap
       */
      this.imports = new Map();
      this.errors = [];
    }

    hasDefault() {
      return this.get('default') != null; // stronger than this.has
    }

    size() {
      var size;
      size = this.namespace.size + this.reexports.size;
      this.dependencies.forEach(function(dep) {
        var d;
        d = dep();
        // CJS / ignored dependencies won't exist (#717)
        if (d == null) {
          return;
        }
        return size += d.size;
      });
      return size;
    }

    /**
     * Note that this does not check explicitly re-exported names for existence
     * in the base namespace, but it will expand all `export * from '...'` exports
     * if not found in the explicit namespace.
     * @param  {string}  name
     * @return {Boolean} true if `name` is exported by this module.
     */
    has(name) {
      var dep, innerMap, ref;
      if (this.namespace.has(name)) {
        return true;
      }
      if (this.reexports.has(name)) {
        return true;
      }
      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        ref = this.dependencies;
        for (dep of ref) {
          innerMap = dep();
          // todo: report as unresolved?
          if (!innerMap) {
            continue;
          }
          if (innerMap.has(name)) {
            return true;
          }
        }
      }
      return false;
    }

    /**
     * ensure that imported name fully resolves.
     * @param  {[type]}  name [description]
     * @return {Boolean}      [description]
     */
    hasDeep(name) {
      var deep, dep, imported, innerMap, innerValue, reexports, ref;
      if (this.namespace.has(name)) {
        return {
          found: true,
          path: [this]
        };
      }
      if (this.reexports.has(name)) {
        reexports = this.reexports.get(name);
        imported = reexports.getImport();
        if (imported == null) {
          return {
            // if import is ignored, return explicit 'null'
            found: true,
            path: [this]
          };
        }
        if (imported.path === this.path && reexports.local === name) {
          return {
            // safeguard against cycles, only if name matches
            found: false,
            path: [this]
          };
        }
        deep = imported.hasDeep(reexports.local);
        deep.path.unshift(this);
        return deep;
      }
      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        ref = this.dependencies;
        for (dep of ref) {
          innerMap = dep();
          // todo: report as unresolved?
          if (!innerMap) {
            continue;
          }
          // safeguard against cycles
          if (innerMap.path === this.path) {
            continue;
          }
          innerValue = innerMap.hasDeep(name);
          if (innerValue.found) {
            innerValue.path.unshift(this);
            return innerValue;
          }
        }
      }
      return {
        found: false,
        path: [this]
      };
    }

    get(name) {
      var dep, imported, innerMap, innerValue, reexports, ref;
      if (this.namespace.has(name)) {
        return this.namespace.get(name);
      }
      if (this.reexports.has(name)) {
        reexports = this.reexports.get(name);
        imported = reexports.getImport();
        if (imported == null) {
          // if import is ignored, return explicit 'null'
          return null;
        }
        // safeguard against cycles, only if name matches
        if (imported.path === this.path && reexports.local === name) {
          return void 0;
        }
        return imported.get(reexports.local);
      }
      // default exports must be explicitly re-exported (#328)
      if (name !== 'default') {
        ref = this.dependencies;
        for (dep of ref) {
          innerMap = dep();
          // todo: report as unresolved?
          if (!innerMap) {
            continue;
          }
          // safeguard against cycles
          if (innerMap.path === this.path) {
            continue;
          }
          innerValue = innerMap.get(name);
          if (innerValue !== void 0) {
            return innerValue;
          }
        }
      }
      return void 0;
    }

    forEach(callback, thisArg) {
      this.namespace.forEach(function(v, n) {
        return callback.call(thisArg, v, n, this);
      });
      this.reexports.forEach(function(reexports, name) {
        var reexported;
        reexported = reexports.getImport();
        // can't look up meta for ignored re-exports (#348)
        return callback.call(thisArg, reexported != null ? reexported.get(reexports.local) : void 0, name, this);
      });
      return this.dependencies.forEach(function(dep) {
        var d;
        d = dep();
        // CJS / ignored dependencies won't exist (#717)
        if (d == null) {
          return;
        }
        return d.forEach(function(v, n) {
          return n !== 'default' && callback.call(thisArg, v, n, this);
        });
      });
    }

    // todo: keys, values, entries?
    reportErrors(context, declaration) {
      var getErrorColumnNumber, getErrorLineNumber;
      getErrorLineNumber = function(e) {
        if (e.lineNumber != null) {
          return e.lineNumber;
        }
        if (e.location == null) {
          return;
        }
        return e.location.first_line + 1;
      };
      getErrorColumnNumber = function(e) {
        if (e.column != null) {
          return e.column;
        }
        if (e.location == null) {
          return;
        }
        return e.location.first_column + 1;
      };
      return context.report({
        node: declaration.source,
        message: `Parse errors in imported module '${declaration.source.value}': ` + `${this.errors.map(function(e) {
          return `${e.message} (${getErrorLineNumber(e)}:${getErrorColumnNumber(e)})`;
        }).join(', ')}`
      });
    }

  };

  captureDoc = function(source, docStyleParsers, ...nodes) {
    var metadata;
    metadata = {};
    // 'some' short-circuits on first 'true'
    nodes.some(function(n) {
      var doc, docStyleParser, err, leadingComments, name;
      try {
        // n.leadingComments is legacy `attachComments` behavior
        if ('leadingComments' in n) {
          ({leadingComments} = n);
        } else if (n.range) {
          leadingComments = source.getCommentsBefore(n);
        }
        if (!(leadingComments != null ? leadingComments.length : void 0)) {
          return false;
        }
        for (name in docStyleParsers) {
          docStyleParser = docStyleParsers[name];
          doc = docStyleParser(leadingComments);
          if (doc) {
            metadata.doc = doc;
          }
        }
        return true;
      } catch (error) {
        err = error;
        return false;
      }
    });
    return metadata;
  };

  captureJsDoc = function(comments) {
    var doc;
    doc = void 0;
    // capture XSDoc
    comments.forEach(function(comment) {
      var err;
      // skip non-block comments
      if (comment.type !== 'Block') {
        return;
      }
      try {
        return doc = doctrine.parse(convertCommentToJsStyleJsdoc(comment.value), {
          unwrap: true
        });
      } catch (error) {
        // sloppy: yes
        // range: yes
        // strict: yes
        err = error;
      }
    });
    /* don't care, for now? maybe add to `errors?` */
    return doc;
  };

  captureTomDoc = function(comments) {
    var comment, i, lines, statusMatch;
    // collect lines up to first paragraph break
    lines = [];
    i = 0;
    while (i < comments.length) {
      comment = comments[i];
      if (comment.value.match(/^\s*$/)) {
        break;
      }
      lines.push(comment.value.trim());
      i++;
    }
    // return doctrine-like object
    statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\s*(.+)/);
    if (statusMatch) {
      return {
        description: statusMatch[2],
        tags: [
          {
            title: statusMatch[1].toLowerCase(),
            description: statusMatch[2]
          }
        ]
      };
    }
  };

  availableDocStyleParsers = {
    jsdoc: captureJsDoc,
    tomdoc: captureTomDoc
  };

  ExportMap.get = function(source, context) {
    var path;
    path = resolve(source, context);
    if (path == null) {
      return null;
    }
    return ExportMap.for(childContext(path, context));
  };

  ExportMap.for = function(context) {
    var cacheKey, content, exportMap, path, stats;
    ({path} = context);
    cacheKey = hashObject(context).digest('hex');
    exportMap = exportCache.get(cacheKey);
    // return cached ignore
    if (exportMap === null) {
      return null;
    }
    stats = fs.statSync(path);
    if (exportMap != null) {
      if (exportMap.mtime - stats.mtime === 0) {
        // date equality check
        return exportMap;
      }
    }
    // future: check content equality?

    // check valid extensions first
    if (!hasValidExtension(path, context)) {
      exportCache.set(cacheKey, null);
      return null;
    }
    // check for and cache ignore
    if (isIgnored(path, context)) {
      log('ignored path due to ignore settings:', path);
      exportCache.set(cacheKey, null);
      return null;
    }
    content = fs.readFileSync(path, {
      encoding: 'utf8'
    });
    // check for and cache unambigious modules
    if (!unambiguous.test(content)) {
      log('ignored path due to unambiguous regex:', path);
      exportCache.set(cacheKey, null);
      return null;
    }
    log('cache miss', cacheKey, 'for path', path);
    exportMap = ExportMap.parse(path, content, context);
    if (exportMap == null) {
      // ambiguous modules return null
      return null;
    }
    exportMap.mtime = stats.mtime;
    exportCache.set(cacheKey, exportMap);
    return exportMap;
  };

  ExportMap.parse = function(path, content, context) {
    var addNamespace, ast, captureDependency, docStyleParsers, docstyle, err, getNamespace, m, namespaces, ref, remotePath, resolveImport, source;
    m = new ExportMap(path);
    try {
      ast = parse(path, content, context);
    } catch (error) {
      err = error;
      log('parse error:', path, err);
      m.errors.push(err);
      return m; // can't continue
    }
    if (!unambiguous.isModule(ast)) {
      return null;
    }
    docstyle = ((ref = context.settings) != null ? ref['import/docstyle'] : void 0) || ['jsdoc'];
    docStyleParsers = {};
    docstyle.forEach(function(style) {
      return docStyleParsers[style] = availableDocStyleParsers[style];
    });
    // attempt to collect module doc
    if (ast.comments) {
      ast.comments.some(function(c) {
        var doc;
        if (c.type !== 'Block') {
          return false;
        }
        try {
          doc = doctrine.parse(convertCommentToJsStyleJsdoc(c.value), {
            unwrap: true
          });
          if (doc.tags.some(function(t) {
            return t.title === 'module';
          })) {
            m.doc = doc;
            return true;
          }
        } catch (error) {
          err = error;
        }
        /* ignore */
        return false;
      });
    }
    namespaces = new Map();
    remotePath = function(value) {
      return resolve.relative(value, path, context.settings);
    };
    resolveImport = function(value) {
      var rp;
      rp = remotePath(value);
      if (rp == null) {
        return null;
      }
      return ExportMap.for(childContext(rp, context));
    };
    getNamespace = function(identifier) {
      if (!namespaces.has(identifier.name)) {
        return;
      }
      return function() {
        return resolveImport(namespaces.get(identifier.name));
      };
    };
    addNamespace = function(object, identifier) {
      var nsfn;
      nsfn = getNamespace(identifier);
      if (nsfn) {
        Object.defineProperty(object, 'namespace', {
          get: nsfn
        });
      }
      return object;
    };
    captureDependency = function(declaration) {
      var existing, getter, hasImportedType, importedSpecifiers, p, supportedTypes;
      if (declaration.source == null) {
        return null;
      }
      if (declaration.importKind === 'type') { // skip Flow type imports
        return null;
      }
      importedSpecifiers = new Set();
      supportedTypes = new Set(['ImportDefaultSpecifier', 'ImportNamespaceSpecifier']);
      hasImportedType = false;
      if (declaration.specifiers) {
        declaration.specifiers.forEach(function(specifier) {
          var isType;
          isType = specifier.importKind === 'type';
          hasImportedType || (hasImportedType = isType);
          if (supportedTypes.has(specifier.type) && !isType) {
            importedSpecifiers.add(specifier.type);
          }
          if (specifier.type === 'ImportSpecifier' && !isType) {
            return importedSpecifiers.add(specifier.imported.name);
          }
        });
      }
      // only Flow types were imported
      if (hasImportedType && importedSpecifiers.size === 0) {
        return null;
      }
      p = remotePath(declaration.source.value);
      if (p == null) {
        return null;
      }
      existing = m.imports.get(p);
      if (existing != null) {
        return existing.getter;
      }
      getter = thunkFor(p, context);
      m.imports.set(p, {
        getter,
        source: {
          // capturing actual node reference holds full AST in memory!
          value: declaration.source.value,
          loc: declaration.source.loc
        },
        importedSpecifiers
      });
      return getter;
    };
    source = makeSourceCode(content, ast);
    ast.body.forEach(function(n) {
      var exportMeta, getter, left, moduleDecls, ns, nsource, ref1;
      if (n.type === 'ExportDefaultDeclaration') {
        exportMeta = captureDoc(source, docStyleParsers, n);
        if (n.declaration.type === 'Identifier') {
          addNamespace(exportMeta, n.declaration);
        }
        m.namespace.set('default', exportMeta);
        return;
      }
      if (n.type === 'ExportAllDeclaration') {
        getter = captureDependency(n);
        if (getter) {
          m.dependencies.add(getter);
        }
        return;
      }
      // capture namespaces in case of later export
      if (n.type === 'ImportDeclaration') {
        captureDependency(n);
        ns = null;
        if (n.specifiers.some(function(s) {
          return s.type === 'ImportNamespaceSpecifier' && (ns = s);
        })) {
          namespaces.set(ns.local.name, n.source.value);
        }
        return;
      }
      if (n.type === 'ExportNamedDeclaration') {
        // capture declaration
        if (n.declaration != null) {
          switch (n.declaration.type) {
            case 'FunctionDeclaration':
            case 'ClassDeclaration':
            case 'TypeAlias':
            case 'InterfaceDeclaration':
            case 'DeclareFunction':
            case 'TSDeclareFunction':
            case 'TSEnumDeclaration':
            case 'TSTypeAliasDeclaration':
            case 'TSInterfaceDeclaration':
            case 'TSAbstractClassDeclaration':
            case 'TSModuleDeclaration':
              m.namespace.set(n.declaration.id.name, captureDoc(source, docStyleParsers, n)); // flowtype with babel-eslint parser
              break;
            case 'VariableDeclaration':
              n.declaration.declarations.forEach(function(d) {
                return recursivePatternCapture(d.id, function(id) {
                  return m.namespace.set(id.name, captureDoc(source, docStyleParsers, d, n));
                });
              });
              break;
            case 'AssignmentExpression':
              ({left} = n.declaration);
              if (left.type === 'Identifier') {
                m.namespace.set(left.name, captureDoc(source, docStyleParsers, n));
              }
          }
        }
        nsource = (ref1 = n.source) != null ? ref1.value : void 0;
        n.specifiers.forEach(function(s) {
          var local;
          exportMeta = {};
          switch (s.type) {
            case 'ExportDefaultSpecifier':
              if (!n.source) {
                return;
              }
              local = 'default';
              break;
            case 'ExportNamespaceSpecifier':
              m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {
                get: function() {
                  return resolveImport(nsource);
                }
              }));
              return;
            case 'ExportSpecifier':
              if (!n.source) {
                m.namespace.set(s.exported.name, addNamespace(exportMeta, s.local));
                return;
              }
              local = s.local.name;
              break;
            default:
              local = s.local.name;
          }
          // todo: JSDoc
          return m.reexports.set(s.exported.name, {
            local,
            getImport: function() {
              return resolveImport(nsource);
            }
          });
        });
      }
      // This doesn't declare anything, but changes what's being exported.
      if (n.type === 'TSExportAssignment') {
        moduleDecls = ast.body.filter(function(bodyNode) {
          return bodyNode.type === 'TSModuleDeclaration' && bodyNode.id.name === n.expression.name;
        });
        return moduleDecls.forEach(function(moduleDecl) {
          if ((moduleDecl != null ? moduleDecl.body : void 0) && moduleDecl.body.body) {
            return moduleDecl.body.body.forEach(function(moduleBlockNode) {
              var exportedDecl;
              // Export-assignment exports all members in the namespace, explicitly exported or not.
              exportedDecl = moduleBlockNode.type === 'ExportNamedDeclaration' ? moduleBlockNode.declaration : moduleBlockNode;
              if (exportedDecl.type === 'VariableDeclaration') {
                return exportedDecl.declarations.forEach(function(decl) {
                  return recursivePatternCapture(decl.id, function(id) {
                    return m.namespace.set(id.name, captureDoc(source, docStyleParsers, decl, exportedDecl, moduleBlockNode));
                  });
                });
              } else {
                return m.namespace.set(exportedDecl.id.name, captureDoc(source, docStyleParsers, moduleBlockNode));
              }
            });
          }
        });
      }
    });
    return m;
  };

  thunkFor = function(p, context) {
    return function() {
      return ExportMap.for(childContext(p, context));
    };
  };

  recursivePatternCapture = function(pattern, callback) {
    switch (pattern.type) {
      case 'Identifier': // base case
        return callback(pattern);
      case 'ObjectPattern':
        return pattern.properties.forEach(function(p) {
          return recursivePatternCapture(p.value, callback);
        });
      case 'ArrayPattern':
        return pattern.elements.forEach(function(element) {
          if (element == null) {
            return;
          }
          return recursivePatternCapture(element, callback);
        });
      case 'AssignmentPattern':
        return callback(pattern.left);
    }
  };

  childContext = function(path, context) {
    var parserOptions, parserPath, settings;
    ({settings, parserOptions, parserPath} = context);
    return {settings, parserOptions, parserPath, path};
  };

  makeSourceCode = function(text, ast) {
    if (SourceCode.length > 1) {
      // ESLint 3
      return new SourceCode(text, ast);
    } else {
      // ESLint 4, 5
      return new SourceCode({text, ast});
    }
  };

  module.exports = {
    default: ExportMap
  };

}).call(this);
