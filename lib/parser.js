// Generated by CoffeeScript 2.5.0
(function() {
  var CodePathAnalyzer, CoffeeScript, KEYS, PATCH_CODE_PATH_ANALYSIS_PROGRAM_NODE_KEY, analyzeScope, babelTraverse, babylonToEspree, babylonTokenTypes, espreeTokenTypes, extend, extendVisitorKeys, flatten, getEspreeTokenType, getParser, getTokenValue, locationDataToAst, parseForESLint, patchBabelTypes, patchCodePathAnalysis, patchImportExportMap, repeat, tokensForESLint;

  CoffeeScript = require('coffeescript');

  ({
    jisonLocationDataToAstLocationData: locationDataToAst
  // traverseBabylonAst
  } = require('coffeescript/lib/coffeescript/nodes'));

  // babylonToEspree = require '../node_modules/babel-eslint/babylon-to-espree'
  babylonToEspree = require('babel-eslint/babylon-to-espree');

  babelTraverse = require('babel-traverse').default;

  babylonTokenTypes = require('babylon').tokTypes;

  ({
    flatten,
    assign: extend,
    repeat
  } = require('lodash'));

  ({patchCodePathAnalysis, PATCH_CODE_PATH_ANALYSIS_PROGRAM_NODE_KEY} = require('./patch-code-path-analysis'));

  patchImportExportMap = require('./patch-import-export-map');

  patchBabelTypes = require('./patch-babel-types');

  // patchReact = require './patch-react'
  analyzeScope = require('./analyze-scope');

  CodePathAnalyzer = require('./code-path-analysis/code-path-analyzer');

  ({KEYS} = require('eslint-visitor-keys'));

  extendVisitorKeys = function() {
    var t;
    t = require('babel-types');
    return extend(t.VISITOR_KEYS, {
      For: ['index', 'name', 'source', 'step', 'guard', 'body'],
      InterpolatedRegExpLiteral: ['expressions'],
      Range: ['from', 'to'],
      OptionalMemberExpression: ['object', 'property'],
      OptionalCallExpression: ['callee', 'arguments'],
      ClassPrototypeProperty: ['key', 'value']
    });
  };

  espreeTokenTypes = {
    '{': 'Punctuator',
    '}': 'Punctuator',
    '[': 'Punctuator',
    ']': 'Punctuator',
    '(': 'Punctuator',
    ')': 'Punctuator',
    CALL_START: 'Punctuator',
    CALL_END: 'Punctuator',
    PARAM_START: 'Punctuator',
    PARAM_END: 'Punctuator',
    INDEX_START: 'Punctuator',
    INDEX_END: 'Punctuator',
    INTERPOLATION_START: 'Punctuator',
    INTERPOLATION_END: 'Punctuator',
    STRING_START: 'Punctuator',
    STRING_END: 'Punctuator',
    '=>': 'Punctuator',
    '->': 'Punctuator',
    ',': 'Punctuator',
    ':': 'Punctuator',
    '.': 'Punctuator',
    '::': 'Punctuator',
    '+': 'Punctuator',
    '++': 'Punctuator',
    '-': 'Punctuator',
    '--': 'Punctuator',
    '**': 'Punctuator',
    MATH: 'Punctuator',
    '=': 'Punctuator',
    '||': 'Punctuator',
    '&&': 'Punctuator',
    '|': 'Punctuator',
    'BIN?': 'Punctuator',
    COMPOUND_ASSIGN: 'Punctuator',
    UNARY_MATH: 'Punctuator',
    '<': 'Punctuator',
    '>': 'Punctuator',
    '/': 'Punctuator',
    RELATION: 'Keyword',
    THEN: 'Keyword',
    LEADING_WHEN: 'Keyword',
    DO: 'Keyword',
    DO_IIFE: 'Keyword',
    WHILE: 'Keyword',
    UNTIL: 'Keyword',
    THROW: 'Keyword',
    SWITCH: 'Keyword',
    RETURN: 'Keyword',
    FOR: 'Keyword',
    FOROF: 'Keyword',
    IF: 'Keyword',
    ELSE: 'Keyword',
    POST_IF: 'Keyword',
    CLASS: 'Keyword',
    EXTENDS: 'Keyword',
    TRY: 'Keyword',
    CATCH: 'Keyword',
    FINALLY: 'Keyword',
    REGEX: 'RegularExpression',
    IDENTIFIER: 'Identifier',
    AWAIT: 'Identifier',
    PROPERTY: 'Identifier',
    STRING: 'String',
    NUMBER: 'Numeric'
  };

  getEspreeTokenType = function(token) {
    var original, ref, ref1, ref2, type, value;
    [type, value] = token;
    ({original} = value);
    if (original != null) {
      value = original;
    }
    if (type === ',' && value === 'JSX_COMMA') {
      return 'JSX_COMMA';
    }
    if (type === 'STRING' && ((ref = token.data) != null ? ref.jsx : void 0)) {
      return 'JSXText';
    }
    if (token.jsxIdentifier || (type === 'PROPERTY' && ((ref1 = token.data) != null ? ref1.jsx : void 0))) {
      return 'JSXIdentifier';
    }
    if ((type === 'UNARY' && (value === 'typeof' || value === 'new' || value === 'delete' || value === 'not')) || (type === 'COMPARE' && (value === 'is' || value === 'isnt'))) {
      return 'Keyword';
    }
    return (ref2 = espreeTokenTypes[type]) != null ? ref2 : type;
  };

  getTokenValue = function(token) {
    var range, ref, ref1, type, value;
    [type, value, {range}] = token;
    if (type === 'INTERPOLATION_START') {
      return (range[1] - range[0] === 1 ? '{' : '#{');
    }
    if (type === 'INTERPOLATION_END') {
      return '}';
    }
    if (type === 'STRING_START' || type === 'STRING_END') {
      return repeat('"', range[1] - range[0]);
    }
    if (type === 'STRING' && ((ref = token.data) != null ? ref.jsx : void 0)) {
      return value.slice(1, -1);
    }
    if (token.jsxColon) {
      return '=';
    }
    return (ref1 = value.original) != null ? ref1 : value.toString();
  };

  // extraTokensForESLint = (ast) ->
  //   extraTokens = []
  //   traverseBabylonAst ast, (node) ->
  //     return unless node
  //     {extra: {parenthesized} = {}, start, end} = node
  //     return unless parenthesized
  //     extraTokens.push
  //       type: '('
  //       value: '('
  //       start: start - 1
  //       end: start
  //     ,
  //       type: ')'
  //       value: ')'
  //       start: end
  //       end: end + 1
  //   extraTokens.sort ({start: firstStart}, {start: secondStart}) ->
  //     if firstStart < secondStart then -1 else 1
  // tokensForESLint = ({tokens, ast}) ->
  tokensForESLint = function({tokens}) {
    var locationData, spreadTokens, token;
    // extraTokens = extraTokensForESLint ast
    // popExtraTokens = ({nextStart}) ->
    //   popped = []
    //   while (
    //     (nextExtra = extraTokens[0]) and
    //     (nextStart is 'END' or nextExtra.start < nextStart)
    //   )
    //     popped.push extraTokens.shift()
    //   popped
    return flatten([
      ...((function() {
        var i,
      len,
      ref,
      ref1,
      ref2,
      ref3,
      ref4,
      ref5,
      ref6,
      ref7,
      results;
// excluding INDENT/OUTDENT seems necessary to avoid eslint createIndexMap() potentially choking on comment/token with same start location
// espree doesn't seem to include tokens for \n
        results = [];
        for (i = 0, len = tokens.length; i < len; i++) {
          token = tokens[i];
          if (!(!(token.generated && !(token.fromThen || token.prevToken || ((ref = token.data) != null ? ref.closingBracketToken : void 0) || ((ref1 = token.data) != null ? ref1.closingTagClosingBracketToken : void 0))) && !(token[0] === 'OUTDENT' && ((ref2 = token.prevToken) != null ? ref2[1] : void 0) !== ';') && !(token[0] === 'TERMINATOR' && token[1] !== ';') && !(token[0] === 'INDENT' && !token.fromThen) && !(token[0] === 'STRING' && token[1].length === 2 && token[2].range[1] - token[2].range[0] < 2))) {
            continue;
          }
          if (((ref3 = token.prevToken) != null ? ref3[1] : void 0) === ';') {
            token = token.prevToken;
          }
          if (token.fromThen) {
            token = token.origin;
          }
          spreadTokens = ((ref4 = token.data) != null ? ref4.openingBracketToken : void 0) ? token.data.tagNameToken[1].length ? (token.data.tagNameToken.jsxIdentifier = true,
      [token.data.openingBracketToken,
      token.data.tagNameToken]) : [token.data.openingBracketToken] : ((ref5 = token.data) != null ? ref5.selfClosingSlashToken : void 0) ? [token.data.selfClosingSlashToken,
      token.data.closingBracketToken] : ((ref6 = token.data) != null ? ref6.closingBracketToken : void 0) ? [token.data.closingBracketToken] : ((ref7 = token.data) != null ? ref7.closingTagClosingBracketToken : void 0) ? token.data.closingTagNameToken[1].length ? (token.data.closingTagNameToken.jsxIdentifier = true,
      [token.data.closingTagOpeningBracketToken,
      token.data.closingTagSlashToken,
      token.data.closingTagNameToken,
      token.data.closingTagClosingBracketToken]) : [token.data.closingTagOpeningBracketToken,
      token.data.closingTagSlashToken,
      token.data.closingTagClosingBracketToken] : [token];
          results.push((function() {
            var j,
      len1,
      results1;
            results1 = [];
            for (j = 0, len1 = spreadTokens.length; j < len1; j++) {
              token = spreadTokens[j];
              [,
      ,
      locationData] = token;
              results1.push({
                type: getEspreeTokenType(token),
                value: getTokenValue(token),
                ...locationDataToAst(locationData)
              });
            }
            return results1;
          })());
        }
        return results;
      })()),
      {}
    ]);
  };

  // ...popExtraTokens(nextStart: 'END')
  exports.getParser = getParser = function(getAst) {
    return function(code, opts) {
      var ast, comment, commentIndex, commentLocs, i, len, ref, ref1, ref2;
      if (!opts.eslintCodePathAnalyzer) {
        patchCodePathAnalysis();
      }
      patchImportExportMap();
      patchBabelTypes();
      // patchReact()
      // ESLint replaces shebang #! with //, but leading // could be part of a heregex
      if (/^\/\//.test(code)) {
        try {
          ast = getAst(code, opts);
        } catch (error) {
          code = code.replace(/^\/\//, '#');
          ast = getAst(code, opts);
        }
      } else {
        ast = getAst(code, opts);
      }
      ast.tokens = tokensForESLint(ast);
      // dump {tokens, transformedTokens: ast.tokens}
      extendVisitorKeys();
      commentLocs = (function() {
        var i, len, ref, ref1, results;
        ref1 = (ref = ast.comments) != null ? ref : [];
        results = [];
        for (i = 0, len = ref1.length; i < len; i++) {
          comment = ref1[i];
          results.push({
            start: {...comment.loc.start},
            end: {...comment.loc.end}
          });
        }
        return results;
      })();
      babylonToEspree(ast, babelTraverse, babylonTokenTypes, code);
      ref1 = (ref = ast.comments) != null ? ref : [];
      // babylonToEspree seems to like to change the file-leading comment's start line
      for (commentIndex = i = 0, len = ref1.length; i < len; commentIndex = ++i) {
        comment = ref1[commentIndex];
        comment.loc = commentLocs[commentIndex];
      }
      // ...and the Program's end range
      if (ast.type === 'Program') {
        ast.range[1] = ast.end;
      } else {
        if ((ref2 = ast.program) != null) {
          ref2.range[1] = ast.program.end;
        }
      }
      // eslint-scope will fail eg on ImportDeclaration's unless treated as module
      ast.sourceType = 'module';
      // hack to enable "dynamic monkeypatching" of code path analysis
      ast[PATCH_CODE_PATH_ANALYSIS_PROGRAM_NODE_KEY] = true;
      return {
        // dump espreeAst: ast
        ast,
        scopeManager: analyzeScope(ast, opts),
        visitorKeys: {
          ...KEYS,
          For: ['index', 'name', 'guard', 'step', 'source', 'body']
        },
        // Identifier: [...KEYS.Identifier, 'declaration']
        CodePathAnalyzer
      };
    };
  };

  exports.parseForESLint = parseForESLint = getParser(function(code, opts) {
    return CoffeeScript.compile(code, {
      ...opts,
      ast: true
    });
  });

  // eslint-plugin-import expects to fall back to calling parse() if
  // parseForESLint() fails.
  exports.parse = function(...args) {
    return parseForESLint(...args).ast;
  };

  // dump = (obj) -> console.log require('util').inspect obj, no, null

}).call(this);
